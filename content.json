[{"title":"java内存划分","date":"2020-02-29T12:06:14.126Z","path":"2020/02/29/java内存划分/","text":"Java内存Java的内存需要划分成5个部分： 1、栈（Stack）：存放的都是方法中的局部变量。方法的运行一定要在栈中运行。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;局部变量：方法的参数，或者是方法{}内部的变量 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用域：一旦超出作用域，立刻从栈内存中消失。 2、堆（Heap）：凡是new出来的东西，都在堆当中。 ​ 堆内存里面的东西都有一个地址值：16进制 ​ 堆内存里面的数据，都有默认值。规则： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果是整数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值为0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果是浮点数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值是0.0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果是字符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值是’\\u0000’ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果是布尔&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值是false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果是引用类型&nbsp;&nbsp;&nbsp;&nbsp;默认值是null 3、方法区（Method Area）：存储.class相关信息，包含方法的信息。 4、本地方法栈（Native Method Stack）：与操作系统相关。 5、寄存器（pc Register）：与CPU相关。","categories":[],"tags":[]},{"title":"idea启动tomcat乱码问题","date":"2020-02-26T08:38:14.939Z","path":"2020/02/26/idea启动tomcat乱码问题/","text":"idea启动tomcat中文乱码解决方法第一次使用idea启动Tomcat的时候控制台可能出现中文乱码的问题 解决方法如下 1.设置项目编码为UTF-8 2.打开idea安装目录的bin目录下进入bin目录找到idea.exe.vmoptions和idea64.exe.vmoptions文件 在这两个文件里面加上如下代码 1-Dfile.encoding&#x3D;UTF-8 在idaeatomcat配置文件会出现该选择 然后重启idea 如果还是有乱码可能是idea的缓存问题 清除缓存重启就好了 清除缓存的方式 重启之后解决了乱码问题","categories":[],"tags":[]},{"title":"JavaWeb","date":"2020-02-19T13:27:16.795Z","path":"2020/02/19/JavaWeb/","text":"1、Web服务器1.1、技术讲解ASP： 微软：国内最早流行的就是ASP; 在HTML中嵌入了VB的脚本，ASP + COM； 在ASP开发中，基本一个页面都有几千行的业务代码，页面极其混乱 维护成本高 C# IIS php PHP开发速度很快，功能很强大，跨平台，代码很简单 无法承载大访问量的情况（局限性） JSP/Servlet： B/S：浏览器和服务器 C/S：客户端与服务器 sun公司主推的B/S架构 基本Java语言的（所有的大公司，或者一些开源的组件，都是java写的） 可以承载三高问题带来的影响；高并发，高可用，高性能 语法像ASP； 2、Web服务器服务器是一种被动的操作，用来接收用户的请求。 Tomcat服务器 Tomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同开发而成。由于有了Sun 的参与和支持，最新的Servlet 和JSP 规范总是能在Tomcat 中得到体现，Tomcat 5支持最新的Servlet 2.4 和JSP 2.0 规范。因为Tomcat 技术先进、性能稳定，而且免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。 Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。对于一个初学者来说，可以这样认为，当在一台机器上配置好Apache 服务器，可利用它响应HTML（标准通用标记语言下的一个应用）页面的访问请求。实际上Tomcat是Apache 服务器的扩展，但运行时它是独立运行的，所以当你运行tomcat 时，它实际上作为一个与Apache 独立的进程单独运行的。 3、Tomcat3.1、下载Tomcat服务器去Tomcat官网下载Tomcat过后解压即可使用。版本为8.5或者9.0 3.2、Tomcat的启动和部署双击bin文件夹下的startup启动，打开浏览器输入localhost:8080进入Tomcat网页即打开成功。 可能的问题： Java环境变量没有配置 闪退问题：需要配置兼容性 可以修改端口号： conf文件中的server.xml文件，第69行可以修改端 Tomcat：8080 mysql：3306 http：80 https：443 3.3 发布一个Web网站将自己写的网站，放到服务器（Tomcat）中指定的web应用的文件夹（webapps）下，就可以访问了 目录结构： 12345678910111213--webapps：Tomcat服务器的web目录 -ROOT -xxxxxx：自己网站的目录名 -WEB-INF -classes：java程序 -lib：web应用所依赖的jar包 -web.xml ：网站配置文件 -index.html -static -css -style.css -js -img 4、HTTP4.1、什么是HTTPhttp是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。 传输： 文本：html，字符串 超文本：图片，音乐，视频，定位，地图。。。。 80 https：安全的 443 4.2 两个时代 http 1.0 HTTP/1.0：客户端可以与web服务器连接后，只能获得一个web资源，如果请求失败，断开连接 http 2.0 HTTP/1.1：客户端可以与web服务器连接后，获得多个web资源 4.3、Http请求 客户端—发请求—服务器 百度： 12345Request URL: https://www.baidu.com/Request Method: GET Status Code: 200 OK Remote Address: 14.215.177.38:443Referrer Policy: no-referrer-when-downgrade 12345Accept: text/html;Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9Cache-Control: max-age=0Connection: keep-alive 1、请求行 请求行中的请求方式：GET 请求方式：Get，Post，HEAD，Delete，put，tract get：请求能够携带的参数比较少，大小有限制，会在浏览器地址栏显示内容，不安全，但高效。 post：请求能够携带的参数没有限制，大小没有限制，不会在浏览器地址栏显示内容，安全，但不高效。 2、消息头123456Accept: 告诉浏览器，他所支持的数据类型Accept-Encoding: 支持哪种编码格式Accept-Language: 告诉浏览器，他的语言环境Cache-Control: 缓存控制Connection: 告诉浏览器，请求完成是断开还是保持连接HOST：主机 4.4、Http响应 服务器—响应—客户端 百度： 1234Cache-Control: private 缓存控制Connection: keep-alive 保持连接Content-Encoding: gzip 编码Content-Type: text/html;charset=utf-8 类型 1、响应头12345678Accept: 告诉浏览器，他所支持的数据类型Accept-Encoding: 支持哪种编码格式Accept-Language: 告诉浏览器，他的语言环境Cache-Control: 缓存控制Connection: 告诉浏览器，请求完成是断开还是保持连接HOST：主机Refresh：告诉浏览器，多久刷新一次Location：让网页重新定位 2、响应状态码（重点）200：请求响应成功 404：找不到资源 3xx：请求重定向 重定向：你重新到我给你的新位置去 5xx：500服务器代码错误 502网关错误 常见面试题： 当你的浏览器中地址栏输入地址并回车的一瞬间到页面能够展示回来，经历了什么？ 5、Maven1、在javaweb开发中，需要使用大量的jar包，我们手动去导入 2、如何能够让一个东西自动帮我导入和配置这个jar包，由此maven诞生了 5.1、Maven项目架构管理工具我们目前用来导入jar包的 Maven的核心思想：约定大于配置 有约束，不要去违反 Maven会规定好你该如何去编写我们的java代码，必须要按照这个规范来 5.2、下载安装Maven5.3、配置环境变量 M2_HOME maven目录下的bin目录 MAVEN_HOME maven的目录 在系统的path中配置 %MAVEN_HOME%\\bin 5.4、配置阿里云镜像目录中conf文件夹下的setting.xml 镜像：mirrors 作用：加速我们的下载 国内建议使用阿里云的镜像（百度搜） 12345&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;*,!jeecg,!jeecg-snapshots&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt; 5.5、本地仓库目录中conf文件夹下的setting.xml 在本地的仓库，远程的仓库； 建立一个本地仓库： 在maven的目录建立文件夹：maven-repo 修改localrepository中的默认地址，指向maven-repo 5.6、在IDEA中使用Maven1、创建一个Maven项目 idea自动导入包，会去阿里云下载很多的配置文件。都保存在maven-repo本地仓库中。 检查maven配置 可以在如下图片处，配置文件标记 5.7 在IDEA中配置Tomcat5.8、pom.xmlpom.xml是maven的核心配置文件 5.9、存在问题1、maven由于他的约定大于配置，我们之后可能会遇到我们写的配置文件，无法被到处或者生效的问题，解决方案： ​ 在web.xml的build下面加个resources 123456789101112131415161718&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt; &lt;excludes&gt; &lt;exclude&gt;**&#x2F;*.properties&lt;&#x2F;exclude&gt; &lt;exclude&gt;**&#x2F;*.xml&lt;&#x2F;exclude&gt; &lt;&#x2F;excludes&gt; &lt;filtering&gt;false&lt;&#x2F;filtering&gt; &lt;&#x2F;resource&gt; &lt;resource&gt; &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt; &lt;includes&gt; &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt; &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt; &lt;&#x2F;includes&gt; &lt;filtering&gt;false&lt;&#x2F;filtering&gt; &lt;&#x2F;resource&gt; &lt;&#x2F;resources&gt; 在build中配置resources解决此问题。 2、maven 3.6.2 ​ ​ 解决方法：降低到版本3.6.1 3、Tomcat闪退： ​ 解决方法：配置%JAVA_HOME% 4、IDEA中每次都要重复配置Maven ​ 解决方法：在全局配置中设置，不要设置项目。 5、maven默认web项目中的web.xml的版本问题 ​ 解决方法：直接复制Tomcat中的默认web.xml的配置信息 6、Servletsun公司Servlet接口默认的两个实现类：GenericServlet、HttpServlet 6.1、Servlet简介 Servlet就是sun公司开发动态web的一门技术 sun在这些API中提供一个借口叫作：Servlet，如果你想开发一个Servlet程序，只需要完成两个小步骤： 编写一个类：实现Servlet接口 把开发好的Java类部署到web服务器中。 把实现了Servlet接口的Java程序叫作，Servlet 6.2、HttpServlet1、构建一个普通的Maven项目，删掉里面的src项目，以后我们的学习就在这个项目里面建立Moudel；这个空的工程就是Maven主工程； 2、关于Servlet父子工程 父项目的pom.xml中会有 123&lt;modules&gt; &lt;module&gt;servlet-01&lt;/module&gt;&lt;/modules&gt; 父项目的pom.xml中会有 12345&lt;parent&gt; &lt;artifactId&gt;javaweb-02-servlet&lt;/artifactId&gt; &lt;groupId&gt;com.ght&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/parent&gt; 3、Maven环境优化 修改web.xml为最新版本 将maven的结构搭建完整 4、编写一个Servlet程序 编写一个普通类 实现Servlet接口： 12345678910111213public class HelloServlet extends HttpServlet &#123; //由于get或者post只是请求实现的不同的方式，可以相互调用，业务逻辑都一样； @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; PrintWriter writer = resp.getWriter(); writer.print(\"hello，Servlet\"); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; 5、编写Servlet的映射 ​ 为什么需要映射：因为写的是Java程序，但是要通过浏览器访问，而浏览器需要连接web服务器，所以我们需要在web服务中注册我们写的Servlet 12345678910&lt;!--注册Servlet--&gt;&lt;servlet&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;servlet-class&gt;com.ght.servlet.HelloServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 6、配置Tomcat 7、启动测试 6.3、Mapping问题一个Servlet可以指定一个映射路径 一个Servlet可以指定多个映射路径 一个Servlet可以指定通用映射路径 可以自定义后缀实现请求映射 *.xxxx。 注：不能xxx/*.xxxx 优先级问题 指定了固有的映射路径优先级最高，如果找不到就会走默认的处理请求 6.4、ServletContextweb容器在启动的时候，它会为每个web 程序都创建一个ServletContext对象，它代表当前的web应用： 获取context对象： 1ServletContext context = this.getServletContext(); 1、共享数据我在这个Servlet中保存的数据，可以在另外一个servlet中拿到 setcontext.java 12345678910111213141516171819202122232425package com.ght.servlet;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class setcontext extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setContentType(\"text/html\"); resp.setCharacterEncoding(\"utf-8\"); ServletContext context = this.getServletContext(); String username = \"小明\"; context.setAttribute(\"username\",username); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; getcontext.java 123456789101112131415161718192021222324252627package com.ght.servlet;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.Writer;public class getcontext extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setContentType(\"text/html\"); resp.setCharacterEncoding(\"utf-8\"); ServletContext context = this.getServletContext(); String username = (String)context.getAttribute(\"username\"); resp.getWriter().print(\"名字\"+username); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; web.xml 1234567891011121314151617181920212223242526272829303132&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" version=\"3.1\" metadata-complete=\"true\"&gt; &lt;servlet&gt; &lt;servlet-name&gt;set&lt;/servlet-name&gt; &lt;servlet-class&gt;com.ght.servlet.setcontext&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;set&lt;/servlet-name&gt; &lt;url-pattern&gt;/set&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;get&lt;/servlet-name&gt; &lt;servlet-class&gt;com.ght.servlet.getcontext&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;get&lt;/servlet-name&gt; &lt;url-pattern&gt;/get&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 2、获取初始化参数12345678910111213141516171819202122package com.ght.servlet;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class servletDemo03 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; ServletContext context = this.getServletContext(); String url = context.getInitParameter(\"url\"); resp.getWriter().print(url); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; web.xml 12345678&lt;servlet&gt; &lt;servlet-name&gt;gp&lt;/servlet-name&gt; &lt;servlet-class&gt;com.ght.servlet.servletDemo03&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;gp&lt;/servlet-name&gt; &lt;url-pattern&gt;/gp&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 3、请求转发浏览器地址不会改变 转发到/gp，/gp指向ServletDemo03 123456789101112131415161718192021package com.ght.servlet;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class ServletDemo04 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; ServletContext context = this.getServletContext(); context.getRequestDispatcher(\"/gp\").forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; web.xml 12345678&lt;servlet&gt; &lt;servlet-name&gt;sd4&lt;/servlet-name&gt; &lt;servlet-class&gt;com.ght.servlet.ServletDemo04&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;sd4&lt;/servlet-name&gt; &lt;url-pattern&gt;/sd4&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 4、读取配置文件​ properties 在Java目录下新建properties 在resources目录下新建properties 发现：都被打包到了同一个路径下：classes，我们称这个路径为classpath 使用流将读取配置文件中的信息 123456789101112131415161718192021222324252627package com.ght.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.InputStream;import java.util.Properties;public class ServletDemo05 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; InputStream is = this.getServletContext().getResourceAsStream(\"/WEB-INF/classes/aa.properties\"); Properties prop = new Properties(); prop.load(is); String user = prop.getProperty(\"username\"); String pass = prop.getProperty(\"password\"); resp.getWriter().print(user+\":\"+pass); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; aa.properties 12username=rootpassword=123456 6.5、HttpServletResponseWeb服务器接受到客户端的http请求，针对这个请求，分别创建一个代表请求的HttpServletRequest对象，代表响应的一个HttpServletResponse； 如果要获取客户端请求过来的参数：找HttpServletRequest 如果要给客户端响应一些信息：找HttpServletResponse 1、简单分类负责向浏览器发送数据的方法 12ServletOutputStream getOutputStream() throws IOException;PrintWriter getWriter() throws IOException; 负责向浏览器发送响应头的方法 12345678910111213141516171819void setCharacterEncoding(String var1);void setContentLength(int var1);void setContentLengthLong(long var1);void setContentType(String var1); void setDateHeader(String var1, long var2);void addDateHeader(String var1, long var2);void setHeader(String var1, String var2);void addHeader(String var1, String var2);void setIntHeader(String var1, int var2);void addIntHeader(String var1, int var2); 2、下载文件1、下载文件 要获取下载文件的路径 下载的文件名 设置让浏览器支持下载我们需要的东西 获取下载文件的输入流 创建缓冲区 获取OutputStream对象 将FileOutputStream流写入buffer缓冲区 使用OutputStream将缓冲区中的数据输出到客户端 12345678910111213141516171819202122232425262728293031323334353637383940package com.ght.servlet;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.FileInputStream;import java.io.IOException;import java.net.URLEncoder;public class FileServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1. 要获取下载文件的路径 String filepath = \"D:\\\\environment\\\\javaweb-02-servlet\\\\response\\\\src\\\\main\\\\resources\\\\图片.png\"; //2. 下载的文件名 String fileName = filepath.substring(filepath.lastIndexOf(\"\\\\\")+1); //3. 设置让浏览器支持下载(\"Content-Disposition\")我们需要的东西,设置编码防止中文文件名乱码的情况 resp.setHeader(\"Content-Disposition\",\"attachment;filename=\"+URLEncoder.encode(fileName,\"UTF-8\")); //4. 获取下载文件的输入流 FileInputStream in = new FileInputStream(filepath); //5. 创建缓冲区 int len = 0; byte[] buffer = new byte[1024]; //6. 获取OutputStream对象 ServletOutputStream out = resp.getOutputStream(); //7. 将FileOutputStream流写入buffer缓冲区,使用OutputStream将缓冲区中的数据输出到客户端 while((len=in.read(buffer)) != -1) &#123; out.write(buffer, 0, len); &#125; in.close(); out.close(); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; 3、验证码功能验证码怎么来的？ 现在前后端分离时代。 前端实现 后端实现，需要用到Java的图片类，生产一个图片 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.ght.servlet;import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.awt.*;import java.awt.image.BufferedImage;import java.io.IOException;import java.util.Random;public class ImageServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //如何让浏览器3秒刷新一次 resp.setHeader(\"refresh\",\"3\"); //在内存中创建一个图片 BufferedImage image = new BufferedImage(80,20,BufferedImage.TYPE_INT_RGB); //得到图片 Graphics2D g = (Graphics2D)image.getGraphics();//笔 //设置背景图片颜色 g.setColor(Color.white); g.fillRect(0,0,80,20); //给图片写数据 g.setColor(Color.BLUE); g.setFont(new Font(null,Font.BOLD,20)); g.drawString(makeNum(),0,20); //告诉浏览器，这个请求用图片的方式打开 resp.setContentType(\"image/jpeg\"); //网站存在缓存，不让浏览器缓存 resp.setDateHeader(\"expires\",-1); resp.setHeader(\"Cache-Control\",\"no-cache\"); resp.setHeader(\"Pragme\",\"no-cache\"); //把图片写在浏览器 ImageIO.write(image,\"jpg\",resp.getOutputStream()); &#125; private String makeNum()&#123; Random random = new Random(); String num = random.nextInt(9999999)+\"\"; StringBuffer sb = new StringBuffer(); //如果生成的数没有7位，就用0补全 for (int i = 0; i &lt; 7-num.length() ; i++) &#123; sb.append(\"0\"); &#125; num = sb.toString()+num; return num; &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; 不要忘记在web.xml中注册 4、实现重定向（重点） 一个web资源B收到客户端A请求后，B会通知A客户端去访问另一个web资源C，这个过程叫重定向。 常见场景： 用户登录（登录成功后请求另一个界面） index.jsp 12345678910111213&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Login&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"/login\" method=\"post\"&gt; 账号：&lt;input type=\"text\" name=\"username\"&gt; 密码：&lt;input type=\"password\" name=\"password\"&gt; &lt;input type=\"submit\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; responsetest.java 12345678910111213141516171819202122package com.ght.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class Responsetest extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String username = req.getParameter(\"username\"); String password = req.getParameter(\"password\"); resp.sendRedirect(\"/success.jsp\"); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; 面试题：请你聊聊重定向和转发的区别？ 相同点： 页面都会实现跳转 不同点： 请求转发的时候，url不会产生变化； 重定向的时候，url地址栏会发生变化； 6.6、HttpServletRequest获取前端参数的值、请求转发12345678910111213141516171819202122232425262728293031package com.ght.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.Arrays;public class RequestTest extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.setCharacterEncoding(\"utf-8\"); resp.setCharacterEncoding(\"utf-8\"); String username = req.getParameter(\"username\"); String password = req.getParameter(\"password\"); String[] hobbies = req.getParameterValues(\"hobbies\"); System.out.println(username); System.out.println(password); System.out.println(Arrays.toString(hobbies)); //请求转发这里的/是代表当前的web项目 req.getRequestDispatcher(\"/success.jsp\").forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; 1234567891011121314151617&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;login&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"/login\" method=\"post\"&gt; 用户名：&lt;input name=\"username\"&gt; 密码：&lt;input type=\"password\" name=\"password\"&gt; &lt;input type=\"checkbox\" name=\"hobbies\" value=\"唱歌\"&gt;唱歌 &lt;input type=\"checkbox\" name=\"hobbies\" value=\"电影\"&gt;电影 &lt;input type=\"checkbox\" name=\"hobbies\" value=\"读书\"&gt;读书 &lt;input type=\"submit\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"javaweb","slug":"javaweb","permalink":"http://yoursite.com/tags/javaweb/"}]},{"title":"Java面向对象_11.作用域","date":"2020-02-18T03:34:33.938Z","path":"2020/02/18/Java面向对象_11/","text":"在Java中，我们经常看到public、protected、private这些修饰符。在Java中，这些修饰符可以用来限定访问作用域。 public定义为public的class、interface可以被其他任何类访问： 123456package abc;public class Hello &#123; public void hi() &#123; &#125;&#125; 上面的Hello是public，因此，可以被其他包的类访问： 12345678package xyz;class Main &#123; void foo() &#123; &#x2F;&#x2F; Main可以访问Hello Hello h &#x3D; new Hello(); &#125;&#125; 定义为public的field、method可以被其他类访问，前提是首先有访问class的权限： 123456package abc;public class Hello &#123; public void hi() &#123; &#125;&#125; 上面的hi()方法是public，可以被其他类调用，前提是首先要能访问Hello类： 12345678package xyz;class Main &#123; void foo() &#123; Hello h &#x3D; new Hello(); h.hi(); &#125;&#125; private定义为private的field、method无法被其他类访问： 1234567891011package abc;public class Hello &#123; &#x2F;&#x2F; 不能被其他类调用: private void hi() &#123; &#125; public void hello() &#123; this.hi(); &#125;&#125; 实际上，确切地说，private访问权限被限定在class的内部，而且与方法声明顺序无关。推荐把private方法放到后面，因为public方法定义了类对外提供的功能，阅读代码的时候，应该先关注public方法： 12345678910package abc;public class Hello &#123; public void hello() &#123; this.hi(); &#125; private void hi() &#123; &#125;&#125; 由于Java支持嵌套类，如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问private的权限： 123456789101112131415161718public class Main &#123; public static void main(String[] args) &#123; Inner i &#x3D; new Inner(); i.hi(); &#125; &#x2F;&#x2F; private方法: private static void hello() &#123; System.out.println(&quot;private hello!&quot;); &#125; &#x2F;&#x2F; 静态内部类: static class Inner &#123; public void hi() &#123; Main.hello(); &#125; &#125;&#125; 定义在一个class内部的class称为嵌套类（nested class），Java支持好几种嵌套类。 protectedprotected作用于继承关系。定义为protected的字段和方法可以被子类访问，以及子类的子类： 1234567package abc;public class Hello &#123; &#x2F;&#x2F; protected方法: protected void hi() &#123; &#125;&#125; 上面的protected方法可以被继承的类访问： 123456789package xyz;class Main extends Hello &#123; void foo() &#123; Hello h &#x3D; new Hello(); &#x2F;&#x2F; 可以访问protected方法: h.hi(); &#125;&#125; package最后，包作用域是指一个类允许访问同一个package的没有public、private修饰的class，以及没有public、protected、private修饰的字段和方法。 1234567package abc;&#x2F;&#x2F; package权限的类:class Hello &#123; &#x2F;&#x2F; package权限的方法: void hi() &#123; &#125;&#125; 只要在同一个包，就可以访问package权限的class、field和method： 12345678910package abc;class Main &#123; void foo() &#123; &#x2F;&#x2F; 可以访问package权限的类: Hello h &#x3D; new Hello(); &#x2F;&#x2F; 可以调用package权限的方法: h.hi(); &#125;&#125; 注意，包名必须完全一致，包没有父子关系，com.apache和com.apache.abc是不同的包。 局部变量在方法内部定义的变量称为局部变量，局部变量作用域从变量声明处开始到对应的块结束。方法参数也是局部变量。 1234567891011121314package abc;public class Hello &#123; void hi(String name) &#123; &#x2F;&#x2F; ① String s &#x3D; name.toLowerCase(); &#x2F;&#x2F; ② int len &#x3D; s.length(); &#x2F;&#x2F; ③ if (len &lt; 10) &#123; &#x2F;&#x2F; ④ int p &#x3D; 10 - len; &#x2F;&#x2F; ⑤ for (int i&#x3D;0; i&lt;10; i++) &#123; &#x2F;&#x2F; ⑥ System.out.println(); &#x2F;&#x2F; ⑦ &#125; &#x2F;&#x2F; ⑧ &#125; &#x2F;&#x2F; ⑨ &#125; &#x2F;&#x2F; ⑩&#125; 我们观察上面的hi()方法代码：方法参数name是局部变量，它的作用域是整个方法，即①～⑩；变量s的作用域是定义处到方法结束，即②～⑩；变量len的作用域是定义处到方法结束，即③～⑩；变量p的作用域是定义处到if块结束，即⑤～⑨；变量i的作用域是for循环，即⑥～⑧。使用局部变量时，应该尽可能把局部变量的作用域缩小，尽可能延后声明局部变量。 finalJava还提供了一个final修饰符。final与访问权限不冲突，它有很多作用。用final修饰class可以阻止被继承： 123456789package abc;&#x2F;&#x2F; 无法被继承:public final class Hello &#123; private int n &#x3D; 0; protected void hi(int t) &#123; long i &#x3D; t; &#125;&#125; 用final修饰method可以阻止被子类覆写： 1234567package abc;public class Hello &#123; &#x2F;&#x2F; 无法被覆写: protected final void hi() &#123; &#125;&#125; 用final修饰field可以阻止被重新赋值： 12345678package abc;public class Hello &#123; private final int n &#x3D; 0; protected void hi() &#123; this.n &#x3D; 1; &#x2F;&#x2F; error! &#125;&#125; 用final修饰局部变量可以阻止被重新赋值： 1234567package abc;public class Hello &#123; protected void hi(final int t) &#123; t &#x3D; 1; &#x2F;&#x2F; error! &#125;&#125; 小结Java内建的访问权限包括public、protected、private和package权限；Java在方法内部定义的变量是局部变量，局部变量的作用域从变量声明开始，到一个块结束；final修饰符不是访问权限，它可以修饰class、field和method；一个.java文件只能包含一个public类，但可以包含多个非public类。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java面向对象_10.包","date":"2020-02-18T03:31:37.078Z","path":"2020/02/18/Java面向对象_10/","text":"在前面的代码中，我们把类和接口命名为Person、Student、Hello等简单名字。在现实中，如果小明写了一个Person类，小红也写了一个Person类，现在，小白既想用小明的Person，也想用小红的Person，怎么办？ 如果小军写了一个Arrays类，恰好JDK也自带了一个Arrays类，如何解决类名冲突？在Java中，我们使用package来解决名字冲突。Java定义了一种名字空间，称之为包：package。一个类总是属于某个包，类名（比如Person）只是一个简写，真正的完整类名是包名.类名。例如：小明的Person类存放在包ming下面，因此，完整类名是ming.Person；小红的Person类存放在包hong下面，因此，完整类名是hong.Person；小军的Arrays类存放在包mr.jun下面，因此，完整类名是mr.jun.Arrays；JDK的Arrays类存放在包java.util下面，因此，完整类名是java.util.Arrays。在定义class的时候，我们需要在第一行声明这个class属于哪个包。小明的Person.java文件： 1234package ming; &#x2F;&#x2F; 申明包名mingpublic class Person &#123;&#125; 小军的Arrays.java文件： 1234package mr.jun; &#x2F;&#x2F; 申明包名mr.junpublic class Arrays &#123;&#125; 在Java虚拟机执行的时候，JVM只看完整类名，因此，只要包名不同，类就不同。包可以是多层结构，用.隔开。例如：java.util。 要特别注意：包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。 我们还需要按照包结构把上面的Java文件组织起来。假设以package_sample作为根目录，src作为源码目录，那么所有文件结构就是： 123456789package_sample└─ src ├─ hong │ └─ Person.java │ ming │ └─ Person.java └─ mr └─ jun └─ Arrays.java 即所有Java文件对应的目录层次要和包的层次一致。 编译后的.class文件也需要按照包结构存放。如果使用IDE，把编译后的.class文件放到bin目录下，那么，编译的文件结构就是： 123456789package_sample└─ bin ├─ hong │ └─ Person.class │ ming │ └─ Person.class └─ mr └─ jun └─ Arrays.class 编译的命令相对比较复杂，我们需要在src目录下执行javac命令： 1javac -d ..&#x2F;bin ming&#x2F;Person.java hong&#x2F;Person.java mr&#x2F;jun&#x2F;Arrays.java 在IDE中，会自动根据包结构编译所有Java源码，所以不必担心使用命令行编译的复杂命令。 包作用域 位于同一个包的类，可以访问包作用域的字段和方法。不用public、protected、private修饰的字段和方法就是包作用域。例如，Person类定义在hello包下面： 12345678package hello;public class Person &#123; &#x2F;&#x2F; 包作用域: void hello() &#123; System.out.println(&quot;Hello!&quot;); &#125;&#125; Main类也定义在hello包下面： 12345678package hello;public class Main &#123; public static void main(String[] args) &#123; Person p &#x3D; new Person(); p.hello(); &#x2F;&#x2F; 可以调用，因为Main和Person在同一个包 &#125;&#125; import在一个class中，我们总会引用其他的class。例如，小明的ming.Person类，如果要引用小军的mr.jun.Arrays类，他有三种写法：第一种，直接写出完整类名，例如： 12345678&#x2F;&#x2F; Person.javapackage ming;public class Person &#123; public void run() &#123; mr.jun.Arrays arrays &#x3D; new mr.jun.Arrays(); &#125;&#125; 很显然，每次写完整类名比较痛苦。因此，第二种写法是用import语句，导入小军的Arrays，然后写简单类名： 1234567891011&#x2F;&#x2F; Person.javapackage ming;&#x2F;&#x2F; 导入完整类名:import mr.jun.Arrays;public class Person &#123; public void run() &#123; Arrays arrays &#x3D; new Arrays(); &#125;&#125; 在写import的时候，可以使用*，表示把这个包下面的所有class都导入进来（但不包括子包的class）： 1234567891011&#x2F;&#x2F; Person.javapackage ming;&#x2F;&#x2F; 导入mr.jun包的所有class:import mr.jun.*;public class Person &#123; public void run() &#123; Arrays arrays &#x3D; new Arrays(); &#125;&#125; 我们一般不推荐这种写法，因为在导入了多个包后，很难看出Arrays类属于哪个包。还有一种import static的语法，它可以导入一个类的静态字段和静态方法： 1234567891011package main;&#x2F;&#x2F; 导入System类的所有静态字段和静态方法:import static java.lang.System.*;public class Main &#123; public static void main(String[] args) &#123; &#x2F;&#x2F; 相当于调用System.out.println(…) out.println(&quot;Hello, world!&quot;); &#125;&#125; import static很少使用。 Java编译器最终编译出的.class文件只使用完整类名，因此，在代码中，当编译器遇到一个class名称时：如果是完整类名，就直接根据完整类名查找这个class；如果是简单类名，按下面的顺序依次查找：查找当前package是否存在这个class；查找import的包是否包含这个class；查找java.lang包是否包含这个class。如果按照上面的规则还无法确定类名，则编译报错。 编写class的时候，编译器会自动帮我们做两个import动作：默认自动import当前package的其他class；默认自动import java.lang.*。自动导入的是java.lang包，但类似java.lang.reflect这些包仍需要手动导入。如果有两个class名称相同，例如，mr.jun.Arrays和java.util.Arrays，那么只能import其中一个，另一个必须写完整类名。 最佳实践为了避免名字冲突，我们需要确定唯一的包名。推荐的做法是使用倒置的域名来确保唯一性。例如：org.apacheorg.apache.commons.logcom.liaoxuefeng.sample子包就可以根据功能自行命名。要注意不要和java.lang包的类重名，即自己的类不要使用这些名字：StringSystemRuntime…要注意也不要和JDK常用类重名：java.util.Listjava.text.Formatjava.math.BigInteger… 小结 Java内建的package机制是为了避免class命名冲突；JDK的核心类使用java.lang包，编译器会自动导入；JDK的其它常用类定义在java.util.*，java.math.*，java.text.*，……；包名推荐使用倒置的域名，例如org.apache。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java面向对象_9.静态字段和静态方法","date":"2020-02-18T03:29:49.706Z","path":"2020/02/18/Java面向对象_9/","text":"在一个class中定义的字段，我们称之为实例字段。实例字段的特点是，每个实例都有独立的字段，各个实例的同名字段互不影响。还有一种字段，是用static修饰的字段，称为静态字段：static field。 实例字段在每个实例中都有自己的一个独立“空间”，但是静态字段只有一个共享“空间”，所有实例都会共享该字段。举个例子： 1234567891011121314151617181920212223242526272829class Person &#123; public String name; public int age; &#x2F;&#x2F; 定义静态字段number: public static int number;&#125;public class Main &#123; public static void main(String[] args) &#123; Person ming &#x3D; new Person(&quot;Xiao Ming&quot;, 12); Person hong &#x3D; new Person(&quot;Xiao Hong&quot;, 15); ming.number &#x3D; 88; System.out.println(hong.number); hong.number &#x3D; 99; System.out.println(ming.number); &#125;&#125;class Person &#123; public String name; public int age; public static int number; public Person(String name, int age) &#123; this.name &#x3D; name; this.age &#x3D; age; &#125;&#125; 输出：8899 对于静态字段，无论修改哪个实例的静态字段，效果都是一样的：所有实例的静态字段都被修改了，原因是静态字段并不属于实例： 12345678910111213141516 ┌──────────────────┐ming ──&gt;│Person instance │ ├──────────────────┤ │name &#x3D; &quot;Xiao Ming&quot;│ │age &#x3D; 12 │ │number ───────────┼──┐ ┌─────────────┐ └──────────────────┘ │ │Person class │ │ ├─────────────┤ ├───&gt;│number &#x3D; 99 │ ┌──────────────────┐ │ └─────────────┘hong ──&gt;│Person instance │ │ ├──────────────────┤ │ │name &#x3D; &quot;Xiao Hong&quot;│ │ │age &#x3D; 15 │ │ │number ───────────┼──┘ └──────────────────┘ 虽然实例可以访问静态字段，但是它们指向的其实都是Person class的静态字段。所以，所有实例共享一个静态字段。因此，不推荐用实例变量.静态字段去访问静态字段，因为在Java程序中，实例对象并没有静态字段。在代码中，实例对象能访问静态字段只是因为编译器可以根据实例类型自动转换为类名.静态字段来访问静态对象。推荐用类名来访问静态字段。可以把静态字段理解为描述class本身的字段（非实例字段）。对于上面的代码，更好的写法是： 12Person.number &#x3D; 99;System.out.println(Person.number); 静态方法 有静态字段，就有静态方法。用static修饰的方法称为静态方法。调用实例方法必须通过一个实例变量，而调用静态方法则不需要实例变量，通过类名就可以调用。静态方法类似其它编程语言的函数。例如： 1234567891011121314public class Main &#123; public static void main(String[] args) &#123; Person.setNumber(99); System.out.println(Person.number); &#125;&#125;class Person &#123; public static int number; public static void setNumber(int value) &#123; number &#x3D; value; &#125;&#125; 因为静态方法属于class而不属于实例，因此，静态方法内部，无法访问this变量，也无法访问实例字段，它只能访问静态字段。通过实例变量也可以调用静态方法，但这只是编译器自动帮我们把实例改写成类名而已。通常情况下，通过实例变量访问静态字段和静态方法，会得到一个编译警告。静态方法经常用于工具类。例如： 12Arrays.sort()Math.random() 静态方法也经常用于辅助方法。注意到Java程序的入口main()也是静态方法。 接口的静态字段 因为interface是一个纯抽象类，所以它不能定义实例字段。但是，interface是可以有静态字段的，并且静态字段必须为final类型： 1234public interface Person &#123; public static final int MALE &#x3D; 1; public static final int FEMALE &#x3D; 2;&#125; 实际上，因为interface的字段只能是public static final类型，所以我们可以把这些修饰符都去掉，上述代码可以简写为： 12345public interface Person &#123; &#x2F;&#x2F; 编译器会自动加上public statc final: int MALE &#x3D; 1; int FEMALE &#x3D; 2;&#125; 编译器会自动把该字段变为public static final类型。 小结 静态字段属于所有实例“共享”的字段，实际上是属于class的字段；调用静态方法不需要实例，无法访问this，但可以访问静态字段和其他静态方法；静态方法常用于工具类和辅助方法。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java面向对象_8.接口","date":"2020-02-18T03:28:19.018Z","path":"2020/02/18/Java面向对象_8/","text":"在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。 如果一个抽象类没有字段，所有方法全部都是抽象方法： 1234abstract class Person &#123; public abstract void run(); public abstract String getName();&#125; 就可以把该抽象类改写为接口：interface。在Java中，使用interface可以声明一个接口： 1234interface Person &#123; void run(); String getName();&#125; 所谓interface，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是public abstract的，所以这两个修饰符不需要写出来（写不写效果都一样）。 当一个具体的class去实现一个interface时，需要使用implements关键字。举个例子： 1234567891011121314151617class Student implements Person &#123; private String name; public Student(String name) &#123; this.name &#x3D; name; &#125; @Override public void run() &#123; System.out.println(this.name + &quot; run&quot;); &#125; @Override public String getName() &#123; return this.name; &#125;&#125; 我们知道，在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个interface，例如： 123class Student implements Person, Hello &#123; &#x2F;&#x2F; 实现了两个interface ...&#125; 术语注意区分术语：Java的接口特指interface的定义，表示一个接口类型和一组方法签名，而编程接口泛指接口规范，如方法签名，数据格式，网络协议等。抽象类和接口的对比如下： abstract class interface继承 只能extends一个class 可以implements多个interface字段 可以定义实例字段 不能定义实例字段抽象方法 可以定义抽象方法 可以定义抽象方法非抽象方法 可以定义非抽象方法 可以定义default方法 接口继承 一个interface可以继承自另一个interface。interface继承自interface使用extends，它相当于扩展了接口的方法。例如： 12345678interface Hello &#123; void hello();&#125;interface Person extends Hello &#123; void run(); String getName();&#125; 此时，Person接口继承自Hello接口，因此，Person接口现在实际上有3个抽象方法签名，其中一个来自继承的Hello接口。 继承关系 合理设计interface和abstract class的继承关系，可以充分复用代码。一般来说，公共逻辑适合放在abstract class中，具体逻辑放到各个子类，而接口层次代表抽象程度。可以参考Java的集合类定义的一组接口、抽象类以及具体子类的继承关系： 12345678910111213141516171819202122┌───────────────┐│ Iterable │└───────────────┘ ▲ ┌───────────────────┐ │ │ Object │┌───────────────┐ └───────────────────┘│ Collection │ ▲└───────────────┘ │ ▲ ▲ ┌───────────────────┐ │ └──────────│AbstractCollection │┌───────────────┐ └───────────────────┘│ List │ ▲└───────────────┘ │ ▲ ┌───────────────────┐ └──────────│ AbstractList │ └───────────────────┘ ▲ ▲ │ │ │ │ ┌────────────┐ ┌────────────┐ │ ArrayList │ │ LinkedList │ └────────────┘ └────────────┘ 在使用的时候，实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为接口比抽象类更抽象： 123List list &#x3D; new ArrayList(); &#x2F;&#x2F; 用List接口引用具体子类的实例Collection coll &#x3D; list; &#x2F;&#x2F; 向上转型为Collection接口Iterable it &#x3D; coll; &#x2F;&#x2F; 向上转型为Iterable接口 default方法 在接口中，可以定义default方法。例如，把Person接口的run()方法改为default方法： 12345678910111213141516171819202122232425public class Main &#123; public static void main(String[] args) &#123; Person p &#x3D; new Student(&quot;Xiao Ming&quot;); p.run(); &#125;&#125;interface Person &#123; String getName(); default void run() &#123; System.out.println(getName() + &quot; run&quot;); &#125;&#125;class Student implements Person &#123; private String name; public Student(String name) &#123; this.name &#x3D; name; &#125; public String getName() &#123; return this.name; &#125;&#125; 实现类可以不必覆写default方法。default方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是default方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。default方法和抽象类的普通方法是有所不同的。因为interface没有字段，default方法无法访问字段，而抽象类的普通方法可以访问实例字段。 小结 Java的接口（interface）定义了纯抽象规范，一个类可以实现多个接口；接口也是数据类型，适用于向上转型和向下转型；接口的所有方法都是抽象方法，接口不能定义实例字段；接口可以定义default方法（JDK&gt;=1.8）。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java面向对象_7.抽象类","date":"2020-02-18T03:26:51.078Z","path":"2020/02/18/Java面向对象_7/","text":"简述：由于多态的存在，每个子类都可以覆写父类的方法，例如： 12345678910111213class Person &#123; public void run() &#123; … &#125;&#125;class Student extends Person &#123; @Override public void run() &#123; … &#125;&#125;class Teacher extends Person &#123; @Override public void run() &#123; … &#125;&#125; 从Person类派生的Student和Teacher都可以覆写run()方法。 如果父类Person的run()方法没有实际意义，能否去掉方法的执行语句？ 123class Person &#123; public void run(); &#x2F;&#x2F; Compile Error!&#125; 答案是不行，会导致编译错误，因为定义方法的时候，必须有实现方法的语句。 能不能去掉父类的run()方法？答案还是不行，因为去掉父类的run()方法，就失去了多态的特性。例如，runTwice()就无法编译： 1234public void runTwice(Person p) &#123; p.run(); &#x2F;&#x2F; Person没有run()方法，会导致编译错误 p.run();&#125; 如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法： 123class Person &#123; public abstract void run();&#125; 把一个方法声明为abstract，表示它是一个抽象方法，本身没有实现任何方法语句。因为这个抽象方法本身是无法执行的，所以，Person类也无法被实例化。编译器会告诉我们，无法编译Person类，因为它包含抽象方法。必须把Person类本身也声明为abstract，才能正确编译它： 123abstract class Person &#123; public abstract void run();&#125; 抽象类 如果一个class定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用abstract修饰。因为无法执行抽象方法，因此这个类也必须申明为抽象类（abstract class）。使用abstract修饰的类就是抽象类。我们无法实例化一个抽象类：Person p = new Person(); // 编译错误 无法实例化的抽象类有什么用？因为抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”。例如，Person类定义了抽象方法run()，那么，在实现子类Student的时候，就必须覆写run()方法： 1234567891011121314151617public class Main &#123; public static void main(String[] args) &#123; Person p &#x3D; new Student(); &#x2F;&#x2F;向上转型 p.run(); &#125;&#125;abstract class Person &#123; public abstract void run();&#125;class Student extends Person &#123; @Override public void run() &#123; System.out.println(&quot;Student.run&quot;); &#125;&#125; 面向抽象编程 当我们定义了抽象类Person，以及具体的Student、Teacher子类的时候，我们可以通过抽象类Person类型去引用具体的子类的实例： 12Person s &#x3D; new Student();Person t &#x3D; new Teacher(); 这种引用抽象类的好处在于，我们对其进行方法调用，并不关心Person类型变量的具体子类型：// 不关心Person变量的具体子类型: 12s.run();t.run(); 同样的代码，如果引用的是一个新的子类，我们仍然不关心具体类型：// 同样不关心新的子类是如何实现run()方法的： 12Person e &#x3D; new Employee();e.run(); 这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。 面向抽象编程的本质就是：上层代码只定义规范（例如：abstract class Person）；不需要子类就可以实现业务逻辑（正常编译）；具体的业务逻辑由不同的子类实现，调用者并不关心。 小结 通过abstract定义的方法是抽象方法，它只有定义，没有实现。抽象方法定义了子类必须实现的接口规范；定义了抽象方法的class必须被定义为抽象类，从抽象类继承的子类必须实现抽象方法；如果不实现抽象方法，则该子类仍是一个抽象类；面向抽象编程使得调用者只关心抽象方法的定义，不关心子类的具体实现。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java面向对象_6.多态和final、super的使用","date":"2020-02-18T03:24:27.506Z","path":"2020/02/18/Java面向对象_6/","text":"在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为覆写（Override）。例如，在Person类中，我们定义了run()方法： 12345class Person &#123; public void run() &#123; System.out.println(&quot;Person.run&quot;); &#125;&#125; 在子类Student中，覆写这个run()方法： 123456class Student extends Person &#123; @Override public void run() &#123; System.out.println(&quot;Student.run&quot;); &#125;&#125; 注意：方法名相同，方法参数相同，但方法返回值不同，也是不同的方法。加上@Override可以让编译器帮助检查是否进行了正确的覆写。希望进行覆写，但是不小心写错了方法签名，编译器会报错。 1234567891011121314public class Main &#123; public static void main(String[] args) &#123; &#125;&#125;class Person &#123; public void run() &#123;&#125;&#125;public class Student extends Person &#123; @Override &#x2F;&#x2F; Compile error! public void run(String s) &#123;&#125;&#125;@Override不是必需的。 多态多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。例如： 12Person p &#x3D; new Student();p.run(); &#x2F;&#x2F; 无法确定运行时究竟调用哪个run()方法 有童鞋会问，从上面的代码一看就明白，肯定调用的是Student的run()方法啊。但是，假设我们编写这样一个方法： 1234public void runTwice(Person p) &#123; p.run(); p.run();&#125; 它传入的参数类型是Person，我们是无法知道传入的参数实际类型究竟是Person，还是Student，还是Person的其他子类，因此，也无法确定调用的是不是Person类定义的run()方法。所以，多态的特性就是，运行期才能动态决定调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法。这种不确定性的方法调用，究竟有什么作用？我们还是来举栗子。假设我们定义一种收入，需要给它报税，那么先定义一个Income类： 123456class Income &#123; protected double income; public double getTax() &#123; return income * 0.1; &#x2F;&#x2F; 税率10% &#125;&#125; 对于工资收入，可以减去一个基数，那么我们可以从Income派生出SalaryIncome，并覆写getTax()： 123456789class Salary extends Income &#123; @Override public double getTax() &#123; if (income &lt;&#x3D; 5000) &#123; return 0; &#125; return (income - 5000) * 0.2; &#125;&#125; 如果你享受国务院特殊津贴，那么按照规定，可以全部免税： 123456class StateCouncilSpecialAllowance extends Income &#123; @Override public double getTax() &#123; return 0; &#125;&#125; 现在，我们要编写一个报税的财务软件，对于一个人的所有收入进行报税，可以这么写： 1234567public double totalTax(Income... incomes) &#123; double total &#x3D; 0; for (Income income: incomes) &#123; total &#x3D; total + income.getTax(); &#125; return total;&#125; 代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Main &#123; public static void main(String[] args) &#123; &#x2F;&#x2F; 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税: Income[] incomes &#x3D; new Income[] &#123; new Income(3000), new Salary(7500), new StateCouncilSpecialAllowance(15000) &#125;; System.out.println(totalTax(incomes)); &#125; public static double totalTax(Income... incomes) &#123; double total &#x3D; 0; for (Income income: incomes) &#123; total &#x3D; total + income.getTax(); &#125; return total; &#125;&#125;class Income &#123; protected double income; public Income(double income) &#123; this.income &#x3D; income; &#125; public double getTax() &#123; return income * 0.1; &#x2F;&#x2F; 税率10% &#125;&#125;class Salary extends Income &#123; public Salary(double income) &#123; super(income); &#125; @Override public double getTax() &#123; if (income &lt;&#x3D; 5000) &#123; return 0; &#125; return (income - 5000) * 0.2; &#125;&#125;class StateCouncilSpecialAllowance extends Income &#123; public StateCouncilSpecialAllowance(double income) &#123; super(income); &#125; @Override public double getTax() &#123; return 0; &#125;&#125; 观察totalTax()方法：利用多态，totalTax()方法只需要和Income打交道，它完全不需要知道Salary和StateCouncilSpecialAllowance的存在，就可以正确计算出总的税。如果我们要新增一种稿费收入，只需要从Income派生，然后正确覆写getTax()方法就可以。把新的类型传入totalTax()，不需要修改任何代码。可见，多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。 覆写Object方法 因为所有的class最终都继承自Object，而Object定义了几个重要的方法： 123toString()：把instance输出为String；equals()：判断两个instance是否逻辑相等；hashCode()：计算一个instance的哈希值。 调用super 在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过super来调用。例如： 1234567891011121314class Person &#123; protected String name; public String hello() &#123; return &quot;Hello, &quot; + name; &#125;&#125;class Student extends Person &#123; @Override public String hello() &#123; &#x2F;&#x2F; 调用父类的hello()方法: return super.hello() + &quot;!&quot;; &#125;&#125; final 继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为final。用final修饰的方法不能被Override： 12345678910111213class Person &#123; protected String name; public final String hello() &#123; return &quot;Hello, &quot; + name; &#125;&#125;Student extends Person &#123; &#x2F;&#x2F; compile error: 不允许覆写 @Override public String hello() &#123; &#125;&#125; 如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为final。用final修饰的类不能被继承： 1234567final class Person &#123; protected String name;&#125;&#x2F;&#x2F; compile error: 不允许继承自PersonStudent extends Person &#123;&#125; 对于一个类的实例字段，同样可以用final修饰。用final修饰的字段在初始化后不能被修改。例如： 123class Person &#123; public final String name &#x3D; &quot;Unamed&quot;;&#125; 对final字段重新赋值会报错： 12Person p &#x3D; new Person();p.name &#x3D; &quot;New Name&quot;; &#x2F;&#x2F; compile error! 以在构造方法中初始化final字段： 123456class Person &#123; public final String name; public Person(String name) &#123; this.name &#x3D; name; &#125;&#125; 这种方法更为常用，因为可以保证实例一旦创建，其final字段就不可修改。 小结 子类可以覆写父类的方法（Override），覆写在子类中改变了父类方法的行为；Java的方法调用总是作用于运行期对象的实际类型，这种行为称为多态；final修饰符有多种作用：final修饰的方法可以阻止被覆写；final修饰的class可以阻止被继承；final修饰的field必须在创建对象时初始化，随后不可修改。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java面向对象_5.继承","date":"2020-02-18T03:21:50.121Z","path":"2020/02/18/Java面向对象_5/","text":"在前面的章节中，我们已经定义了Person类： 123456789class Person &#123; private String name; private int age; public String getName() &#123;...&#125; public void setName(String name) &#123;...&#125; public int getAge() &#123;...&#125; public void setAge(int age) &#123;...&#125;&#125; 现在，假设需要定义一个Student类，字段如下： 123456789101112class Student &#123; private String name; private int age; private int score; public String getName() &#123;...&#125; public void setName(String name) &#123;...&#125; public int getAge() &#123;...&#125; public void setAge(int age) &#123;...&#125; public int getScore() &#123; … &#125; public void setScore(int score) &#123; … &#125;&#125; 仔细观察，发现Student类包含了Person类已有的字段和方法，只是多出了一个score字段和相应的getScore()、setScore()方法。能不能在Student中不要写重复的代码？这个时候，继承就派上用场了。 继承是面向对象编程中非常强大的一种机制，它首先可以复用代码。当我们让Student从Person继承时，Student就获得了Person的所有功能，我们只需要为Student编写新增的功能。Java使用extends关键字来实现继承： 123456789101112131415161718class Person &#123; private String name; private int age; public String getName() &#123;...&#125; public void setName(String name) &#123;...&#125; public int getAge() &#123;...&#125; public void setAge(int age) &#123;...&#125;&#125;class Student extends Person &#123; &#x2F;&#x2F; 不要重复name和age字段&#x2F;方法, &#x2F;&#x2F; 只需要定义新增score字段&#x2F;方法: private int score; public int getScore() &#123; … &#125; public void setScore(int score) &#123; … &#125;&#125; 可见，通过继承，Student只需要编写额外的功能，不再需要重复代码。在OOP的术语中，我们把Person称为超类（super class），父类（parent class），基类（base class），把Student称为子类（subclass），扩展类（extended class）。 继承树 注意到我们在定义Person的时候，没有写extends。在Java中，没有明确写extends的类，编译器会自动加上extends Object。所以，任何类，除了Object，都会继承自某个类。下图是Person、Student的继承树： 12345678910111213┌───────────┐│ Object │└───────────┘ ▲ │┌───────────┐│ Person │└───────────┘ ▲ │┌───────────┐│ Student │└───────────┘ Java只允许一个class继承自一个类，因此，一个类有且仅有一个父类。只有Object特殊，它没有父类。类似的，如果我们定义一个继承自Person的Teacher，它们的继承树关系如下： 1234567891011121314 ┌───────────┐ │ Object │ └───────────┘ ▲ │ ┌───────────┐ │ Person │ └───────────┘ ▲ ▲ │ │ │ │┌───────────┐ ┌───────────┐│ Student │ │ Teacher │└───────────┘ └───────────┘ protected 继承有个特点，就是子类无法访问父类的private字段或者private方法。例如，Student类就无法访问Person类的name和age字段： 12345678910class Person &#123; private String name; private int age;&#125;class Student extends Person &#123; public String hello() &#123; return &quot;Hello, &quot; + name; &#x2F;&#x2F; 编译错误：无法访问name字段 &#125;&#125; 这使得继承的作用被削弱了。为了让子类可以访问父类的字段，我们需要把private改为protected。用protected修饰的字段可以被子类访问： 12345678910class Person &#123; protected String name; protected int age;&#125;class Student extends Person &#123; public String hello() &#123; return &quot;Hello, &quot; + name; &#x2F;&#x2F; OK! &#125;&#125; 因此，protected关键字可以把字段和方法的访问权限控制在继承树内部，一个protected字段和方法可以被其子类，以及子类的子类所访问，后面我们还会详细讲解。 super super关键字表示父类（超类）。子类引用父类的字段时，可以用super.fieldName。例如： 12345class Student extends Person &#123; public String hello() &#123; return &quot;Hello, &quot; + super.name; &#125;&#125; 实际上，这里使用super.name，或者this.name，或者name，效果都是一样的。编译器会自动定位到父类的name字段。但是，在某些时候，就必须使用super。我们来看一个例子： 1234567891011121314151617181920212223public class Main &#123; public static void main(String[] args) &#123; Student s &#x3D; new Student(&quot;Xiao Ming&quot;, 12, 89); &#125;&#125;class Person &#123; protected String name; protected int age; public Person(String name, int age) &#123; this.name &#x3D; name; this.age &#x3D; age; &#125;&#125;class Student extends Person &#123; protected int score; public Student(String name, int age, int score) &#123; this.score &#x3D; score; &#125;&#125; 运行上面的代码，会得到一个编译错误，大意是在Student的构造方法中，无法调用Person的构造方法。这是因为在Java中，任何class的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句super();，所以，Student类的构造方法实际上是这样： 12345678class Student extends Person &#123; protected int score; public Student(String name, int age, int score) &#123; super(); &#x2F;&#x2F; 自动调用父类的构造方法 this.score &#x3D; score; &#125;&#125; 但是，Person类并没有无参数的构造方法，因此，编译失败。解决方法是调用Person类存在的某个构造方法。例如： 12345678class Student extends Person &#123; protected int score; public Student(String name, int age, int score) &#123; super(name, age); &#x2F;&#x2F; 调用父类的构造方法Person(String, int) this.score &#x3D; score; &#125;&#125; 这样就可以正常编译了！因此我们得出结论：如果父类没有默认的构造方法，子类就必须显式调用super()并给出参数以便让编译器定位到父类的一个合适的构造方法。这里还顺带引出了另一个问题：即子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。 向上转型 如果一个引用变量的类型是Student，那么它可以指向一个Student类型的实例： 1Student s &#x3D; new Student(); 如果一个引用类型的变量是Person，那么它可以指向一个Person类型的实例： 1Person p &#x3D; new Person(); 现在问题来了：如果Student是从Person继承下来的，那么，一个引用类型为Person的变量，能否指向Student类型的实例？ 1Person p &#x3D; new Student(); &#x2F;&#x2F; ??? 测试一下就可以发现，这种指向是允许的！这是因为Student继承自Person，因此，它拥有Person的全部功能。Person类型的变量，如果指向Student类型的实例，对它进行操作，是没有问题的！这种把一个子类类型安全地变为父类类型的赋值，被称为向上转型（upcasting）。向上转型实际上是把一个子类型安全地变为更加抽象的父类型： 1234Student s &#x3D; new Student();Person p &#x3D; s; &#x2F;&#x2F; upcasting, okObject o1 &#x3D; p; &#x2F;&#x2F; upcasting, okObject o2 &#x3D; s; &#x2F;&#x2F; upcasting, ok 注意到继承树是Student &gt; Person &gt; Object，所以，可以把Student类型转型为Person，或者更高层次的Object。 向下转型 和向上转型相反，如果把一个父类类型强制转型为子类类型，就是向下转型（downcasting）。例如： 1234Person p1 &#x3D; new Student(); &#x2F;&#x2F; upcasting, okPerson p2 &#x3D; new Person();Student s1 &#x3D; (Student) p1; &#x2F;&#x2F; okStudent s2 &#x3D; (Student) p2; &#x2F;&#x2F; runtime error! ClassCastException! 如果测试上面的代码，可以发现：Person类型p1实际指向Student实例，Person类型变量p2实际指向Person实例。在向下转型的时候，把p1转型为Student会成功，因为p1确实指向Student实例，把p2转型为Student会失败，因为p2的实际类型是Person，不能把父类变为子类，因为子类功能比父类多，多的功能无法凭空变出来。因此，向下转型很可能会失败。失败的时候，Java虚拟机会报ClassCastException。为了避免向下转型出错，Java提供了instanceof操作符，可以先判断一个实例究竟是不是某种类型： 12345678910Person p &#x3D; new Person();System.out.println(p instanceof Person); &#x2F;&#x2F; trueSystem.out.println(p instanceof Student); &#x2F;&#x2F; falseStudent s &#x3D; new Student();System.out.println(s instanceof Person); &#x2F;&#x2F; trueSystem.out.println(s instanceof Student); &#x2F;&#x2F; trueStudent n &#x3D; null;System.out.println(n instanceof Student); &#x2F;&#x2F; false 区分继承和组合 在使用继承时，我们要注意逻辑一致性。考察下面的Book类： 12345class Book &#123; protected String name; public String getName() &#123;...&#125; public void setName(String name) &#123;...&#125;&#125; 这个Book类也有name字段，那么，我们能不能让Student继承自Book呢？ 123class Student extends Book &#123; protected int score;&#125; 显然，从逻辑上讲，这是不合理的，Student不应该从Book继承，而应该从Person继承。究其原因，是因为Student是Person的一种，它们是is关系，而Student并不是Book。实际上Student和Book的关系是has关系。具有has关系不应该使用继承，而是使用组合，即Student可以持有一个Book实例： 1234class Student extends Person &#123; protected Book book; protected int score;&#125; 因此，继承是is关系，组合是has关系。 小结 继承是面向对象编程的一种强大的代码复用方式；Java只允许单继承，所有类最终的根类是Object；protected允许子类访问父类的字段和方法；子类的构造方法可以通过super()调用父类的构造方法；可以安全地向上转型为更抽象的类型；可以强制向下转型，最好借助instanceof判断；子类和父类的关系是is，has关系不能用继承。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java面向对象_4.构造方法","date":"2020-02-18T03:20:01.873Z","path":"2020/02/18/Java面向对象_4/","text":"创建实例的时候，我们经常需要同时初始化这个实例的字段，例如： 123Person ming &#x3D; new Person();ming.setName(&quot;小明&quot;);ming.setAge(12); 初始化对象实例需要3行代码，而且，如果忘了调用setName()或者setAge()，这个实例内部的状态就是不正确的。能否在创建对象实例时就把内部字段全部初始化为合适的值？完全可以。这时，我们就需要构造方法。创建实例的时候，实际上是通过构造方法来初始化实例的。我们先来定义一个构造方法，能在创建Person实例的时候，一次性传入name和age，完成初始化： 12345678910111213141516171819202122232425public class Main &#123; public static void main(String[] args) &#123; Person p &#x3D; new Person(&quot;Xiao Ming&quot;, 15); System.out.println(p.getName()); System.out.println(p.getAge()); &#125;&#125;class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.name &#x3D; name; this.age &#x3D; age; &#125; public String getName() &#123; return this.name; &#125; public int getAge() &#123; return this.age; &#125;&#125; 由于构造方法是如此特殊，所以构造方法的名称就是类名。构造方法的参数没有限制，在方法内部，也可以编写任意语句。但是，和普通方法相比，构造方法没有返回值（也没有void），调用构造方法，必须用new操作符。 默认构造方法 是不是任何class都有构造方法？是的。那前面我们并没有为Person类编写构造方法，为什么可以调用new Person()？原因是如果一个类没有定义构造方法，编译器会自动为我们生成一个默认构造方法，它没有参数，也没有执行语句，类似这样： 1234class Person &#123; public Person() &#123; &#125;&#125; 要特别注意的是，如果我们自定义了一个构造方法，那么，编译器就不再自动创建默认构造方法 如果既要能使用带参数的构造方法，又想保留不带参数的构造方法，那么只能把两个构造方法都定义出来： 123456789101112131415161718192021222324252627public class Main &#123; public static void main(String[] args) &#123; Person p1 &#x3D; new Person(&quot;Xiao Ming&quot;, 15); &#x2F;&#x2F; 既可以调用带参数的构造方法 Person p2 &#x3D; new Person(); &#x2F;&#x2F; 也可以调用无参数构造方法 &#125;&#125;class Person &#123; private String name; private int age; public Person() &#123; &#125; public Person(String name, int age) &#123; this.name &#x3D; name; this.age &#x3D; age; &#125; public String getName() &#123; return this.name; &#125; public int getAge() &#123; return this.age; &#125;&#125; 没有在构造方法中初始化字段时，引用类型的字段默认是null，数值类型的字段用默认值，int类型默认值是0，布尔类型默认值是false： 1234567class Person &#123; private String name; &#x2F;&#x2F; 默认初始化为null private int age; &#x2F;&#x2F; 默认初始化为0 public Person() &#123; &#125;&#125; 也可以对字段直接进行初始化： 1234class Person &#123; private String name &#x3D; &quot;Unamed&quot;; private int age &#x3D; 10;&#125; 那么问题来了：既对字段进行初始化，又在构造方法中对字段进行初始化： 123456789class Person &#123; private String name &#x3D; &quot;Unamed&quot;; private int age &#x3D; 10; public Person(String name, int age) &#123; this.name &#x3D; name; this.age &#x3D; age; &#125;&#125; 当我们创建对象的时候，new Person(“Xiao Ming”, 12)得到的对象实例，字段的初始值是啥？在Java中，创建对象实例的时候，按照如下顺序进行初始化：先初始化字段，例如，int age = 10;表示字段初始化为10，double salary;表示字段默认初始化为0，String name;表示引用类型字段默认初始化为null；执行构造方法的代码进行初始化。因此，构造方法的代码由于后运行，所以，new Person(“Xiao Ming”, 12)的字段值最终由构造方法的代码确定。 多构造方法 可以定义多个构造方法，在通过new操作符调用的时候，编译器通过构造方法的参数数量、位置和类型自动区分： 1234567891011121314151617class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.name &#x3D; name; this.age &#x3D; age; &#125; public Person(String name) &#123; this.name &#x3D; name; this.age &#x3D; 12; &#125; public Person() &#123; &#125;&#125; 如果调用new Person(“Xiao Ming”, 20);，会自动匹配到构造方法public Person(String, int)。如果调用new Person(“Xiao Ming”);，会自动匹配到构造方法public Person(String)。如果调用new Person();，会自动匹配到构造方法public Person()。一个构造方法可以调用其他构造方法，这样做的目的是便于代码复用。调用其他构造方法的语法是this(…)： 1234567891011121314151617class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.name &#x3D; name; this.age &#x3D; age; &#125; public Person(String name) &#123; this(name, 18); &#x2F;&#x2F; 调用另一个构造方法Person(String, int) &#125; public Person() &#123; this(&quot;Unnamed&quot;); &#x2F;&#x2F; 调用另一个构造方法Person(String) &#125;&#125; 小结 实例在创建时通过new操作符会调用其对应的构造方法，构造方法用于初始化实例；没有定义构造方法时，编译器会自动创建一个默认的无参数构造方法；可以定义多个构造方法，编译器根据参数自动判断；可以在一个构造方法内部调用另一个构造方法，便于代码复用。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java面向对象_3.方法重载","date":"2020-02-18T03:18:35.029Z","path":"2020/02/18/Java面向对象_3/","text":"在一个类中，我们可以定义多个方法。如果有一系列方法，它们的功能都是类似的，只有参数有所不同，那么，可以把这一组方法名做成同名方法。例如，在Hello类中，定义多个hello()方法： 1234567891011121314151617class Hello &#123; public void hello() &#123; System.out.println(\"Hello, world!\"); &#125; public void hello(String name) &#123; System.out.println(\"Hello, \" + name + \"!\"); &#125; public void hello(String name, int age) &#123; if (age &lt; 18) &#123; System.out.println(\"Hi, \" + name + \"!\"); &#125; else &#123; System.out.println(\"Hello, \" + name + \"!\"); &#125; &#125;&#125; 这种方法名相同，但各自的参数不同，称为方法重载（Overload）。注意：方法重载的返回值类型通常都是相同的。方法重载的目的是，功能类似的方法使用同一名字，更容易记住，因此，调用起来更简单。 小结 方法重载是指多个方法的方法名相同，但各自的参数不同；重载方法应该完成类似的功能，参考String的indexOf()；重载方法返回值类型应该相同。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java面向对象_2.方法","date":"2020-02-18T01:43:53.540Z","path":"2020/02/18/Java面向对象_2/","text":"一个class可以包含多个field，例如，我们给Person类就定义了两个field： 1234class Person &#123; public String name; public int age;&#125; 但是，直接把field用public暴露给外部可能会破坏封装性。比如，代码可以这样写：Person ming = new Person();ming.name = “Xiao Ming”;ming.age = -99; // age设置为负数 显然，直接操作field，容易造成逻辑混乱。为了避免外部代码直接去访问field，我们可以用private修饰field，拒绝外部访问: 1234class Person &#123; private String name; private int age;&#125; 把field从public改成private，外部代码不能访问这些field，那我们定义这些field有什么用？怎么才能给它赋值？怎么才能读取它的值？所以我们需要使用方法（method）来让外部代码可以间接修改field： 1234567891011121314151617181920212223242526272829303132public class Main &#123; public static void main(String[] args) &#123; Person ming = new Person(); ming.setName(\"Xiao Ming\"); // 设置name ming.setAge(12); // 设置age System.out.println(ming.getName() + \", \" + ming.getAge()); &#125;&#125;class Person &#123; private String name; private int age; public String getName() &#123; return this.name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return this.age; &#125; public void setAge(int age) &#123; if (age &lt; 0 || age &gt; 100) &#123; throw new IllegalArgumentException(\"invalid age value\"); &#125; this.age = age; &#125;&#125; 虽然外部代码不能直接修改private字段，但是，外部代码可以调用方法setName()和setAge()来间接修改private字段。在方法内部，我们就有机会检查参数对不对。比如，setAge()就会检查传入的参数，参数超出了范围，直接报错。这样，外部代码就没有任何机会把age设置成不合理的值。同样，外部代码不能直接读取private字段，但可以通过getName()和getAge()间接获取private字段的值。所以，一个类通过定义方法，就可以给外部代码暴露一些操作的接口，同时，内部自己保证逻辑一致性。调用方法的语法是实例变量.方法名(参数);。一个方法调用就是一个语句，所以不要忘了在末尾加;。例如：ming.setName(“Xiao Ming”);。 定义方法从上面的代码可以看出，定义方法的语法是： 1234修饰符 方法返回类型 方法名(方法参数列表) &#123; 若干方法语句; return 方法返回值;&#125; 方法返回值通过return语句实现，如果没有返回值，返回类型设置为void，可以省略return。 private方法 有public方法，自然就有private方法。和private字段一样，private方法不允许外部调用，那我们定义private方法有什么用？定义private方法的理由是内部方法是可以调用private方法的。例如： 12345678910111213141516171819202122232425public class Main &#123; public static void main(String[] args) &#123; Person ming &#x3D; new Person(); ming.setBirth(2008); System.out.println(ming.getAge()); &#125;&#125;class Person &#123; private String name; private int birth; public void setBirth(int birth) &#123; this.birth &#x3D; birth; &#125; public int getAge() &#123; return calcAge(2019); &#x2F;&#x2F; 调用private方法 &#125; &#x2F;&#x2F; private方法: private int calcAge(int currentYear) &#123; return currentYear - this.birth; &#125;&#125; 观察上述代码，calcAge()是一个private方法，外部代码无法调用，但是，内部方法getAge()可以调用它。此外，我们还注意到，这个Person类只定义了birth字段，没有定义age字段，获取age时，通过方法getAge()返回的是一个实时计算的值，并非存储在某个字段的值。这说明方法可以封装一个类的对外接口，调用方不需要知道也不关心Person实例在内部到底有没有age字段。 this变量在方法内部，可以使用一个隐含的变量this，它始终指向当前实例。因此，通过this.field就可以访问当前实例的字段。如果没有命名冲突，可以省略this。例如： 1234567class Person &#123; private String name; public String getName() &#123; return name; // 相当于this.name &#125;&#125; 但是，如果有局部变量和字段重名，那么局部变量优先级更高，就必须加上this： 1234567class Person &#123; private String name; public void setName(String name) &#123; this.name = name; // 前面的this不可少，少了就变成局部变量name了 &#125;&#125; 方法参数方法可以包含0个或任意个参数。方法参数用于接收传递给方法的变量值。调用方法时，必须严格按照参数的定义一一传递。例如： 123456class Person &#123; ... public void setNameAndAge(String name, int age) &#123; ... &#125;&#125; 调用这个setNameAndAge()方法时，必须有两个参数，且第一个参数必须为String，第二个参数必须为int：Person ming = new Person();ming.setNameAndAge(“Xiao Ming”); // 编译错误：参数个数不对ming.setNameAndAge(12, “Xiao Ming”); // 编译错误：参数类型不对 可变参数可变参数用类型…定义，可变参数相当于数组类型： 1234567class Group &#123; private String[] names; public void setNames(String... names) &#123; this.names &#x3D; names; &#125;&#125; 上面的setNames()就定义了一个可变参数。调用时，可以这么写： 12345Group g &#x3D; new Group();g.setNames(&quot;Xiao Ming&quot;, &quot;Xiao Hong&quot;, &quot;Xiao Jun&quot;); &#x2F;&#x2F; 传入3个Stringg.setNames(&quot;Xiao Ming&quot;, &quot;Xiao Hong&quot;); &#x2F;&#x2F; 传入2个Stringg.setNames(&quot;Xiao Ming&quot;); &#x2F;&#x2F; 传入1个Stringg.setNames(); &#x2F;&#x2F; 传入0个String 参数绑定调用方把参数传递给实例方法时，调用时传递的值会按参数位置一一绑定。那什么是参数绑定？我们先观察一个基本类型参数的传递： 12345678910111213141516171819202122public class Main &#123; public static void main(String[] args) &#123; Person p = new Person(); int n = 15; // n的值为15 p.setAge(n); // 传入n的值 System.out.println(p.getAge()); // 15 n = 20; // n的值改为20 System.out.println(p.getAge()); // 15还是20? &#125;&#125;class Person &#123; private int age; public int getAge() &#123; return this.age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 运行代码，从结果可知，修改外部的局部变量n，不影响实例p的age字段，原因是setAge()方法获得的参数，复制了n的值，因此，p.age和局部变量n互不影响。结论：基本类型参数的传递，是调用方值的复制。双方各自的后续修改，互不影响。 我们再看一个传递引用参数的例子： 12345678910111213141516171819202122public class Main &#123; public static void main(String[] args) &#123; Person p = new Person(); String[] fullname = new String[] &#123; \"Homer\", \"Simpson\" &#125;; p.setName(fullname); // 传入fullname数组 System.out.println(p.getName()); // \"Homer Simpson\" fullname[0] = \"Bart\"; // fullname数组的第一个元素修改为\"Bart\" System.out.println(p.getName()); // \"Homer Simpson\"还是\"Bart Simpson\"? &#125;&#125;class Person &#123; private String[] name; public String getName() &#123; return this.name[0] + \" \" + this.name[1]; &#125; public void setName(String[] name) &#123; this.name = name; &#125;&#125; 注意到setName()的参数现在是一个数组。一开始，把fullname数组传进去，然后，修改fullname数组的内容，结果发现，实例p的字段p.name也被修改了！结论：引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方 小结 方法可以让外部代码安全地访问实例字段；方法是一组执行语句，并且可以执行任意逻辑；方法内部遇到return时返回，void表示不返回任何值（注意和返回null不同）；外部代码通过public方法操作实例，内部代码可以调用private方法；理解方法的参数绑定。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java面向对象_1.基础","date":"2020-02-18T00:50:06.074Z","path":"2020/02/18/Java面向对象_1/","text":"面向对象编程，是一种通过对象的方式，把现实世界映射到计算机模型的一种编程方法。现实世界中，我们定义了“人”这种抽象概念，而具体的人则是“小明”、“小红”、“小军”等一个个具体的人。所以，“人”可以定义为一个类（class），而具体的人则是实例（instance）：现实世界 计算机模型 Java代码 人 类 / class class Person { }小明 实例 / ming Person ming = new Person()小红 实例 / hong Person hong = new Person()小军 实例 / jun Person jun = new Person() 定义class 在Java中，创建一个类，例如，给这个类命名为Person，就是定义一个class： 1234class Person &#123; public String name; public int age;&#125; 一个class可以包含多个字段（field），字段用来描述一个类的特征。上面的Person类，我们定义了两个字段，一个是String类型的字段，命名为name，一个是int类型的字段，命名为age。public是用来修饰字段的，它表示这个字段可以被外部访问。 创建实例 定义了class，只是定义了对象模版，而要根据对象模版创建出真正的对象实例，必须用new操作符。new操作符可以创建一个实例，然后，我们需要定义一个引用类型的变量来指向这个实例： Person ming = new Person();上述代码创建了一个Person类型的实例，并通过变量ming指向它。注意区分Person ming是定义Person类型的变量ming，而new Person()是创建Person实例。 有了指向这个实例的变量，我们就可以通过这个变量来操作实例。访问实例变量可以用变量.字段，例如： 1234567ming.name &#x3D; &quot;Xiao Ming&quot;; &#x2F;&#x2F; 对字段name赋值ming.age &#x3D; 12; &#x2F;&#x2F; 对字段age赋值System.out.println(ming.name); &#x2F;&#x2F; 访问字段namePerson hong &#x3D; new Person();hong.name &#x3D; &quot;Xiao Hong&quot;;hong.age &#x3D; 15; 上述两个变量分别指向两个不同的实例，它们在内存中的结构如下： 123456789101112 ┌──────────────────┐ming ──────&gt;│Person instance │ ├──────────────────┤ │name &#x3D; &quot;Xiao Ming&quot;│ │age &#x3D; 12 │ └──────────────────┘ ┌──────────────────┐hong ──────&gt;│Person instance │ ├──────────────────┤ │name &#x3D; &quot;Xiao Hong&quot;│ │age &#x3D; 15 │ └──────────────────┘ 两个instance拥有class定义的name和age字段，且各自都有一份独立的数据，互不干扰。 小结 在OOP中，class和instance是“模版”和“实例”的关系；定义class就是定义了一种数据类型，对应的instance是这种数据类型的实例；class定义的field，在每个instance都会拥有各自的field，且互不干扰；通过new操作符创建新的instance，然后用变量指向它，即可通过变量来引用这个instance；访问实例字段的方法是变量名.字段名；指向instance的变量都是引用变量。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础_数组操作-3.多维数组","date":"2020-02-17T06:48:50.886Z","path":"2020/02/17/Java基础_数组操作-3/","text":"二维数组二维数组就是数组的数组。定义一个二维数组如下： 12345678910public class Main &#123; public static void main(String[] args) &#123; int[][] ns &#x3D; &#123; &#123; 1, 2, 3, 4 &#125;, &#123; 5, 6, 7, 8 &#125;, &#123; 9, 10, 11, 12 &#125; &#125;; System.out.println(ns.length); &#x2F;&#x2F; 3 &#125;&#125; 因为ns包含3个数组，因此，ns.length为3。实际上ns在内存中的结构如下： 123456789 ┌───┬───┬───┬───┐ ┌───┐ ┌──&gt;│ 1 │ 2 │ 3 │ 4 │ns ─────&gt;│░░░│──┘ └───┴───┴───┴───┘ ├───┤ ┌───┬───┬───┬───┐ │░░░│─────&gt;│ 5 │ 6 │ 7 │ 8 │ ├───┤ └───┴───┴───┴───┘ │░░░│──┐ ┌───┬───┬───┬───┐ └───┘ └──&gt;│ 9 │10 │11 │12 │ └───┴───┴───┴───┘ 如果我们定义一个普通数组arr0，然后把ns[0]赋值给它： 1234567891011public class Main &#123; public static void main(String[] args) &#123; int[][] ns &#x3D; &#123; &#123; 1, 2, 3, 4 &#125;, &#123; 5, 6, 7, 8 &#125;, &#123; 9, 10, 11, 12 &#125; &#125;; int[] arr0 &#x3D; ns[0]; System.out.println(arr0.length); &#x2F;&#x2F; 4 &#125;&#125; 实际上arr0就获取了ns数组的第0个元素。因为ns数组的每个元素也是一个数组，因此，arr0指向的数组就是{ 1, 2, 3, 4 }。在内存中，结构如下： 1234567891011 arr0 ─────┐ ▼ ┌───┬───┬───┬───┐ ┌───┐ ┌──&gt;│ 1 │ 2 │ 3 │ 4 │ns ─────&gt;│░░░│──┘ └───┴───┴───┴───┘ ├───┤ ┌───┬───┬───┬───┐ │░░░│─────&gt;│ 5 │ 6 │ 7 │ 8 │ ├───┤ └───┴───┴───┴───┘ │░░░│──┐ ┌───┬───┬───┬───┐ └───┘ └──&gt;│ 9 │10 │11 │12 │ └───┴───┴───┴───┘ 访问二维数组的某个元素需要使用array[row][col]，例如：System.out.println(ns[1][2]); // 7 二维数组的每个数组元素的长度并不要求相同，例如，可以这么定义ns数组： 12345int[][] ns &#x3D; &#123; &#123; 1, 2, 3, 4 &#125;, &#123; 5, 6 &#125;, &#123; 7, 8, 9 &#125;&#125;; 这个二维数组在内存中的结构如下： 123456789 ┌───┬───┬───┬───┐ ┌───┐ ┌──&gt;│ 1 │ 2 │ 3 │ 4 │ns ─────&gt;│░░░│──┘ └───┴───┴───┴───┘ ├───┤ ┌───┬───┐ │░░░│─────&gt;│ 5 │ 6 │ ├───┤ └───┴───┘ │░░░│──┐ ┌───┬───┬───┐ └───┘ └──&gt;│ 7 │ 8 │ 9 │ └───┴───┴───┘ 要打印一个二维数组，可以使用两层嵌套的for循环： 1234567for (int[] arr : ns) &#123; for (int n : arr) &#123; System.out.print(n); System.out.print(&#39;, &#39;); &#125; System.out.println();&#125; 或者使用Java标准库的Arrays.deepToString()： 123456789101112import java.util.Arrays;public class Main &#123; public static void main(String[] args) &#123; int[][] ns &#x3D; &#123; &#123; 1, 2, 3, 4 &#125;, &#123; 5, 6, 7, 8 &#125;, &#123; 9, 10, 11, 12 &#125; &#125;; System.out.println(Arrays.deepToString(ns)); &#125;&#125; 三维数组（基本不使用）三维数组就是二维数组的数组。可以这么定义一个三维数组： 123456789101112131415int[][][] ns &#x3D; &#123; &#123; &#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125; &#125;, &#123; &#123;10, 11&#125;, &#123;12, 13&#125; &#125;, &#123; &#123;14, 15, 16&#125;, &#123;17, 18&#125; &#125;&#125;; 它在内存中的结构如下： 123456789101112131415161718192021 ┌───┬───┬───┐ ┌───┐ ┌──&gt;│ 1 │ 2 │ 3 │ ┌──&gt;│░░░│──┘ └───┴───┴───┘ │ ├───┤ ┌───┬───┬───┐ │ │░░░│─────&gt;│ 4 │ 5 │ 6 │ │ ├───┤ └───┴───┴───┘ │ │░░░│──┐ ┌───┬───┬───┐ ┌───┐ │ └───┘ └──&gt;│ 7 │ 8 │ 9 │ns ────&gt;│░░░│──┘ └───┴───┴───┘ ├───┤ ┌───┐ ┌───┬───┐ │░░░│─────&gt;│░░░│─────&gt;│10 │11 │ ├───┤ ├───┤ └───┴───┘ │░░░│──┐ │░░░│──┐ ┌───┬───┐ └───┘ │ └───┘ └──&gt;│12 │13 │ │ └───┴───┘ │ ┌───┐ ┌───┬───┬───┐ └──&gt;│░░░│─────&gt;│14 │15 │16 │ ├───┤ └───┴───┴───┘ │░░░│──┐ ┌───┬───┐ └───┘ └──&gt;│17 │18 │ └───┴───┘ 如果我们要访问三维数组的某个元素，例如，ns[2][0][1]，只需要顺着定位找到对应的最终元素15即可。理论上，我们可以定义任意的N维数组。但在实际应用中，除了二维数组在某些时候还能用得上，更高维度的数组很少使用。 小结 二维数组就是数组的数组，三维数组就是二维数组的数组；多维数组的每个数组元素长度都不要求相同；打印多维数组可以使用Arrays.deepToString()；最常见的多维数组是二维数组，访问二维数组的一个元素使用array[row][col]。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础_数组操作-2.数组排序","date":"2020-02-17T06:20:24.430Z","path":"2020/02/17/Java基础_数组操作-2/","text":"我们在Java程序基础里介绍了数组这种数据类型。有了数组，我们还需要来操作它。而数组最常见的一个操作就是遍历。 通过for循环就可以遍历数组。因为数组的每个元素都可以通过索引来访问，因此，使用标准的for循环可以完成一个数组的遍历： 123456789public class Main &#123; public static void main(String[] args) &#123; int[] ns &#x3D; &#123; 1, 4, 9, 16, 25 &#125;; for (int i&#x3D;0; i&lt;ns.length; i++) &#123; int n &#x3D; ns[i]; System.out.println(n); &#125; &#125;&#125; 第二种方式是使用for each循环，直接迭代数组的每个元素： 12345678public class Main &#123; public static void main(String[] args) &#123; int[] ns &#x3D; &#123; 1, 4, 9, 16, 25 &#125;; for (int n : ns) &#123; System.out.println(n); &#125; &#125;&#125; 注意：在for (int n : ns)循环中，变量n直接拿到ns数组的元素，而不是索引。显然for each循环更加简洁。但是，for each循环无法拿到数组的索引，因此，到底用哪一种for循环，取决于我们的需要。 打印数组内容 直接打印数组变量，得到的是数组在JVM中的引用地址： 12int[] ns &#x3D; &#123; 1, 1, 2, 3, 5, 8 &#125;;System.out.println(ns); &#x2F;&#x2F; 类似 [I@7852e922 所以为了得到数组的具体内容，使用for each循环来打印它： 1234int[] ns &#x3D; &#123; 1, 1, 2, 3, 5, 8 &#125;;for (int n : ns) &#123; System.out.print(n + &quot;, &quot;);&#125; 使用for each循环打印也很麻烦。幸好Java标准库提供了Arrays.toString()，可以快速打印数组内容：import java.util.Arrays; 123456public class Main &#123; public static void main(String[] args) &#123; int[] ns &#x3D; &#123; 1, 1, 2, 3, 5, 8 &#125;; System.out.println(Arrays.toString(ns)); &#125;&#125; 小结遍历数组可以使用for循环，for循环可以访问数组索引，for each循环直接迭代每个数组元素，但无法获取索引；使用Arrays.toString()可以快速获取数组内容。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础_数组操作-1.遍历数组","date":"2020-02-17T06:16:38.761Z","path":"2020/02/17/Java基础_数组操作-1/","text":"我们在Java程序基础里介绍了数组这种数据类型。有了数组，我们还需要来操作它。而数组最常见的一个操作就是遍历。 通过for循环就可以遍历数组。因为数组的每个元素都可以通过索引来访问，因此，使用标准的for循环可以完成一个数组的遍历： 123456789public class Main &#123; public static void main(String[] args) &#123; int[] ns &#x3D; &#123; 1, 4, 9, 16, 25 &#125;; for (int i&#x3D;0; i&lt;ns.length; i++) &#123; int n &#x3D; ns[i]; System.out.println(n); &#125; &#125;&#125; 第二种方式是使用for each循环，直接迭代数组的每个元素： 12345678public class Main &#123; public static void main(String[] args) &#123; int[] ns &#x3D; &#123; 1, 4, 9, 16, 25 &#125;; for (int n : ns) &#123; System.out.println(n); &#125; &#125;&#125; 注意：在for (int n : ns)循环中，变量n直接拿到ns数组的元素，而不是索引。显然for each循环更加简洁。但是，for each循环无法拿到数组的索引，因此，到底用哪一种for循环，取决于我们的需要。 打印数组内容 直接打印数组变量，得到的是数组在JVM中的引用地址： 12int[] ns &#x3D; &#123; 1, 1, 2, 3, 5, 8 &#125;;System.out.println(ns); &#x2F;&#x2F; 类似 [I@7852e922 所以为了得到数组的具体内容，使用for each循环来打印它： 1234int[] ns &#x3D; &#123; 1, 1, 2, 3, 5, 8 &#125;;for (int n : ns) &#123; System.out.print(n + &quot;, &quot;);&#125; 使用for each循环打印也很麻烦。幸好Java标准库提供了Arrays.toString()，可以快速打印数组内容： 12345678import java.util.Arrays;public class Main &#123; public static void main(String[] args) &#123; int[] ns &#x3D; &#123; 1, 1, 2, 3, 5, 8 &#125;; System.out.println(Arrays.toString(ns)); &#125;&#125; 小结遍历数组可以使用for循环，for循环可以访问数组索引，for each循环直接迭代每个数组元素，但无法获取索引；使用Arrays.toString()可以快速获取数组内容。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础_流程控制-6.break和continue","date":"2020-02-17T06:14:34.758Z","path":"2020/02/17/Java基础_流程控制-6/","text":"无论是while循环还是for循环，有两个特别的语句可以使用，就是break语句和continue语句。break在循环过程中，可以使用break语句跳出当前循环。我们来看一个例子： 123456789101112public class Main &#123; public static void main(String[] args) &#123; int sum &#x3D; 0; for (int i&#x3D;1; ; i++) &#123; sum &#x3D; sum + i; if (i &#x3D;&#x3D; 100) &#123; break; &#125; &#125; System.out.println(sum); &#125;&#125; 使用for循环计算从1到100时，我们并没有在for()中设置循环退出的检测条件。但是，在循环内部，我们用if判断，如果i==100，就通过break退出循环。注意：break跳出的是自己的那一层循环，并不会结束上层循环 continuebreak会跳出当前循环，也就是整个循环都不会执行了。而continue则是提前结束本次循环，直接继续执行下次循环。我们看一个例子： 1234567891011121314public class Main &#123; public static void main(String[] args) &#123; int sum &#x3D; 0; for (int i&#x3D;1; i&lt;&#x3D;10; i++) &#123; System.out.println(&quot;begin i &#x3D; &quot; + i); if (i % 2 &#x3D;&#x3D; 0) &#123; continue; &#x2F;&#x2F; continue语句会结束本次循环 &#125; sum &#x3D; sum + i; System.out.println(&quot;end i &#x3D; &quot; + i); &#125; System.out.println(sum); &#x2F;&#x2F; 25 &#125;&#125; 在多层嵌套的循环中，continue语句同样是结束本次自己所在的循环。 小结 break语句可以跳出当前循环；break语句通常配合if，在满足条件时提前结束整个循环；break语句总是跳出最近的一层循环；continue语句可以提前结束本次循环；continue语句通常配合if，在满足条件时提前结束本次循环。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础_流程控制-5.for循环","date":"2020-02-17T06:12:37.739Z","path":"2020/02/17/Java基础_流程控制-5/","text":"除了while和do while循环，Java使用最广泛的是for循环。for循环的功能非常强大，它使用计数器实现循环。for循环会先初始化计数器，然后，在每次循环前检测循环条件，在每次循环后更新计数器。计数器变量通常命名为i。 我们把1到100求和用for循环改写一下： 123456789public class Main &#123; public static void main(String[] args) &#123; int sum &#x3D; 0; for (int i&#x3D;1; i&lt;&#x3D;100; i++) &#123; sum &#x3D; sum + i; &#125; System.out.println(sum); &#125;&#125; 在for循环执行前，会先执行初始化语句int i=1，它定义了计数器变量i并赋初始值为1，然后，循环前先检查循环条件i&lt;=100，循环后自动执行i++，因此，和while循环相比，for循环把更新计数器的代码统一放到了一起。在for循环的循环体内部，不需要去更新变量i。for循环的结构是： 123for (初始条件; 循环检测条件; 循环后更新计数器) &#123; &#x2F;&#x2F; 执行语句&#125; 如果要计算一个整型数组各个元素的和，可以使用for循环实现： 1234567891011public class Main &#123; public static void main(String[] args) &#123; int[] ns &#x3D; &#123; 1, 4, 9, 16, 25 &#125;; int sum &#x3D; 0; for (int i&#x3D;0; i&lt;ns.length; i++) &#123; System.out.println(&quot;i &#x3D; &quot; + i + &quot;, ns[i] &#x3D; &quot; + ns[i]); sum &#x3D; sum + ns[i]; &#125; System.out.println(&quot;sum &#x3D; &quot; + sum); &#125;&#125; for each循环 for循环经常用来遍历数组，因为通过计数器可以根据索引来访问数组的每个元素： 1234int[] ns &#x3D; &#123; 1, 4, 9, 16, 25 &#125;;for (int i&#x3D;0; i&lt;ns.length; i++) &#123; System.out.println(ns[i]);&#125; Java还提供了另一种for each循环，它可以更简单地遍历数组： 12345678public class Main &#123; public static void main(String[] args) &#123; int[] ns &#x3D; &#123; 1, 4, 9, 16, 25 &#125;; for (int n : ns) &#123; System.out.println(n); &#125; &#125;&#125; 和for循环相比，for each循环的变量n不再是计数器，而是直接对应到数组的每个元素。for each循环的写法也更简洁。但是，for each循环无法指定遍历顺序，也无法获取数组的索引。除了数组外，for each循环能够遍历所有“可迭代”的数据类型，包括List、Map等。 小结 for循环通过计数器可以实现复杂循环；for each循环可以直接遍历数组的每个元素；最佳实践：计数器变量定义在for循环内部，循环体内部不修改计数器；","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础_流程控制-4.while循环","date":"2020-02-17T06:11:28.335Z","path":"2020/02/17/Java基础_流程控制-4/","text":"循环语句就是让计算机根据条件做循环计算，在条件满足时继续循环，条件不满足时退出循环。例如，计算从1到100的和：1 + 2 + 3 + 4 + … + 100 = ? while循环在每次循环开始前，首先判断条件是否成立。如果计算结果为true，就把循环体内的语句执行一遍，如果计算结果为false，那就直接跳到while循环的末尾，继续往下执行。求1到100的和可以用如下代码实现： 1234567891011public class Main &#123; public static void main(String[] args) &#123; int sum &#x3D; 0; &#x2F;&#x2F; 累加的和，初始化为0 int n &#x3D; 1; while (n &lt;&#x3D; 100) &#123; &#x2F;&#x2F; 循环条件是n &lt;&#x3D; 100 sum &#x3D; sum + n; &#x2F;&#x2F; 把n累加到sum中 n ++; &#x2F;&#x2F; n自身加1 &#125; System.out.println(sum); &#x2F;&#x2F; 5050 &#125;&#125; 注意：while循环是先判断循环条件，再循环，因此，有可能一次循环都不做。所以，在写循环条件的时候要避免死循环。 小结 while循环先判断循环条件是否满足，再执行循环语句；while循环可能一次都不执行；编写循环时要注意循环条件，并避免死循环。 do while循环 在Java中，while循环是先判断循环条件，再执行循环。而另一种do while循环则是先执行循环，再判断条件，条件满足时继续循环，条件不满足时退出。 123do &#123; 执行循环语句&#125; while (条件表达式); 可见，do while循环会至少循环一次。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础_流程控制-3.switch多重选择","date":"2020-02-17T06:10:02.512Z","path":"2020/02/17/Java基础_流程控制-3/","text":"除了if语句外，还有一种条件判断switch，是根据某个表达式的结果，分别去执行不同的分支。例如，在游戏中，让用户选择选项：单人模式多人模式退出游戏 这时，switch语句就派上用场了。switch语句根据switch (表达式)计算的结果，跳转到匹配的case结果，然后继续执行后续语句，直到遇到break结束执行。例子： 12345678910111213141516171819public class Main &#123; public static void main(String[] args) &#123; int option &#x3D; 1; switch (option) &#123; case 1: System.out.println(&quot;Selected 1&quot;); break; case 2: System.out.println(&quot;Selected 2&quot;); break; case 3: System.out.println(&quot;Selected 3&quot;); break; default: System.out.println(&quot;Not selected&quot;); break; &#125; &#125;&#125; 如果option的值没有匹配到任何case，例如option = 99，那么，switch语句不会执行任何语句。这时，可以给switch语句加一个default，当没有匹配到任何case时，执行default： 使用switch时，注意case语句并没有花括号{}，而且，case语句具有“穿透性”，如果没有break；会导致继续执行下面的case导致形成意想不到的结果。 switch语句还可以匹配字符串。字符串匹配时，是比较“内容相等”。例如： 12345678910111213141516171819public class Main &#123; public static void main(String[] args) &#123; String fruit &#x3D; &quot;apple&quot;; switch (fruit) &#123; case &quot;apple&quot;: System.out.println(&quot;Selected apple&quot;); break; case &quot;pear&quot;: System.out.println(&quot;Selected pear&quot;); break; case &quot;mango&quot;: System.out.println(&quot;Selected mango&quot;); break; default: System.out.println(&quot;No fruit selected&quot;); break; &#125; &#125;&#125; yield大多数时候，在switch表达式内部，我们会返回简单的值。但是，如果需要复杂的语句，我们也可以写很多语句，放到{…}里，然后，用yield返回一个值作为switch语句的返回值： 1234567891011121314public class Main &#123; public static void main(String[] args) &#123; String fruit &#x3D; &quot;orange&quot;; int opt &#x3D; switch (fruit) &#123; case &quot;apple&quot; -&gt; 1; case &quot;pear&quot;, &quot;mango&quot; -&gt; 2; default -&gt; &#123; int code &#x3D; fruit.hashCode(); yield code; &#x2F;&#x2F; switch语句返回值 &#125; &#125;; System.out.println(&quot;opt &#x3D; &quot; + opt); &#125;&#125; 小结switch语句可以做多重选择，然后执行匹配的case语句后续代码；switch的计算结果必须是整型、字符串或枚举类型；注意千万不要漏写break，建议打开fall-through警告；总是写上default，建议打开missing default警告；从Java 13开始，switch语句升级为表达式，不再需要break，并且允许使用yield返回值。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础_流程控制-2.if判断","date":"2020-02-17T06:08:41.296Z","path":"2020/02/17/Java基础_流程控制-2/","text":"在Java中，如果要根据一个条件来判断是否执行某一语句块时，要用到if语句。 if语句的基本语法 123if (条件) &#123; &#x2F;&#x2F; 条件满足时执行&#125; 根据if的计算结果（true还是false），决定是否执行if语句块（即花括号{}包含的所有语句） 例子： 123456789public class Main &#123; public static void main(String[] args) &#123; int n &#x3D; 70; if (n &gt;&#x3D; 60) &#123; System.out.println(&quot;及格了&quot;); &#125; System.out.println(&quot;END&quot;); &#125;&#125; 当条件n &gt;= 60计算结果为true时，if语句块被执行，将打印”及格了”，否则，if语句块将被跳过。修改n的值可以看到执行效果。{}内可以包含多条语句，不止是及格了一条，但是如果只有一条语句的时候，可以省略{} else if语句还可以编写一个else { … }，当条件判断为false时，将执行else的语句块例子： 1234567891011public class Main &#123; public static void main(String[] args) &#123; int n &#x3D; 70; if (n &gt;&#x3D; 60) &#123; System.out.println(&quot;及格了&quot;); &#125; else &#123; System.out.println(&quot;挂科了&quot;); &#125; System.out.println(&quot;END&quot;); &#125;&#125; 修改上述代码n的值，观察if条件为true或false时，程序执行的语句块。else不是必须的。 还可以用多个if … else if … 12345678910111213public class Main &#123; public static void main(String[] args) &#123; int n &#x3D; 70; if (n &gt;&#x3D; 90) &#123; System.out.println(&quot;优秀&quot;); &#125; else if (n &gt;&#x3D; 60) &#123; System.out.println(&quot;及格了&quot;); &#125; else &#123; System.out.println(&quot;挂科了&quot;); &#125; System.out.println(&quot;END&quot;); &#125;&#125; 在串联使用多个if时，要特别注意判断顺序。正确的方式是按照判断范围从大到小依次判断。使用if时，还要特别注意边界条件。 前面讲过了浮点数在计算机中常常无法精确表示，并且计算可能出现误差，因此，判断浮点数相等用==判断不靠谱以下代码是错误的 12345678910public class Main &#123; public static void main(String[] args) &#123; double x &#x3D; 1 - 9.0 &#x2F; 10; if (x &#x3D;&#x3D; 0.1) &#123; System.out.println(&quot;x is 0.1&quot;); &#125; else &#123; System.out.println(&quot;x is NOT 0.1&quot;); &#125; &#125;&#125; 正确的方法是利用差值小于某个临界值来判断： 12345678910public class Main &#123; public static void main(String[] args) &#123; double x &#x3D; 1 - 9.0 &#x2F; 10; if (Math.abs(x - 0.1) &lt; 0.00001) &#123; System.out.println(&quot;x is 0.1&quot;); &#125; else &#123; System.out.println(&quot;x is NOT 0.1&quot;); &#125; &#125;&#125; 判断引用类型相等 在Java中，判断值类型的变量是否相等，可以使用==运算符。但是，判断引用类型的变量是否相等，==表示“引用是否相等”，或者说，是否指向同一个对象。例如，下面的两个String类型，它们的内容是相同的，但是，分别指向不同的对象，用==判断，结果为false： 12345678910111213public class Main &#123; public static void main(String[] args) &#123; String s1 &#x3D; &quot;hello&quot;; String s2 &#x3D; &quot;HELLO&quot;.toLowerCase(); System.out.println(s1); System.out.println(s2); if (s1 &#x3D;&#x3D; s2) &#123; System.out.println(&quot;s1 &#x3D;&#x3D; s2&quot;); &#125; else &#123; System.out.println(&quot;s1 !&#x3D; s2&quot;); &#125; &#125;&#125; 输出：s1 != s2 要判断引用类型的变量内容是否相等，必须使用equals()方法： 1234567891011121314public class Main &#123; public static void main(String[] args) &#123; String s1 &#x3D; &quot;hello&quot;; String s2 &#x3D; &quot;HELLO&quot;.toLowerCase(); System.out.println(s1); System.out.println(s2); if (s1.equals(s2)) &#123; System.out.println(&quot;s1 equals s2&quot;); &#125; else &#123; System.out.println(&quot;s1 not equals s2&quot;); &#125; &#125;&#125;输出：s1 equals s2 注意：执行语句s1.equals(s2)时，如果变量s1为null，会报空指针异常NullPointerException： 12345678public class Main &#123; public static void main(String[] args) &#123; String s1 &#x3D; null; if (s1.equals(&quot;hello&quot;)) &#123; System.out.println(&quot;hello&quot;); &#125; &#125;&#125; 如果要处理NullPointerException，可以使用短路运算符&amp;&amp; 123456789public class Main &#123; public static void main(String[] args) &#123; String s1 &#x3D; null; if (s1 !&#x3D; null &amp;&amp; s1.equals(&quot;hello&quot;)) &#123; System.out.println(&quot;hello&quot;); &#125; &#125;&#125;还可以把一定不是null的对象&quot;hello&quot;放到前面：例如：if (&quot;hello&quot;.equals(s)) &#123; ... &#125;。 小结if … else可以做条件判断，else是可选的；不推荐省略花括号{}；多个if … else串联要特别注意判断顺序；要注意if的边界条件；要注意浮点数判断相等不能直接用==运算符；引用类型判断内容相等要使用equals()，注意避免空指针异常NullPointerException。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础_流程控制-1.输入与输出","date":"2020-02-17T05:22:02.614Z","path":"2020/02/17/Java基础_流程控制-1/","text":"输出在前面的代码中，我们总是使用System.out.println()来向屏幕输出一些内容。println是print line的缩写，表示输出并换行。因此，如果输出后不想换行，可以用print() 格式化输出如果要把数据显示成我们期望的格式，就需要使用格式化输出的功能。格式化输出使用System.out.printf()，通过使用占位符%?，printf()可以把后面的参数格式化成指定格式： 1234567public class Main &#123; public static void main(String[] args) &#123; double d &#x3D; 3.1415926; System.out.printf(&quot;%.2f\\n&quot;, d); &#x2F;&#x2F; 显示两位小数3.14 System.out.printf(&quot;%.4f\\n&quot;, d); &#x2F;&#x2F; 显示4位小数3.1416 &#125;&#125; 以下是Java中的多种占位符： 占位符 说明%d 格式化输出整数%x 格式化输出十六进制整数%f 格式化输出浮点数%e 格式化输出科学计数法表示的浮点数%s 格式化字符串 由于%表示占位符，因此，连续两个%%表示一个%字符本身（占位符本身还有更详细的格式化参数，这里就不再赘述） 输入和输出相比，Java的输入就要复杂得多。 123456789101112import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner scanner &#x3D; new Scanner(System.in); &#x2F;&#x2F; 创建Scanner对象 System.out.print(&quot;Input your name: &quot;); &#x2F;&#x2F; 打印提示 String name &#x3D; scanner.nextLine(); &#x2F;&#x2F; 读取一行输入并获取字符串 System.out.print(&quot;Input your age: &quot;); &#x2F;&#x2F; 打印提示 int age &#x3D; scanner.nextInt(); &#x2F;&#x2F; 读取一行输入并获取整数 System.out.printf(&quot;Hi, %s, you are %d\\n&quot;, name, age); &#x2F;&#x2F; 格式化输出 &#125;&#125; 首先，我们通过import语句导入java.util.Scanner，import是导入某个类的语句，必须放到Java源代码的开头，后面我们在Java的package中会详细讲解如何使用import。然后，创建Scanner对象并传入System.in。System.out代表标准输出流，而System.in代表标准输入流。直接使用System.in读取用户输入虽然是可以的，但需要更复杂的代码，而通过Scanner就可以简化后续的代码。有了Scanner对象后，要读取用户输入的字符串，使用scanner.nextLine()，要读取用户输入的整数，使用scanner.nextInt()。Scanner会自动转换数据类型，因此不必手动转换。 小结Java提供的输出包括：System.out.println() / print() / printf()，其中printf()可以格式化输出；Java提供Scanner对象来方便输入，读取对应的类型可以使用：scanner.nextLine() / nextInt() / nextDouble() /","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础_Java程序基础-6.数组类型","date":"2020-02-17T05:18:20.968Z","path":"2020/02/17/Java基础_Java程序基础-6/","text":"如果有一组类型相同的变量，例如，5位同学的成绩，可以这么写： 12345678910public class Main &#123; public static void main(String[] args) &#123; // 5位同学的成绩: int n1 = 68; int n2 = 79; int n3 = 91; int n4 = 85; int n5 = 62; &#125;&#125; 但其实没有必要定义5个int变量。可以使用数组来表示“一组”int类型定义一个数组类型的变量，使用数组类型“类型[]”，例如，int[]。和单个基本类型变量不同，数组变量初始化必须使用new int[5]表示创建一个可容纳5个int元素的数组。int[] arr = new int[5];Java的数组有几个特点：数组所有元素初始化为默认值，整型都是0，浮点型是0.0，布尔型是false；数组一旦创建后，大小就不可改变。要访问数组中的某一个元素，需要使用索引。数组索引从0开始，例如，5个元素的数组，索引范围是0~4。可以修改数组中的某一个元素，使用赋值语句，例如，ns[1] = 79;。可以用数组变量.length获取数组大小（长度）（数组是引用类型，在使用索引访问数组元素时，如果索引超出范围，运行时将报错） 也可以在定义数组时直接指定初始化的元素，这样就不必写出数组大小，而是由编译器自动推算数组大小例如： 1234567public class Main &#123; public static void main(String[] args) &#123; // 5位同学的成绩: int[] ns = new int[] &#123; 68, 79, 91, 85, 62 &#125;; System.out.println(ns.length); // 编译器自动推算数组大小为5 &#125;&#125; 还可以简写成：int[] ns = { 68, 79, 91, 85, 62 }; 注意数组是引用类型，并且数组大小不可变。例如：定义了一个数组 1ns = new int[] &#123; 68, 79, 91, 85, 62 &#125;; 然后再修改他的长度 1ns = new int[] &#123; 1, 2, 3 &#125;; 数组大小看上去变了，其实没有改变对于数组ns来说，执行ns = new int[] { 68, 79, 91, 85, 62 };时，它指向一个5个元素的数组： 12345678910111213 ns │ ▼┌───┬───┬───┬───┬───┬───┬───┐│ │68 │79 │91 │85 │62 │ │└───┴───┴───┴───┴───┴───┴───┘执行ns = new int[] &#123; 1, 2, 3 &#125;;时，它指向一个新的3个元素的数组： ns ──────────────────────┐ │ ▼┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐│ │68 │79 │91 │85 │62 │ │ 1 │ 2 │ 3 │ │└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘ 但是，原有的5个元素的数组并没有改变，只是无法通过变量ns引用到它们而已。 字符串数组如果数组元素不是基本类型，而是一个引用类型，那么，修改数组元素会有哪些不同？字符串是引用类型，因此我们先定义一个字符串数组： 123String[] names = &#123; \"ABC\", \"XYZ\", \"zoo\"&#125;; 对于String[]类型的数组变量names，它实际上包含3个元素，但每个元素都指向某个字符串对象： 123456789 ┌─────────────────────────┐ names │ ┌─────────────────────┼───────────┐ │ │ │ │ │ ▼ │ │ ▼ ▼┌───┬───┬─┴─┬─┴─┬───┬───────┬───┬───────┬───┬───────┬───┐│ │░░░│░░░│░░░│ │ \"ABC\" │ │ \"XYZ\" │ │ \"zoo\" │ │└───┴─┬─┴───┴───┴───┴───────┴───┴───────┴───┴───────┴───┘ │ ▲ └─────────────────┘ 对names[1]进行赋值，例如names[1] = “cat”;，效果如下： 123456789 ┌─────────────────────────────────────────────────┐ names │ ┌─────────────────────────────────┐ │ │ │ │ │ │ ▼ │ │ ▼ ▼┌───┬───┬─┴─┬─┴─┬───┬───────┬───┬───────┬───┬───────┬───┬───────┬───┐│ │░░░│░░░│░░░│ │ \"ABC\" │ │ \"XYZ\" │ │ \"zoo\" │ │ \"cat\" │ │└───┴─┬─┴───┴───┴───┴───────┴───┴───────┴───┴───────┴───┴───────┴───┘ │ ▲ └─────────────────┘ 这里注意到原来names[1]指向的字符串”XYZ”并没有改变，仅仅是将names[1]的引用从指向”XYZ”改成了指向”cat”，其结果是字符串”XYZ”再也无法通过names[1]访问到了。 小结数组是同一数据类型的集合，数组一旦创建后，大小就不可变；可以通过索引访问数组元素，但索引超出范围将报错；数组元素可以是值类型（如int）或引用类型（如String），但数组本身是引用类型；","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础_Java程序基础-5.字符和字符串","date":"2020-02-17T03:13:49.096Z","path":"2020/02/17/Java基础_Java程序基础-5/","text":"字符类型字符类型char是基本数据类型，它是character的缩写。一个char保存一个Unicode字符： 12char c1 = 'A';char c2 = '中'; 因为Java在内存中总是使用Unicode表示字符，所以，一个英文字符和一个中文字符都用一个char类型表示，它们都占用两个字节。要显示一个字符的Unicode编码，只需将char类型直接赋值给int类型即可： 12int n1 = 'A'; // 字母“A”的Unicodde编码是65int n2 = '中'; // 汉字“中”的Unicode编码是20013 还可以直接用转义字符\\u+Unicode编码来表示一个字符：// 注意是十六进制: 12char c3 = '\\u0041'; // 'A'，因为十六进制0041 = 十进制65char c4 = '\\u4e2d'; // '中'，因为十六进制4e2d = 十进制20013 字符串类型和char类型不同，字符串类型String是引用类型，我们用双引号”…”表示字符串。一个字符串可以存储0个到任意个字符： 1234String s = \"\"; // 空字符串，包含0个字符String s1 = \"A\"; // 包含一个字符String s2 = \"ABC\"; // 包含3个字符String s3 = \"中文 ABC\"; // 包含6个字符，其中有一个空格 因为字符串使用双引号”…”表示开始和结束，那如果字符串本身恰好包含一个”字符怎么表示？例如，”abc”xyz”，编译器就无法判断中间的引号究竟是字符串的一部分还是表示字符串结束。这个时候，我们需要借助转义字符\\： 1String s = \"abc\\\"xyz\"; // 包含7个字符: a, b, c, \", x, y, z 因为\\是转义字符，所以，两个\\表示一个\\字符： 1String s = \"abc\\\\xyz\"; // 包含7个字符: a, b, c, \\, x, y, z 常见的转义字符包括： 1234567\\\" 表示字符\"\\' 表示字符'\\\\ 表示字符\\\\n 表示换行符\\r 表示回车符\\t 表示Tab\\u#### 表示一个Unicode编码的字符 字符串连接Java的编译器对字符串做了特殊照顾，可以使用+连接任意字符串和其他数据类型，这样极大地方便了字符串的处理。例如： 12345678public class Main &#123; public static void main(String[] args) &#123; String s1 = \"Hello\"; String s2 = \"world\"; String s = s1 + \" \" + s2 + \"!\"; System.out.println(s); &#125;&#125; 注：如果用+连接字符串和其他数据类型，会将其他数据类型先自动转型为字符串 多行字符串如果我们要表示多行字符串，使用+号连接会非常不方便： 123String s = \"first line \\n\" + \"second line \\n\" + \"end\"; 从Java 13开始，字符串可以用”””…”””表示多行字符串（Text Blocks）了。举个例子： 1234567891011public class Main &#123; public static void main(String[] args) &#123; String s = \"\"\" SELECT * FROM users WHERE id &gt; 100 ORDER BY name DESC \"\"\"; System.out.println(s); &#125;&#125; 上述多行字符串实际上是5行，在最后一个DESC后面还有一个\\n。如果我们不想在字符串末尾加一个\\n，就需要这么写： 12345String s = \"\"\" SELECT * FROM users WHERE id &gt; 100 ORDER BY name DESC\"\"\"; 不可变特性Java的字符串除了是一个引用类型外，还有个重要特点，就是字符串不可变。考察以下代码： 12345678public class Main &#123; public static void main(String[] args) &#123; String s = \"hello\"; System.out.println(s); // 显示 hello s = \"world\"; System.out.println(s); // 显示 world &#125;&#125; 观察执行结果，难道字符串s变了吗？其实变的不是字符串，而是变量s的“指向”。执行String s = “hello”;时，JVM虚拟机先创建字符串”hello”，然后，把字符串变量s指向它： 1234567891011121314 s │ ▼┌───┬───────────┬───┐│ │ \"hello\" │ │└───┴───────────┴───┘紧接着，执行s = \"world\";时，JVM虚拟机先创建字符串\"world\"，然后，把字符串变量s指向它： s ──────────────┐ │ ▼┌───┬───────────┬───┬───────────┬───┐│ │ \"hello\" │ │ \"world\" │ │└───┴───────────┴───┴───────────┴───┘ 原来的字符串”hello”还在，只是我们无法通过变量s访问它而已。因此，字符串的不可变是指字符串内容不可变。理解了引用类型的“指向”后，试解释下面的代码输出 12345678public class Main &#123; public static void main(String[] args) &#123; String s = \"hello\"; String t = s; s = \"world\"; System.out.println(t); // t是\"hello\"还是\"world\"? &#125;&#125; 输出：hello 空值null引用类型的变量可以指向一个空值null，它表示不存在，即该变量不指向任何对象。例如： 1234String s1 = null; // s1是nullString s2; // 没有赋初值值，s2也是nullString s3 = s1; // s3也是nullString s4 = \"\"; // s4指向空字符串，不是null 注意要区分空值null和空字符串””，空字符串是一个有效的字符串对象，它不等于null。 小结Java的字符类型char是基本类型，字符串类型String是引用类型；基本类型的变量是“持有”某个数值，引用类型的变量是“指向”某个对象；引用类型的变量可以是空值null；要区分空值null和空字符串””。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础_Java程序基础-4.布尔运算","date":"2020-02-17T02:39:08.045Z","path":"2020/02/17/Java基础_Java程序基础-4/","text":"对于布尔类型boolean，永远只有true和false两个值。布尔运算是一种关系运算，包括以下几类： 1234567891011比较运算符：&gt;，&gt;=，&lt;，&lt;=，==，!=与运算 &amp;&amp;或运算 ||非运算 !下面是一些示例：boolean isGreater = 5 &gt; 3; // trueint age = 12;boolean isZero = age == 0; // falseboolean isNonZero = !isZero; // trueboolean isAdult = age &gt;= 18; // falseboolean isTeenager = age &gt;6 &amp;&amp; age &lt;18; // true 关系运算符的优先级从高到低依次是： 12345!\\&gt;，&gt;=，&lt;，&lt;===，!=&amp;&amp;|| 短路运算布尔运算的一个重要特点是短路运算。如果一个布尔运算的表达式能提前确定结果，则后续的计算不再执行，直接返回结果。因为false &amp;&amp; x的结果总是false，无论x是true还是false，因此，与运算在确定第一个值为false后，不再继续计算，而是直接返回false。 1234567public class Main &#123; public static void main(String[] args) &#123; boolean b = 5 &lt; 3; boolean result = b &amp;&amp; (5 / 0 &gt; 0); System.out.println(result); &#125;&#125; 如果没有短路运算，&amp;&amp;后面的表达式会由于除数为0而报错，但实际上该语句并未报错，原因在于与运算是短路运算符，提前计算出了结果false。如果变量b的值为true，则表达式变为true &amp;&amp; (5 / 0 &gt; 0)。因为无法进行短路运算，该表达式必定会由于除数为0而报错，可以自行测试。类似的，对于||运算，只要能确定第一个值为true，后续计算也不再进行，而是直接返回true 三元运算符Java还提供一个三元运算符b ? x : y，它根据第一个布尔表达式的结果，分别返回后续两个表达式之一的计算结果。注意到三元运算b ? x : y会首先计算b，如果b为true，则只计算x，否则，只计算y。此外，x和y的类型必须相同，因为返回值不是boolean，而是x和y之一。 小结与运算和或运算是短路运算；三元运算b ? x : y后面的类型必须相同，三元运算也是“短路运算”，只计算x或y。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础_Java程序基础-3.浮点数运算","date":"2020-02-17T02:34:31.525Z","path":"2020/02/17/Java基础_Java程序基础-3/","text":"浮点数运算和整数运算相比，只能进行加减乘除这些数值计算，不能做位运算和移位运算。在计算机中，浮点数虽然表示的范围大，但是，浮点数有个非常重要的特点，就是浮点数常常无法精确表示。 浮点数0.1在计算机中就无法精确表示，因为十进制的0.1换算成二进制是一个无限循环小数，很显然，无论使用float还是double，都只能存储一个0.1的近似值。但是，0.5这个浮点数又可以精确地表示。因为浮点数常常无法精确表示，因此，浮点数运算会产生误差： 123456789public class Main &#123; public static void main(String[] args) &#123; double x = 1.0 / 10; double y = 1 - 9.0 / 10; // 观察x和y是否相等: System.out.println(x); System.out.println(y); &#125;&#125; 结果：0.10.09999999999999998 浮点数的比较由于浮点数存在运算误差，所以比较两个浮点数是否相等常常会出现错误的结果。正确的比较方法是判断两个浮点数之差的绝对值是否小于一个很小的数： 12345678// 比较x和y是否相等，先计算其差的绝对值:double r = Math.abs(x - y);// 再判断绝对值是否足够小:if (r &lt; 0.00001) &#123; // 可以认为相等&#125; else &#123; // 不相等&#125; 浮点数在内存的表示方法和整数比更加复杂。Java的浮点数完全遵循IEEE-754标准，这也是绝大多数计算机平台都支持的浮点数标准表示方法。 溢出整数运算在除数为0时会报错，而浮点数运算在除数为0时，不会报错，但会返回几个特殊值：NaN表示Not a NumberInfinity表示无穷大-Infinity表示负无穷大例如： 123double d1 = 0.0 / 0; // NaNdouble d2 = 1.0 / 0; // Infinitydouble d3 = -1.0 / 0; // -Infinity 这三种特殊值在实际运算中很少碰到，我们只需要了解即可。 强制转型可以将浮点数强制转型为整数。在转型时，浮点数的小数部分会被丢掉。如果转型后超过了整型能表示的最大范围，将返回整型的最大值。例如： 12345int n1 = (int) 12.3; // 12int n2 = (int) 12.7; // 12int n2 = (int) -12.7; // -12int n3 = (int) (12.7 + 0.5); // 13int n4 = (int) 1.2e20; // 2147483647 如果要进行四舍五入，可以对浮点数加上0.5再强制转型： 1234567public class Main &#123; public static void main(String[] args) &#123; double d = 2.6; int n = (int) (d + 0.5); System.out.println(n); &#125;&#125; 小结浮点数常常无法精确表示，并且浮点数的运算结果可能有误差；比较两个浮点数通常比较它们的绝对值之差是否小于一个特定值；整型和浮点型运算时，整型会自动提升为浮点型；可以将浮点型强制转为整型，但超出范围后将始终返回整型的最大值。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础_Java程序基础-2.整数运算","date":"2020-02-16T14:32:24.877Z","path":"2020/02/16/Java基础_Java程序基础-2/","text":"2.整数运算Java的整数运算遵循四则运算规则，可以使用任意嵌套的小括号。四则运算规则和初等数学一致。 整数的数值表示不但是精确的，而且整数运算永远是精确的，即使是除法也是精确的，因为两个整数相除只能得到结果的整数部分： 1int x = 12345 / 67; // 184 求余运算使用%： 1int y = 12345 % 67; // 12345÷67的余数是17 特别注意：整数的除法对于除数为0时运行时将报错，但编译不会报错。 溢出要特别注意，整数由于存在范围限制，如果计算结果超出了范围，就会产生溢出，而溢出不会出错，却会得到一个奇怪的结果 要解决上面的问题，可以把int换成long类型，由于long可表示的整型范围更大，所以结果就不会溢出： 12345678long x = 2147483640;long y = 15;long sum = x + y;System.out.println(sum); // 2147483655还有一种简写的运算符，即+=，-=，*=，/=，它们的使用方法如下：n += 100; // 3409, 相当于 n = n + 100;n -= 100; // 3309, 相当于 n = n - 100; 自增/自减Java还提供了++运算和–运算，它们可以对一个整数进行加1和减1的操作：// 自增/自减运算 注意++写在前面和后面计算结果是不同的，++n表示先加1再引用n，n++表示先引用n再加1。不建议把++运算混入到常规运算中，容易自己把自己搞懵了。 移位运算在计算机中，整数总是以二进制的形式表示。例如，int类型的整数7使用4字节表示的二进制如下：00000000 0000000 0000000 00000111 可以对整数进行移位运算。对整数7左移1位将得到整数14，左移两位将得到整数28： 1234567891011121314151617181920212223242526int n = 7; // 00000000 00000000 00000000 00000111 = 7int a = n &lt;&lt; 1; // 00000000 00000000 00000000 00001110 = 14int b = n &lt;&lt; 2; // 00000000 00000000 00000000 00011100 = 28int c = n &lt;&lt; 28; // 01110000 00000000 00000000 00000000 = 1879048192int d = n &lt;&lt; 29; // 11100000 00000000 00000000 00000000 = -536870912左移29位时，由于最高位变成1，因此结果变成了负数。类似的，对整数7进行右移，结果如下：int n = 7; // 00000000 00000000 00000000 00000111 = 7int a = n &gt;&gt; 1; // 00000000 00000000 00000000 00000011 = 3int b = n &gt;&gt; 2; // 00000000 00000000 00000000 00000001 = 1int c = n &gt;&gt; 3; // 00000000 00000000 00000000 00000000 = 0如果对一个负数进行右移，最高位的1不动，结果仍然是一个负数：int n = -536870912;int a = n &gt;&gt; 1; // 11110000 00000000 00000000 00000000 = -268435456int b = n &gt;&gt; 2; // 10111000 00000000 00000000 00000000 = -134217728int c = n &gt;&gt; 28; // 11111111 11111111 11111111 11111110 = -2int d = n &gt;&gt; 29; // 11111111 11111111 11111111 11111111 = -1还有一种不带符号的右移运算，使用&gt;&gt;&gt;，它的特点是符号位跟着动，因此，对一个负数进行&gt;&gt;&gt;右移，它会变成正数，原因是最高位的1变成了0：int n = -536870912;int a = n &gt;&gt;&gt; 1; // 01110000 00000000 00000000 00000000 = 1879048192int b = n &gt;&gt;&gt; 2; // 00111000 00000000 00000000 00000000 = 939524096int c = n &gt;&gt;&gt; 29; // 00000000 00000000 00000000 00000111 = 7int d = n &gt;&gt;&gt; 31; // 00000000 00000000 00000000 00000001 = 1 对byte和short类型进行移位时，会首先转换为int再进行位移。仔细观察可发现，左移实际上就是不断地×2，右移实际上就是不断地÷2。 位运算位运算是按位进行与、或、非和异或的运算。与运算的规则是，必须两个数同时为1，结果才为1： 1234n = 0 &amp; 0; // 0n = 0 &amp; 1; // 0n = 1 &amp; 0; // 0n = 1 &amp; 1; // 1 或运算的规则是，只要任意一个为1，结果就为1： 1234n = 0 | 0; // 0n = 0 | 1; // 1n = 1 | 0; // 1n = 1 | 1; // 1 非运算的规则是，0和1互换： 12n = ~0; // 1n = ~1; // 0 异或运算的规则是，如果两个数不同，结果为1，否则为0： 1234n = 0 ^ 0; // 0n = 0 ^ 1; // 1n = 1 ^ 0; // 1n = 1 ^ 1; // 0 对两个整数进行位运算，实际上就是按位对齐，然后依次对每一位进行运算。例如： 1234567public class Main &#123; public static void main(String[] args) &#123; int i = 167776589; // 00001010 00000000 00010001 01001101 int n = 167776512; // 00001010 00000000 00010001 00000000 System.out.println(i &amp; n); // 167776512 &#125;&#125; 运算优先级在Java的计算表达式中，运算优先级从高到低依次是： 12345678()! ~ ++ --\\* / %\\+ -&lt;&lt; &gt;&gt; &gt;&gt;&gt;&amp;|\\+= -= *= /= 记不住也没关系，只需要加括号就可以保证运算的优先级正确。 类型自动提升与强制转型在运算过程中，如果参与运算的两个数类型不一致，那么计算结果为较大类型的整型。例如，short和int计算，结果总是int，原因是short首先自动被转型为int也可以将结果强制转型，即将大范围的整数转型为小范围的整数。强制转型使用(类型)，例如，将int强制转型为short： 12int i = 12345;short s = (short) i; // 12345 小结整数运算的结果永远是精确的；运算结果会自动提升；可以强制转型，但超出范围的强制转型会得到错误的结果；应该选择合适范围的整型（int或long），没有必要为了节省内存而使用byte和short进行整数运算。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础_Java程序基础-1.基本数据类型","date":"2020-02-16T13:05:49.195Z","path":"2020/02/16/Java基础_Java程序基础-1/","text":"1.基本数据类型 基本数据类型是CPU可以直接进行运算的类型。Java定义了以下几种基本数据类型：整数类型：byte，short，int，long浮点数类型：float，double字符类型：char布尔类型：boolean 不同的数据类型占用的字节数不一样。我们看一下Java基本数据类型占用的字节数：a表示一个字节 byte │ a │ short │ a │ a │ int │ a │ a │ a │ a │ long │ a │ a │ a │ a │ a │ a │ a │ a │ float │ a │ a │ a │ a │ double │ a │ a │ a │ a │ a │ a │ a │ a │ char │ a │ a │ byte恰好就是一个字节，而long和double需要8个字节。 整型 对于整型类型，Java只定义了带符号的整型，因此，最高位的bit表示符号位（0表示正数，1表示负数）。各种整型能表示的最大范围如下： 1234byte：-128 ~ 127short: -32768 ~ 32767int: -2147483648 ~ 2147483647long: -9223372036854775808 ~ 9223372036854775807 浮点型 浮点类型的数就是小数，因为小数用科学计数法表示的时候，小数点是可以“浮动”的，如1234.5可以表示成12.345x102，也可以表示成1.2345x103，所以称为浮点数。下面是定义浮点数的例子： 12345float f1 = 3.14f;float f2 = 3.14e38f; // 科学计数法表示的3.14x10^38double d = 1.79e308;double d2 = -1.79e308;double d3 = 4.9e-324; // 科学计数法表示的4.9x10^-324 对于float类型，需要加上f后缀。浮点数可表示的范围非常大，float类型可最大表示3.4x1038，而double类型可最大表示1.79x10308。 布尔类型 布尔类型boolean只有true和false两个值，布尔类型总是关系运算的计算结果： 12345boolean b1 = true;boolean b2 = false;boolean isGreater = 5 &gt; 3; // 计算结果为trueint age = 12;boolean isAdult = age &gt;= 18; // 计算结果为false Java语言对布尔类型的存储并没有做规定，因为理论上存储布尔类型只需要1 bit，但是通常JVM内部会把boolean表示为4字节整数。 字符类型 字符类型char表示一个字符。Java的char类型除了可表示标准的ASCII外，还可以表示一个Unicode字符： 注意char类型使用单引号’，且仅有一个字符，要和双引号”的字符串类型区分开。 常量 定义变量的时候，如果加上final修饰符，这个变量就变成了常量： 1234final double PI = 3.14; // PI是一个常量double r = 5.0;double area = PI * r * r;PI = 300; // compile error! 常量在定义时进行初始化后就不可再次赋值，再次赋值会导致编译错误。常量的作用是用有意义的变量名来避免魔术数字（Magic number），例如，不要在代码中到处写3.14，而是定义一个常量。如果将来需要提高计算精度，我们只需要在常量的定义处修改，例如，改成3.1416，而不必在所有地方替换3.14。根据习惯，常量名通常全部大写。 var关键字（java 10 开始使用）有些时候，类型的名字太长，写起来比较麻烦。例如：StringBuilder sb = new StringBuilder(); 这个时候，如果想省略变量类型，可以使用var关键字：var sb = new StringBuilder(); 编译器会根据赋值语句自动推断出变量sb的类型是StringBuilder。对编译器来说，语句：var sb = new StringBuilder(); 实际上会自动变成：StringBuilder sb = new StringBuilder(); 因此，使用var定义变量，仅仅是少写了变量类型而已。 小结Java提供了两种变量类型：基本类型和引用类型基本类型包括整型，浮点型，布尔型，字符型。变量可重新赋值，等号是赋值语句，不是数学意义的等号。常量在初始化后不可重新赋值，使用常量便于理解程序意图。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]}]