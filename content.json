[{"title":"Java面向对象_2.方法","date":"2020-02-18T01:43:53.540Z","path":"2020/02/18/Java面向对象_2/","text":"一个class可以包含多个field，例如，我们给Person类就定义了两个field：class Person { public String name; public int age;} 但是，直接把field用public暴露给外部可能会破坏封装性。比如，代码可以这样写：Person ming = new Person();ming.name = “Xiao Ming”;ming.age = -99; // age设置为负数 显然，直接操作field，容易造成逻辑混乱。为了避免外部代码直接去访问field，我们可以用private修饰field，拒绝外部访问：class Person { private String name; private int age;} 把field从public改成private，外部代码不能访问这些field，那我们定义这些field有什么用？怎么才能给它赋值？怎么才能读取它的值？所以我们需要使用方法（method）来让外部代码可以间接修改field：public class Main { public static void main(String[] args) { Person ming = new Person(); ming.setName(“Xiao Ming”); // 设置name ming.setAge(12); // 设置age System.out.println(ming.getName() + “, “ + ming.getAge()); }} class Person { private String name; private int age; public String getName() { return this.name; } public void setName(String name) { this.name = name; } public int getAge() { return this.age; } public void setAge(int age) { if (age &lt; 0 || age &gt; 100) { throw new IllegalArgumentException(&quot;invalid age value&quot;); } this.age = age; }}虽然外部代码不能直接修改private字段，但是，外部代码可以调用方法setName()和setAge()来间接修改private字段。在方法内部，我们就有机会检查参数对不对。比如，setAge()就会检查传入的参数，参数超出了范围，直接报错。这样，外部代码就没有任何机会把age设置成不合理的值。同样，外部代码不能直接读取private字段，但可以通过getName()和getAge()间接获取private字段的值。所以，一个类通过定义方法，就可以给外部代码暴露一些操作的接口，同时，内部自己保证逻辑一致性。调用方法的语法是实例变量.方法名(参数);。一个方法调用就是一个语句，所以不要忘了在末尾加;。例如：ming.setName(“Xiao Ming”);。 定义方法 从上面的代码可以看出，定义方法的语法是：修饰符 方法返回类型 方法名(方法参数列表) { 若干方法语句; return 方法返回值;} 方法返回值通过return语句实现，如果没有返回值，返回类型设置为void，可以省略return。 private方法 有public方法，自然就有private方法。和private字段一样，private方法不允许外部调用，那我们定义private方法有什么用？定义private方法的理由是内部方法是可以调用private方法的。例如：public class Main { public static void main(String[] args) { Person ming = new Person(); ming.setBirth(2008); System.out.println(ming.getAge()); }} class Person { private String name; private int birth; public void setBirth(int birth) { this.birth = birth; } public int getAge() { return calcAge(2019); // 调用private方法 } // private方法: private int calcAge(int currentYear) { return currentYear - this.birth; }}观察上述代码，calcAge()是一个private方法，外部代码无法调用，但是，内部方法getAge()可以调用它。此外，我们还注意到，这个Person类只定义了birth字段，没有定义age字段，获取age时，通过方法getAge()返回的是一个实时计算的值，并非存储在某个字段的值。这说明方法可以封装一个类的对外接口，调用方不需要知道也不关心Person实例在内部到底有没有age字段。 this变量 在方法内部，可以使用一个隐含的变量this，它始终指向当前实例。因此，通过this.field就可以访问当前实例的字段。如果没有命名冲突，可以省略this。例如：class Person { private String name; public String getName() { return name; // 相当于this.name }} 但是，如果有局部变量和字段重名，那么局部变量优先级更高，就必须加上this：class Person { private String name; public void setName(String name) { this.name = name; // 前面的this不可少，少了就变成局部变量name了 }} 方法参数 方法可以包含0个或任意个参数。方法参数用于接收传递给方法的变量值。调用方法时，必须严格按照参数的定义一一传递。例如：class Person { … public void setNameAndAge(String name, int age) { … }} 调用这个setNameAndAge()方法时，必须有两个参数，且第一个参数必须为String，第二个参数必须为int：Person ming = new Person();ming.setNameAndAge(“Xiao Ming”); // 编译错误：参数个数不对ming.setNameAndAge(12, “Xiao Ming”); // 编译错误：参数类型不对 可变参数 可变参数用类型…定义，可变参数相当于数组类型：class Group { private String[] names; public void setNames(String... names) { this.names = names; }} 上面的setNames()就定义了一个可变参数。调用时，可以这么写：Group g = new Group();g.setNames(“Xiao Ming”, “Xiao Hong”, “Xiao Jun”); // 传入3个Stringg.setNames(“Xiao Ming”, “Xiao Hong”); // 传入2个Stringg.setNames(“Xiao Ming”); // 传入1个Stringg.setNames(); // 传入0个String 参数绑定 调用方把参数传递给实例方法时，调用时传递的值会按参数位置一一绑定。那什么是参数绑定？我们先观察一个基本类型参数的传递：public class Main { public static void main(String[] args) { Person p = new Person(); int n = 15; // n的值为15 p.setAge(n); // 传入n的值 System.out.println(p.getAge()); // 15 n = 20; // n的值改为20 System.out.println(p.getAge()); // 15还是20? }} class Person { private int age; public int getAge() { return this.age; } public void setAge(int age) { this.age = age; }} 运行代码，从结果可知，修改外部的局部变量n，不影响实例p的age字段，原因是setAge()方法获得的参数，复制了n的值，因此，p.age和局部变量n互不影响。结论：基本类型参数的传递，是调用方值的复制。双方各自的后续修改，互不影响。 我们再看一个传递引用参数的例子：public class Main { public static void main(String[] args) { Person p = new Person(); String[] fullname = new String[] { “Homer”, “Simpson” }; p.setName(fullname); // 传入fullname数组 System.out.println(p.getName()); // “Homer Simpson” fullname[0] = “Bart”; // fullname数组的第一个元素修改为”Bart” System.out.println(p.getName()); // “Homer Simpson”还是”Bart Simpson”? }} class Person { private String[] name; public String getName() { return this.name[0] + &quot; &quot; + this.name[1]; } public void setName(String[] name) { this.name = name; }}注意到setName()的参数现在是一个数组。一开始，把fullname数组传进去，然后，修改fullname数组的内容，结果发现，实例p的字段p.name也被修改了！结论：引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方 小结 方法可以让外部代码安全地访问实例字段；方法是一组执行语句，并且可以执行任意逻辑；方法内部遇到return时返回，void表示不返回任何值（注意和返回null不同）；外部代码通过public方法操作实例，内部代码可以调用private方法；理解方法的参数绑定。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java面向对象_1.基础","date":"2020-02-18T00:50:06.074Z","path":"2020/02/18/Java面向对象_1/","text":"面向对象编程，是一种通过对象的方式，把现实世界映射到计算机模型的一种编程方法。现实世界中，我们定义了“人”这种抽象概念，而具体的人则是“小明”、“小红”、“小军”等一个个具体的人。所以，“人”可以定义为一个类（class），而具体的人则是实例（instance）：现实世界 计算机模型 Java代码 人 类 / class class Person { }小明 实例 / ming Person ming = new Person()小红 实例 / hong Person hong = new Person()小军 实例 / jun Person jun = new Person() 定义class 在Java中，创建一个类，例如，给这个类命名为Person，就是定义一个class： 1234class Person &#123; public String name; public int age;&#125; 一个class可以包含多个字段（field），字段用来描述一个类的特征。上面的Person类，我们定义了两个字段，一个是String类型的字段，命名为name，一个是int类型的字段，命名为age。public是用来修饰字段的，它表示这个字段可以被外部访问。 创建实例 定义了class，只是定义了对象模版，而要根据对象模版创建出真正的对象实例，必须用new操作符。new操作符可以创建一个实例，然后，我们需要定义一个引用类型的变量来指向这个实例： Person ming = new Person();上述代码创建了一个Person类型的实例，并通过变量ming指向它。注意区分Person ming是定义Person类型的变量ming，而new Person()是创建Person实例。 有了指向这个实例的变量，我们就可以通过这个变量来操作实例。访问实例变量可以用变量.字段，例如： 1234567ming.name &#x3D; &quot;Xiao Ming&quot;; &#x2F;&#x2F; 对字段name赋值ming.age &#x3D; 12; &#x2F;&#x2F; 对字段age赋值System.out.println(ming.name); &#x2F;&#x2F; 访问字段namePerson hong &#x3D; new Person();hong.name &#x3D; &quot;Xiao Hong&quot;;hong.age &#x3D; 15; 上述两个变量分别指向两个不同的实例，它们在内存中的结构如下： 123456789101112 ┌──────────────────┐ming ──────&gt;│Person instance │ ├──────────────────┤ │name &#x3D; &quot;Xiao Ming&quot;│ │age &#x3D; 12 │ └──────────────────┘ ┌──────────────────┐hong ──────&gt;│Person instance │ ├──────────────────┤ │name &#x3D; &quot;Xiao Hong&quot;│ │age &#x3D; 15 │ └──────────────────┘ 两个instance拥有class定义的name和age字段，且各自都有一份独立的数据，互不干扰。 小结 在OOP中，class和instance是“模版”和“实例”的关系；定义class就是定义了一种数据类型，对应的instance是这种数据类型的实例；class定义的field，在每个instance都会拥有各自的field，且互不干扰；通过new操作符创建新的instance，然后用变量指向它，即可通过变量来引用这个instance；访问实例字段的方法是变量名.字段名；指向instance的变量都是引用变量。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础_数组操作-3.多维数组","date":"2020-02-17T06:48:50.886Z","path":"2020/02/17/Java基础_数组操作-3/","text":"二维数组二维数组就是数组的数组。定义一个二维数组如下： 12345678910public class Main &#123; public static void main(String[] args) &#123; int[][] ns &#x3D; &#123; &#123; 1, 2, 3, 4 &#125;, &#123; 5, 6, 7, 8 &#125;, &#123; 9, 10, 11, 12 &#125; &#125;; System.out.println(ns.length); &#x2F;&#x2F; 3 &#125;&#125; 因为ns包含3个数组，因此，ns.length为3。实际上ns在内存中的结构如下： 123456789 ┌───┬───┬───┬───┐ ┌───┐ ┌──&gt;│ 1 │ 2 │ 3 │ 4 │ns ─────&gt;│░░░│──┘ └───┴───┴───┴───┘ ├───┤ ┌───┬───┬───┬───┐ │░░░│─────&gt;│ 5 │ 6 │ 7 │ 8 │ ├───┤ └───┴───┴───┴───┘ │░░░│──┐ ┌───┬───┬───┬───┐ └───┘ └──&gt;│ 9 │10 │11 │12 │ └───┴───┴───┴───┘ 如果我们定义一个普通数组arr0，然后把ns[0]赋值给它： 1234567891011public class Main &#123; public static void main(String[] args) &#123; int[][] ns &#x3D; &#123; &#123; 1, 2, 3, 4 &#125;, &#123; 5, 6, 7, 8 &#125;, &#123; 9, 10, 11, 12 &#125; &#125;; int[] arr0 &#x3D; ns[0]; System.out.println(arr0.length); &#x2F;&#x2F; 4 &#125;&#125; 实际上arr0就获取了ns数组的第0个元素。因为ns数组的每个元素也是一个数组，因此，arr0指向的数组就是{ 1, 2, 3, 4 }。在内存中，结构如下： 1234567891011 arr0 ─────┐ ▼ ┌───┬───┬───┬───┐ ┌───┐ ┌──&gt;│ 1 │ 2 │ 3 │ 4 │ns ─────&gt;│░░░│──┘ └───┴───┴───┴───┘ ├───┤ ┌───┬───┬───┬───┐ │░░░│─────&gt;│ 5 │ 6 │ 7 │ 8 │ ├───┤ └───┴───┴───┴───┘ │░░░│──┐ ┌───┬───┬───┬───┐ └───┘ └──&gt;│ 9 │10 │11 │12 │ └───┴───┴───┴───┘ 访问二维数组的某个元素需要使用array[row][col]，例如：System.out.println(ns[1][2]); // 7 二维数组的每个数组元素的长度并不要求相同，例如，可以这么定义ns数组： 12345int[][] ns &#x3D; &#123; &#123; 1, 2, 3, 4 &#125;, &#123; 5, 6 &#125;, &#123; 7, 8, 9 &#125;&#125;; 这个二维数组在内存中的结构如下： 123456789 ┌───┬───┬───┬───┐ ┌───┐ ┌──&gt;│ 1 │ 2 │ 3 │ 4 │ns ─────&gt;│░░░│──┘ └───┴───┴───┴───┘ ├───┤ ┌───┬───┐ │░░░│─────&gt;│ 5 │ 6 │ ├───┤ └───┴───┘ │░░░│──┐ ┌───┬───┬───┐ └───┘ └──&gt;│ 7 │ 8 │ 9 │ └───┴───┴───┘ 要打印一个二维数组，可以使用两层嵌套的for循环： 1234567for (int[] arr : ns) &#123; for (int n : arr) &#123; System.out.print(n); System.out.print(&#39;, &#39;); &#125; System.out.println();&#125; 或者使用Java标准库的Arrays.deepToString()： 123456789101112import java.util.Arrays;public class Main &#123; public static void main(String[] args) &#123; int[][] ns &#x3D; &#123; &#123; 1, 2, 3, 4 &#125;, &#123; 5, 6, 7, 8 &#125;, &#123; 9, 10, 11, 12 &#125; &#125;; System.out.println(Arrays.deepToString(ns)); &#125;&#125; 三维数组（基本不使用）三维数组就是二维数组的数组。可以这么定义一个三维数组： 123456789101112131415int[][][] ns &#x3D; &#123; &#123; &#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125; &#125;, &#123; &#123;10, 11&#125;, &#123;12, 13&#125; &#125;, &#123; &#123;14, 15, 16&#125;, &#123;17, 18&#125; &#125;&#125;; 它在内存中的结构如下： 123456789101112131415161718192021 ┌───┬───┬───┐ ┌───┐ ┌──&gt;│ 1 │ 2 │ 3 │ ┌──&gt;│░░░│──┘ └───┴───┴───┘ │ ├───┤ ┌───┬───┬───┐ │ │░░░│─────&gt;│ 4 │ 5 │ 6 │ │ ├───┤ └───┴───┴───┘ │ │░░░│──┐ ┌───┬───┬───┐ ┌───┐ │ └───┘ └──&gt;│ 7 │ 8 │ 9 │ns ────&gt;│░░░│──┘ └───┴───┴───┘ ├───┤ ┌───┐ ┌───┬───┐ │░░░│─────&gt;│░░░│─────&gt;│10 │11 │ ├───┤ ├───┤ └───┴───┘ │░░░│──┐ │░░░│──┐ ┌───┬───┐ └───┘ │ └───┘ └──&gt;│12 │13 │ │ └───┴───┘ │ ┌───┐ ┌───┬───┬───┐ └──&gt;│░░░│─────&gt;│14 │15 │16 │ ├───┤ └───┴───┴───┘ │░░░│──┐ ┌───┬───┐ └───┘ └──&gt;│17 │18 │ └───┴───┘ 如果我们要访问三维数组的某个元素，例如，ns[2][0][1]，只需要顺着定位找到对应的最终元素15即可。理论上，我们可以定义任意的N维数组。但在实际应用中，除了二维数组在某些时候还能用得上，更高维度的数组很少使用。 小结 二维数组就是数组的数组，三维数组就是二维数组的数组；多维数组的每个数组元素长度都不要求相同；打印多维数组可以使用Arrays.deepToString()；最常见的多维数组是二维数组，访问二维数组的一个元素使用array[row][col]。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础_数组操作-2.数组排序","date":"2020-02-17T06:20:24.430Z","path":"2020/02/17/Java基础_数组操作-2/","text":"我们在Java程序基础里介绍了数组这种数据类型。有了数组，我们还需要来操作它。而数组最常见的一个操作就是遍历。 通过for循环就可以遍历数组。因为数组的每个元素都可以通过索引来访问，因此，使用标准的for循环可以完成一个数组的遍历： 123456789public class Main &#123; public static void main(String[] args) &#123; int[] ns &#x3D; &#123; 1, 4, 9, 16, 25 &#125;; for (int i&#x3D;0; i&lt;ns.length; i++) &#123; int n &#x3D; ns[i]; System.out.println(n); &#125; &#125;&#125; 第二种方式是使用for each循环，直接迭代数组的每个元素： 12345678public class Main &#123; public static void main(String[] args) &#123; int[] ns &#x3D; &#123; 1, 4, 9, 16, 25 &#125;; for (int n : ns) &#123; System.out.println(n); &#125; &#125;&#125; 注意：在for (int n : ns)循环中，变量n直接拿到ns数组的元素，而不是索引。显然for each循环更加简洁。但是，for each循环无法拿到数组的索引，因此，到底用哪一种for循环，取决于我们的需要。 打印数组内容 直接打印数组变量，得到的是数组在JVM中的引用地址： 12int[] ns &#x3D; &#123; 1, 1, 2, 3, 5, 8 &#125;;System.out.println(ns); &#x2F;&#x2F; 类似 [I@7852e922 所以为了得到数组的具体内容，使用for each循环来打印它： 1234int[] ns &#x3D; &#123; 1, 1, 2, 3, 5, 8 &#125;;for (int n : ns) &#123; System.out.print(n + &quot;, &quot;);&#125; 使用for each循环打印也很麻烦。幸好Java标准库提供了Arrays.toString()，可以快速打印数组内容：import java.util.Arrays; 123456public class Main &#123; public static void main(String[] args) &#123; int[] ns &#x3D; &#123; 1, 1, 2, 3, 5, 8 &#125;; System.out.println(Arrays.toString(ns)); &#125;&#125; 小结遍历数组可以使用for循环，for循环可以访问数组索引，for each循环直接迭代每个数组元素，但无法获取索引；使用Arrays.toString()可以快速获取数组内容。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础_数组操作-1.遍历数组","date":"2020-02-17T06:16:38.761Z","path":"2020/02/17/Java基础_数组操作-1/","text":"我们在Java程序基础里介绍了数组这种数据类型。有了数组，我们还需要来操作它。而数组最常见的一个操作就是遍历。 通过for循环就可以遍历数组。因为数组的每个元素都可以通过索引来访问，因此，使用标准的for循环可以完成一个数组的遍历： 123456789public class Main &#123; public static void main(String[] args) &#123; int[] ns &#x3D; &#123; 1, 4, 9, 16, 25 &#125;; for (int i&#x3D;0; i&lt;ns.length; i++) &#123; int n &#x3D; ns[i]; System.out.println(n); &#125; &#125;&#125; 第二种方式是使用for each循环，直接迭代数组的每个元素： 12345678public class Main &#123; public static void main(String[] args) &#123; int[] ns &#x3D; &#123; 1, 4, 9, 16, 25 &#125;; for (int n : ns) &#123; System.out.println(n); &#125; &#125;&#125; 注意：在for (int n : ns)循环中，变量n直接拿到ns数组的元素，而不是索引。显然for each循环更加简洁。但是，for each循环无法拿到数组的索引，因此，到底用哪一种for循环，取决于我们的需要。 打印数组内容 直接打印数组变量，得到的是数组在JVM中的引用地址： 12int[] ns &#x3D; &#123; 1, 1, 2, 3, 5, 8 &#125;;System.out.println(ns); &#x2F;&#x2F; 类似 [I@7852e922 所以为了得到数组的具体内容，使用for each循环来打印它： 1234int[] ns &#x3D; &#123; 1, 1, 2, 3, 5, 8 &#125;;for (int n : ns) &#123; System.out.print(n + &quot;, &quot;);&#125; 使用for each循环打印也很麻烦。幸好Java标准库提供了Arrays.toString()，可以快速打印数组内容： 12345678import java.util.Arrays;public class Main &#123; public static void main(String[] args) &#123; int[] ns &#x3D; &#123; 1, 1, 2, 3, 5, 8 &#125;; System.out.println(Arrays.toString(ns)); &#125;&#125; 小结遍历数组可以使用for循环，for循环可以访问数组索引，for each循环直接迭代每个数组元素，但无法获取索引；使用Arrays.toString()可以快速获取数组内容。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础_流程控制-6.break和continue","date":"2020-02-17T06:14:34.758Z","path":"2020/02/17/Java基础_流程控制-6/","text":"无论是while循环还是for循环，有两个特别的语句可以使用，就是break语句和continue语句。break在循环过程中，可以使用break语句跳出当前循环。我们来看一个例子： 123456789101112public class Main &#123; public static void main(String[] args) &#123; int sum &#x3D; 0; for (int i&#x3D;1; ; i++) &#123; sum &#x3D; sum + i; if (i &#x3D;&#x3D; 100) &#123; break; &#125; &#125; System.out.println(sum); &#125;&#125; 使用for循环计算从1到100时，我们并没有在for()中设置循环退出的检测条件。但是，在循环内部，我们用if判断，如果i==100，就通过break退出循环。注意：break跳出的是自己的那一层循环，并不会结束上层循环 continuebreak会跳出当前循环，也就是整个循环都不会执行了。而continue则是提前结束本次循环，直接继续执行下次循环。我们看一个例子： 1234567891011121314public class Main &#123; public static void main(String[] args) &#123; int sum &#x3D; 0; for (int i&#x3D;1; i&lt;&#x3D;10; i++) &#123; System.out.println(&quot;begin i &#x3D; &quot; + i); if (i % 2 &#x3D;&#x3D; 0) &#123; continue; &#x2F;&#x2F; continue语句会结束本次循环 &#125; sum &#x3D; sum + i; System.out.println(&quot;end i &#x3D; &quot; + i); &#125; System.out.println(sum); &#x2F;&#x2F; 25 &#125;&#125; 在多层嵌套的循环中，continue语句同样是结束本次自己所在的循环。 小结 break语句可以跳出当前循环；break语句通常配合if，在满足条件时提前结束整个循环；break语句总是跳出最近的一层循环；continue语句可以提前结束本次循环；continue语句通常配合if，在满足条件时提前结束本次循环。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础_流程控制-5.for循环","date":"2020-02-17T06:12:37.739Z","path":"2020/02/17/Java基础_流程控制-5/","text":"除了while和do while循环，Java使用最广泛的是for循环。for循环的功能非常强大，它使用计数器实现循环。for循环会先初始化计数器，然后，在每次循环前检测循环条件，在每次循环后更新计数器。计数器变量通常命名为i。 我们把1到100求和用for循环改写一下： 123456789public class Main &#123; public static void main(String[] args) &#123; int sum &#x3D; 0; for (int i&#x3D;1; i&lt;&#x3D;100; i++) &#123; sum &#x3D; sum + i; &#125; System.out.println(sum); &#125;&#125; 在for循环执行前，会先执行初始化语句int i=1，它定义了计数器变量i并赋初始值为1，然后，循环前先检查循环条件i&lt;=100，循环后自动执行i++，因此，和while循环相比，for循环把更新计数器的代码统一放到了一起。在for循环的循环体内部，不需要去更新变量i。for循环的结构是： 123for (初始条件; 循环检测条件; 循环后更新计数器) &#123; &#x2F;&#x2F; 执行语句&#125; 如果要计算一个整型数组各个元素的和，可以使用for循环实现： 1234567891011public class Main &#123; public static void main(String[] args) &#123; int[] ns &#x3D; &#123; 1, 4, 9, 16, 25 &#125;; int sum &#x3D; 0; for (int i&#x3D;0; i&lt;ns.length; i++) &#123; System.out.println(&quot;i &#x3D; &quot; + i + &quot;, ns[i] &#x3D; &quot; + ns[i]); sum &#x3D; sum + ns[i]; &#125; System.out.println(&quot;sum &#x3D; &quot; + sum); &#125;&#125; for each循环 for循环经常用来遍历数组，因为通过计数器可以根据索引来访问数组的每个元素： 1234int[] ns &#x3D; &#123; 1, 4, 9, 16, 25 &#125;;for (int i&#x3D;0; i&lt;ns.length; i++) &#123; System.out.println(ns[i]);&#125; Java还提供了另一种for each循环，它可以更简单地遍历数组： 12345678public class Main &#123; public static void main(String[] args) &#123; int[] ns &#x3D; &#123; 1, 4, 9, 16, 25 &#125;; for (int n : ns) &#123; System.out.println(n); &#125; &#125;&#125; 和for循环相比，for each循环的变量n不再是计数器，而是直接对应到数组的每个元素。for each循环的写法也更简洁。但是，for each循环无法指定遍历顺序，也无法获取数组的索引。除了数组外，for each循环能够遍历所有“可迭代”的数据类型，包括List、Map等。 小结 for循环通过计数器可以实现复杂循环；for each循环可以直接遍历数组的每个元素；最佳实践：计数器变量定义在for循环内部，循环体内部不修改计数器；","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础_流程控制-4.while循环","date":"2020-02-17T06:11:28.335Z","path":"2020/02/17/Java基础_流程控制-4/","text":"循环语句就是让计算机根据条件做循环计算，在条件满足时继续循环，条件不满足时退出循环。例如，计算从1到100的和：1 + 2 + 3 + 4 + … + 100 = ? while循环在每次循环开始前，首先判断条件是否成立。如果计算结果为true，就把循环体内的语句执行一遍，如果计算结果为false，那就直接跳到while循环的末尾，继续往下执行。求1到100的和可以用如下代码实现： 1234567891011public class Main &#123; public static void main(String[] args) &#123; int sum &#x3D; 0; &#x2F;&#x2F; 累加的和，初始化为0 int n &#x3D; 1; while (n &lt;&#x3D; 100) &#123; &#x2F;&#x2F; 循环条件是n &lt;&#x3D; 100 sum &#x3D; sum + n; &#x2F;&#x2F; 把n累加到sum中 n ++; &#x2F;&#x2F; n自身加1 &#125; System.out.println(sum); &#x2F;&#x2F; 5050 &#125;&#125; 注意：while循环是先判断循环条件，再循环，因此，有可能一次循环都不做。所以，在写循环条件的时候要避免死循环。 小结 while循环先判断循环条件是否满足，再执行循环语句；while循环可能一次都不执行；编写循环时要注意循环条件，并避免死循环。 do while循环 在Java中，while循环是先判断循环条件，再执行循环。而另一种do while循环则是先执行循环，再判断条件，条件满足时继续循环，条件不满足时退出。 123do &#123; 执行循环语句&#125; while (条件表达式); 可见，do while循环会至少循环一次。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础_流程控制-3.switch多重选择","date":"2020-02-17T06:10:02.512Z","path":"2020/02/17/Java基础_流程控制-3/","text":"除了if语句外，还有一种条件判断switch，是根据某个表达式的结果，分别去执行不同的分支。例如，在游戏中，让用户选择选项：单人模式多人模式退出游戏 这时，switch语句就派上用场了。switch语句根据switch (表达式)计算的结果，跳转到匹配的case结果，然后继续执行后续语句，直到遇到break结束执行。例子： 12345678910111213141516171819public class Main &#123; public static void main(String[] args) &#123; int option &#x3D; 1; switch (option) &#123; case 1: System.out.println(&quot;Selected 1&quot;); break; case 2: System.out.println(&quot;Selected 2&quot;); break; case 3: System.out.println(&quot;Selected 3&quot;); break; default: System.out.println(&quot;Not selected&quot;); break; &#125; &#125;&#125; 如果option的值没有匹配到任何case，例如option = 99，那么，switch语句不会执行任何语句。这时，可以给switch语句加一个default，当没有匹配到任何case时，执行default： 使用switch时，注意case语句并没有花括号{}，而且，case语句具有“穿透性”，如果没有break；会导致继续执行下面的case导致形成意想不到的结果。 switch语句还可以匹配字符串。字符串匹配时，是比较“内容相等”。例如： 12345678910111213141516171819public class Main &#123; public static void main(String[] args) &#123; String fruit &#x3D; &quot;apple&quot;; switch (fruit) &#123; case &quot;apple&quot;: System.out.println(&quot;Selected apple&quot;); break; case &quot;pear&quot;: System.out.println(&quot;Selected pear&quot;); break; case &quot;mango&quot;: System.out.println(&quot;Selected mango&quot;); break; default: System.out.println(&quot;No fruit selected&quot;); break; &#125; &#125;&#125; yield大多数时候，在switch表达式内部，我们会返回简单的值。但是，如果需要复杂的语句，我们也可以写很多语句，放到{…}里，然后，用yield返回一个值作为switch语句的返回值： 1234567891011121314public class Main &#123; public static void main(String[] args) &#123; String fruit &#x3D; &quot;orange&quot;; int opt &#x3D; switch (fruit) &#123; case &quot;apple&quot; -&gt; 1; case &quot;pear&quot;, &quot;mango&quot; -&gt; 2; default -&gt; &#123; int code &#x3D; fruit.hashCode(); yield code; &#x2F;&#x2F; switch语句返回值 &#125; &#125;; System.out.println(&quot;opt &#x3D; &quot; + opt); &#125;&#125; 小结switch语句可以做多重选择，然后执行匹配的case语句后续代码；switch的计算结果必须是整型、字符串或枚举类型；注意千万不要漏写break，建议打开fall-through警告；总是写上default，建议打开missing default警告；从Java 13开始，switch语句升级为表达式，不再需要break，并且允许使用yield返回值。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础_流程控制-2.if判断","date":"2020-02-17T06:08:41.296Z","path":"2020/02/17/Java基础_流程控制-2/","text":"在Java中，如果要根据一个条件来判断是否执行某一语句块时，要用到if语句。 if语句的基本语法 123if (条件) &#123; &#x2F;&#x2F; 条件满足时执行&#125; 根据if的计算结果（true还是false），决定是否执行if语句块（即花括号{}包含的所有语句） 例子： 123456789public class Main &#123; public static void main(String[] args) &#123; int n &#x3D; 70; if (n &gt;&#x3D; 60) &#123; System.out.println(&quot;及格了&quot;); &#125; System.out.println(&quot;END&quot;); &#125;&#125; 当条件n &gt;= 60计算结果为true时，if语句块被执行，将打印”及格了”，否则，if语句块将被跳过。修改n的值可以看到执行效果。{}内可以包含多条语句，不止是及格了一条，但是如果只有一条语句的时候，可以省略{} else if语句还可以编写一个else { … }，当条件判断为false时，将执行else的语句块例子： 1234567891011public class Main &#123; public static void main(String[] args) &#123; int n &#x3D; 70; if (n &gt;&#x3D; 60) &#123; System.out.println(&quot;及格了&quot;); &#125; else &#123; System.out.println(&quot;挂科了&quot;); &#125; System.out.println(&quot;END&quot;); &#125;&#125; 修改上述代码n的值，观察if条件为true或false时，程序执行的语句块。else不是必须的。 还可以用多个if … else if … 12345678910111213public class Main &#123; public static void main(String[] args) &#123; int n &#x3D; 70; if (n &gt;&#x3D; 90) &#123; System.out.println(&quot;优秀&quot;); &#125; else if (n &gt;&#x3D; 60) &#123; System.out.println(&quot;及格了&quot;); &#125; else &#123; System.out.println(&quot;挂科了&quot;); &#125; System.out.println(&quot;END&quot;); &#125;&#125; 在串联使用多个if时，要特别注意判断顺序。正确的方式是按照判断范围从大到小依次判断。使用if时，还要特别注意边界条件。 前面讲过了浮点数在计算机中常常无法精确表示，并且计算可能出现误差，因此，判断浮点数相等用==判断不靠谱以下代码是错误的 12345678910public class Main &#123; public static void main(String[] args) &#123; double x &#x3D; 1 - 9.0 &#x2F; 10; if (x &#x3D;&#x3D; 0.1) &#123; System.out.println(&quot;x is 0.1&quot;); &#125; else &#123; System.out.println(&quot;x is NOT 0.1&quot;); &#125; &#125;&#125; 正确的方法是利用差值小于某个临界值来判断： 12345678910public class Main &#123; public static void main(String[] args) &#123; double x &#x3D; 1 - 9.0 &#x2F; 10; if (Math.abs(x - 0.1) &lt; 0.00001) &#123; System.out.println(&quot;x is 0.1&quot;); &#125; else &#123; System.out.println(&quot;x is NOT 0.1&quot;); &#125; &#125;&#125; 判断引用类型相等 在Java中，判断值类型的变量是否相等，可以使用==运算符。但是，判断引用类型的变量是否相等，==表示“引用是否相等”，或者说，是否指向同一个对象。例如，下面的两个String类型，它们的内容是相同的，但是，分别指向不同的对象，用==判断，结果为false： 12345678910111213public class Main &#123; public static void main(String[] args) &#123; String s1 &#x3D; &quot;hello&quot;; String s2 &#x3D; &quot;HELLO&quot;.toLowerCase(); System.out.println(s1); System.out.println(s2); if (s1 &#x3D;&#x3D; s2) &#123; System.out.println(&quot;s1 &#x3D;&#x3D; s2&quot;); &#125; else &#123; System.out.println(&quot;s1 !&#x3D; s2&quot;); &#125; &#125;&#125; 输出：s1 != s2 要判断引用类型的变量内容是否相等，必须使用equals()方法： 1234567891011121314public class Main &#123; public static void main(String[] args) &#123; String s1 &#x3D; &quot;hello&quot;; String s2 &#x3D; &quot;HELLO&quot;.toLowerCase(); System.out.println(s1); System.out.println(s2); if (s1.equals(s2)) &#123; System.out.println(&quot;s1 equals s2&quot;); &#125; else &#123; System.out.println(&quot;s1 not equals s2&quot;); &#125; &#125;&#125;输出：s1 equals s2 注意：执行语句s1.equals(s2)时，如果变量s1为null，会报空指针异常NullPointerException： 12345678public class Main &#123; public static void main(String[] args) &#123; String s1 &#x3D; null; if (s1.equals(&quot;hello&quot;)) &#123; System.out.println(&quot;hello&quot;); &#125; &#125;&#125; 如果要处理NullPointerException，可以使用短路运算符&amp;&amp; 123456789public class Main &#123; public static void main(String[] args) &#123; String s1 &#x3D; null; if (s1 !&#x3D; null &amp;&amp; s1.equals(&quot;hello&quot;)) &#123; System.out.println(&quot;hello&quot;); &#125; &#125;&#125;还可以把一定不是null的对象&quot;hello&quot;放到前面：例如：if (&quot;hello&quot;.equals(s)) &#123; ... &#125;。 小结if … else可以做条件判断，else是可选的；不推荐省略花括号{}；多个if … else串联要特别注意判断顺序；要注意if的边界条件；要注意浮点数判断相等不能直接用==运算符；引用类型判断内容相等要使用equals()，注意避免空指针异常NullPointerException。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础_流程控制-1.输入与输出","date":"2020-02-17T05:22:02.614Z","path":"2020/02/17/Java基础_流程控制-1/","text":"输出在前面的代码中，我们总是使用System.out.println()来向屏幕输出一些内容。println是print line的缩写，表示输出并换行。因此，如果输出后不想换行，可以用print() 格式化输出如果要把数据显示成我们期望的格式，就需要使用格式化输出的功能。格式化输出使用System.out.printf()，通过使用占位符%?，printf()可以把后面的参数格式化成指定格式： 1234567public class Main &#123; public static void main(String[] args) &#123; double d &#x3D; 3.1415926; System.out.printf(&quot;%.2f\\n&quot;, d); &#x2F;&#x2F; 显示两位小数3.14 System.out.printf(&quot;%.4f\\n&quot;, d); &#x2F;&#x2F; 显示4位小数3.1416 &#125;&#125; 以下是Java中的多种占位符： 占位符 说明%d 格式化输出整数%x 格式化输出十六进制整数%f 格式化输出浮点数%e 格式化输出科学计数法表示的浮点数%s 格式化字符串 由于%表示占位符，因此，连续两个%%表示一个%字符本身（占位符本身还有更详细的格式化参数，这里就不再赘述） 输入和输出相比，Java的输入就要复杂得多。 123456789101112import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner scanner &#x3D; new Scanner(System.in); &#x2F;&#x2F; 创建Scanner对象 System.out.print(&quot;Input your name: &quot;); &#x2F;&#x2F; 打印提示 String name &#x3D; scanner.nextLine(); &#x2F;&#x2F; 读取一行输入并获取字符串 System.out.print(&quot;Input your age: &quot;); &#x2F;&#x2F; 打印提示 int age &#x3D; scanner.nextInt(); &#x2F;&#x2F; 读取一行输入并获取整数 System.out.printf(&quot;Hi, %s, you are %d\\n&quot;, name, age); &#x2F;&#x2F; 格式化输出 &#125;&#125; 首先，我们通过import语句导入java.util.Scanner，import是导入某个类的语句，必须放到Java源代码的开头，后面我们在Java的package中会详细讲解如何使用import。然后，创建Scanner对象并传入System.in。System.out代表标准输出流，而System.in代表标准输入流。直接使用System.in读取用户输入虽然是可以的，但需要更复杂的代码，而通过Scanner就可以简化后续的代码。有了Scanner对象后，要读取用户输入的字符串，使用scanner.nextLine()，要读取用户输入的整数，使用scanner.nextInt()。Scanner会自动转换数据类型，因此不必手动转换。 小结Java提供的输出包括：System.out.println() / print() / printf()，其中printf()可以格式化输出；Java提供Scanner对象来方便输入，读取对应的类型可以使用：scanner.nextLine() / nextInt() / nextDouble() /","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础_Java程序基础-6.数组类型","date":"2020-02-17T05:18:20.968Z","path":"2020/02/17/Java基础_Java程序基础-6/","text":"如果有一组类型相同的变量，例如，5位同学的成绩，可以这么写：public class Main { public static void main(String[] args) { // 5位同学的成绩: int n1 = 68; int n2 = 79; int n3 = 91; int n4 = 85; int n5 = 62; }} 但其实没有必要定义5个int变量。可以使用数组来表示“一组”int类型定义一个数组类型的变量，使用数组类型“类型[]”，例如，int[]。和单个基本类型变量不同，数组变量初始化必须使用new int[5]表示创建一个可容纳5个int元素的数组。int[] arr = new int[5];Java的数组有几个特点：数组所有元素初始化为默认值，整型都是0，浮点型是0.0，布尔型是false；数组一旦创建后，大小就不可改变。要访问数组中的某一个元素，需要使用索引。数组索引从0开始，例如，5个元素的数组，索引范围是0~4。可以修改数组中的某一个元素，使用赋值语句，例如，ns[1] = 79;。可以用数组变量.length获取数组大小（长度）（数组是引用类型，在使用索引访问数组元素时，如果索引超出范围，运行时将报错） 也可以在定义数组时直接指定初始化的元素，这样就不必写出数组大小，而是由编译器自动推算数组大小例如：public class Main { public static void main(String[] args) { // 5位同学的成绩: int[] ns = new int[] { 68, 79, 91, 85, 62 }; System.out.println(ns.length); // 编译器自动推算数组大小为5 }}还可以简写成：int[] ns = { 68, 79, 91, 85, 62 }; 注意数组是引用类型，并且数组大小不可变。例如：定义了一个数组ns = new int[] { 68, 79, 91, 85, 62 };然后再修改他的长度ns = new int[] { 1, 2, 3 }; 数组大小看上去变了，其实没有改变对于数组ns来说，执行ns = new int[] { 68, 79, 91, 85, 62 };时，它指向一个5个元素的数组： ns │ ▼┌───┬───┬───┬───┬───┬───┬───┐│ │68 │79 │91 │85 │62 │ │└───┴───┴───┴───┴───┴───┴───┘执行ns = new int[] { 1, 2, 3 };时，它指向一个新的3个元素的数组： ns ──────────────────────┐ │ ▼┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐│ │68 │79 │91 │85 │62 │ │ 1 │ 2 │ 3 │ │└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘ 但是，原有的5个元素的数组并没有改变，只是无法通过变量ns引用到它们而已。 字符串数组如果数组元素不是基本类型，而是一个引用类型，那么，修改数组元素会有哪些不同？字符串是引用类型，因此我们先定义一个字符串数组：String[] names = { “ABC”, “XYZ”, “zoo”}; 对于String[]类型的数组变量names，它实际上包含3个元素，但每个元素都指向某个字符串对象： ┌─────────────────────────┐ names │ ┌─────────────────────┼───────────┐ │ │ │ │ │ ▼ │ │ ▼ ▼┌───┬───┬─┴─┬─┴─┬───┬───────┬───┬───────┬───┬───────┬───┐│ │░░░│░░░│░░░│ │ “ABC” │ │ “XYZ” │ │ “zoo” │ │└───┴─┬─┴───┴───┴───┴───────┴───┴───────┴───┴───────┴───┘ │ ▲ └─────────────────┘ 对names[1]进行赋值，例如names[1] = “cat”;，效果如下： ┌─────────────────────────────────────────────────┐ names │ ┌─────────────────────────────────┐ │ │ │ │ │ │ ▼ │ │ ▼ ▼┌───┬───┬─┴─┬─┴─┬───┬───────┬───┬───────┬───┬───────┬───┬───────┬───┐│ │░░░│░░░│░░░│ │ “ABC” │ │ “XYZ” │ │ “zoo” │ │ “cat” │ │└───┴─┬─┴───┴───┴───┴───────┴───┴───────┴───┴───────┴───┴───────┴───┘ │ ▲ └─────────────────┘ 这里注意到原来names[1]指向的字符串”XYZ”并没有改变，仅仅是将names[1]的引用从指向”XYZ”改成了指向”cat”，其结果是字符串”XYZ”再也无法通过names[1]访问到了。 小结数组是同一数据类型的集合，数组一旦创建后，大小就不可变；可以通过索引访问数组元素，但索引超出范围将报错；数组元素可以是值类型（如int）或引用类型（如String），但数组本身是引用类型；","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础_Java程序基础-5.字符和字符串","date":"2020-02-17T03:13:49.096Z","path":"2020/02/17/Java基础_Java程序基础-5/","text":"字符类型字符类型char是基本数据类型，它是character的缩写。一个char保存一个Unicode字符：char c1 = ‘A’;char c2 = ‘中’; 因为Java在内存中总是使用Unicode表示字符，所以，一个英文字符和一个中文字符都用一个char类型表示，它们都占用两个字节。要显示一个字符的Unicode编码，只需将char类型直接赋值给int类型即可：int n1 = ‘A’; // 字母“A”的Unicodde编码是65int n2 = ‘中’; // 汉字“中”的Unicode编码是20013 还可以直接用转义字符\\u+Unicode编码来表示一个字符：// 注意是十六进制:char c3 = ‘\\u0041’; // ‘A’，因为十六进制0041 = 十进制65char c4 = ‘\\u4e2d’; // ‘中’，因为十六进制4e2d = 十进制20013 字符串类型和char类型不同，字符串类型String是引用类型，我们用双引号”…”表示字符串。一个字符串可以存储0个到任意个字符：String s = “”; // 空字符串，包含0个字符String s1 = “A”; // 包含一个字符String s2 = “ABC”; // 包含3个字符String s3 = “中文 ABC”; // 包含6个字符，其中有一个空格 因为字符串使用双引号”…”表示开始和结束，那如果字符串本身恰好包含一个”字符怎么表示？例如，”abc”xyz”，编译器就无法判断中间的引号究竟是字符串的一部分还是表示字符串结束。这个时候，我们需要借助转义字符\\：String s = “abc&quot;xyz”; // 包含7个字符: a, b, c, “, x, y, z 因为\\是转义字符，所以，两个\\表示一个\\字符：String s = “abc\\xyz”; // 包含7个字符: a, b, c, , x, y, z 常见的转义字符包括：&quot; 表示字符”&#39; 表示字符’\\ 表示字符\\n 表示换行符\\r 表示回车符\\t 表示Tab\\u#### 表示一个Unicode编码的字符 字符串连接Java的编译器对字符串做了特殊照顾，可以使用+连接任意字符串和其他数据类型，这样极大地方便了字符串的处理。例如：public class Main { public static void main(String[] args) { String s1 = “Hello”; String s2 = “world”; String s = s1 + “ “ + s2 + “!”; System.out.println(s); }}注：如果用+连接字符串和其他数据类型，会将其他数据类型先自动转型为字符串 多行字符串如果我们要表示多行字符串，使用+号连接会非常不方便：String s = “first line \\n” + “second line \\n” + “end”; 从Java 13开始，字符串可以用”””…”””表示多行字符串（Text Blocks）了。举个例子：public class Main { public static void main(String[] args) { String s = “”” SELECT * FROM users WHERE id &gt; 100 ORDER BY name DESC “””; System.out.println(s); }}上述多行字符串实际上是5行，在最后一个DESC后面还有一个\\n。如果我们不想在字符串末尾加一个\\n，就需要这么写：String s = “”” SELECT * FROM users WHERE id &gt; 100 ORDER BY name DESC”””; 不可变特性Java的字符串除了是一个引用类型外，还有个重要特点，就是字符串不可变。考察以下代码：public class Main { public static void main(String[] args) { String s = “hello”; System.out.println(s); // 显示 hello s = “world”; System.out.println(s); // 显示 world }} 观察执行结果，难道字符串s变了吗？其实变的不是字符串，而是变量s的“指向”。执行String s = “hello”;时，JVM虚拟机先创建字符串”hello”，然后，把字符串变量s指向它： s │ ▼┌───┬───────────┬───┐│ │ “hello” │ │└───┴───────────┴───┘ 紧接着，执行s = “world”;时，JVM虚拟机先创建字符串”world”，然后，把字符串变量s指向它： s ──────────────┐ │ ▼┌───┬───────────┬───┬───────────┬───┐│ │ “hello” │ │ “world” │ │└───┴───────────┴───┴───────────┴───┘ 原来的字符串”hello”还在，只是我们无法通过变量s访问它而已。因此，字符串的不可变是指字符串内容不可变。理解了引用类型的“指向”后，试解释下面的代码输出public class Main { public static void main(String[] args) { String s = “hello”; String t = s; s = “world”; System.out.println(t); // t是”hello”还是”world”? }}输出：hello 空值null引用类型的变量可以指向一个空值null，它表示不存在，即该变量不指向任何对象。例如：String s1 = null; // s1是nullString s2; // 没有赋初值值，s2也是nullString s3 = s1; // s3也是nullString s4 = “”; // s4指向空字符串，不是null 注意要区分空值null和空字符串””，空字符串是一个有效的字符串对象，它不等于null。 小结Java的字符类型char是基本类型，字符串类型String是引用类型；基本类型的变量是“持有”某个数值，引用类型的变量是“指向”某个对象；引用类型的变量可以是空值null；要区分空值null和空字符串””。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础_Java程序基础-4.布尔运算","date":"2020-02-17T02:39:08.045Z","path":"2020/02/17/Java基础_Java程序基础-4/","text":"对于布尔类型boolean，永远只有true和false两个值。布尔运算是一种关系运算，包括以下几类：比较运算符：&gt;，&gt;=，&lt;，&lt;=，==，!=与运算 &amp;&amp;或运算 ||非运算 !下面是一些示例：boolean isGreater = 5 &gt; 3; // trueint age = 12;boolean isZero = age == 0; // falseboolean isNonZero = !isZero; // trueboolean isAdult = age &gt;= 18; // falseboolean isTeenager = age &gt;6 &amp;&amp; age &lt;18; // true 关系运算符的优先级从高到低依次是：!&gt;，&gt;=，&lt;，&lt;===，!=&amp;&amp;|| 短路运算布尔运算的一个重要特点是短路运算。如果一个布尔运算的表达式能提前确定结果，则后续的计算不再执行，直接返回结果。因为false &amp;&amp; x的结果总是false，无论x是true还是false，因此，与运算在确定第一个值为false后，不再继续计算，而是直接返回false。public class Main { public static void main(String[] args) { boolean b = 5 &lt; 3; boolean result = b &amp;&amp; (5 / 0 &gt; 0); System.out.println(result); }}如果没有短路运算，&amp;&amp;后面的表达式会由于除数为0而报错，但实际上该语句并未报错，原因在于与运算是短路运算符，提前计算出了结果false。如果变量b的值为true，则表达式变为true &amp;&amp; (5 / 0 &gt; 0)。因为无法进行短路运算，该表达式必定会由于除数为0而报错，可以自行测试。类似的，对于||运算，只要能确定第一个值为true，后续计算也不再进行，而是直接返回true 三元运算符Java还提供一个三元运算符b ? x : y，它根据第一个布尔表达式的结果，分别返回后续两个表达式之一的计算结果。注意到三元运算b ? x : y会首先计算b，如果b为true，则只计算x，否则，只计算y。此外，x和y的类型必须相同，因为返回值不是boolean，而是x和y之一。 小结与运算和或运算是短路运算；三元运算b ? x : y后面的类型必须相同，三元运算也是“短路运算”，只计算x或y。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础_Java程序基础-3.浮点数运算","date":"2020-02-17T02:34:31.525Z","path":"2020/02/17/Java基础_Java程序基础-3/","text":"浮点数运算和整数运算相比，只能进行加减乘除这些数值计算，不能做位运算和移位运算。在计算机中，浮点数虽然表示的范围大，但是，浮点数有个非常重要的特点，就是浮点数常常无法精确表示。 浮点数0.1在计算机中就无法精确表示，因为十进制的0.1换算成二进制是一个无限循环小数，很显然，无论使用float还是double，都只能存储一个0.1的近似值。但是，0.5这个浮点数又可以精确地表示。因为浮点数常常无法精确表示，因此，浮点数运算会产生误差：public class Main { public static void main(String[] args) { double x = 1.0 / 10; double y = 1 - 9.0 / 10; // 观察x和y是否相等: System.out.println(x); System.out.println(y); }} 结果：0.10.09999999999999998 浮点数的比较由于浮点数存在运算误差，所以比较两个浮点数是否相等常常会出现错误的结果。正确的比较方法是判断两个浮点数之差的绝对值是否小于一个很小的数：// 比较x和y是否相等，先计算其差的绝对值:double r = Math.abs(x - y);// 再判断绝对值是否足够小:if (r &lt; 0.00001) { // 可以认为相等} else { // 不相等} 浮点数在内存的表示方法和整数比更加复杂。Java的浮点数完全遵循IEEE-754标准，这也是绝大多数计算机平台都支持的浮点数标准表示方法。 溢出整数运算在除数为0时会报错，而浮点数运算在除数为0时，不会报错，但会返回几个特殊值：NaN表示Not a NumberInfinity表示无穷大-Infinity表示负无穷大例如：double d1 = 0.0 / 0; // NaNdouble d2 = 1.0 / 0; // Infinitydouble d3 = -1.0 / 0; // -Infinity 这三种特殊值在实际运算中很少碰到，我们只需要了解即可。 强制转型可以将浮点数强制转型为整数。在转型时，浮点数的小数部分会被丢掉。如果转型后超过了整型能表示的最大范围，将返回整型的最大值。例如：int n1 = (int) 12.3; // 12int n2 = (int) 12.7; // 12int n2 = (int) -12.7; // -12int n3 = (int) (12.7 + 0.5); // 13int n4 = (int) 1.2e20; // 2147483647 如果要进行四舍五入，可以对浮点数加上0.5再强制转型：public class Main { public static void main(String[] args) { double d = 2.6; int n = (int) (d + 0.5); System.out.println(n); }} 小结浮点数常常无法精确表示，并且浮点数的运算结果可能有误差；比较两个浮点数通常比较它们的绝对值之差是否小于一个特定值；整型和浮点型运算时，整型会自动提升为浮点型；可以将浮点型强制转为整型，但超出范围后将始终返回整型的最大值。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础_Java程序基础-2.整数运算","date":"2020-02-16T14:32:24.877Z","path":"2020/02/16/Java基础_Java程序基础-2/","text":"2.整数运算Java的整数运算遵循四则运算规则，可以使用任意嵌套的小括号。四则运算规则和初等数学一致。 整数的数值表示不但是精确的，而且整数运算永远是精确的，即使是除法也是精确的，因为两个整数相除只能得到结果的整数部分：int x = 12345 / 67; // 184 求余运算使用%：int y = 12345 % 67; // 12345÷67的余数是17 特别注意：整数的除法对于除数为0时运行时将报错，但编译不会报错。 溢出要特别注意，整数由于存在范围限制，如果计算结果超出了范围，就会产生溢出，而溢出不会出错，却会得到一个奇怪的结果 要解决上面的问题，可以把int换成long类型，由于long可表示的整型范围更大，所以结果就不会溢出：long x = 2147483640;long y = 15;long sum = x + y;System.out.println(sum); // 2147483655 还有一种简写的运算符，即+=，-=，*=，/=，它们的使用方法如下：n += 100; // 3409, 相当于 n = n + 100;n -= 100; // 3309, 相当于 n = n - 100; 自增/自减Java还提供了++运算和–运算，它们可以对一个整数进行加1和减1的操作：// 自增/自减运算 注意++写在前面和后面计算结果是不同的，++n表示先加1再引用n，n++表示先引用n再加1。不建议把++运算混入到常规运算中，容易自己把自己搞懵了。 移位运算在计算机中，整数总是以二进制的形式表示。例如，int类型的整数7使用4字节表示的二进制如下：00000000 0000000 0000000 00000111 可以对整数进行移位运算。对整数7左移1位将得到整数14，左移两位将得到整数28：int n = 7; // 00000000 00000000 00000000 00000111 = 7int a = n &lt;&lt; 1; // 00000000 00000000 00000000 00001110 = 14int b = n &lt;&lt; 2; // 00000000 00000000 00000000 00011100 = 28int c = n &lt;&lt; 28; // 01110000 00000000 00000000 00000000 = 1879048192int d = n &lt;&lt; 29; // 11100000 00000000 00000000 00000000 = -536870912左移29位时，由于最高位变成1，因此结果变成了负数。 类似的，对整数7进行右移，结果如下：int n = 7; // 00000000 00000000 00000000 00000111 = 7int a = n &gt;&gt; 1; // 00000000 00000000 00000000 00000011 = 3int b = n &gt;&gt; 2; // 00000000 00000000 00000000 00000001 = 1int c = n &gt;&gt; 3; // 00000000 00000000 00000000 00000000 = 0 如果对一个负数进行右移，最高位的1不动，结果仍然是一个负数：int n = -536870912;int a = n &gt;&gt; 1; // 11110000 00000000 00000000 00000000 = -268435456int b = n &gt;&gt; 2; // 10111000 00000000 00000000 00000000 = -134217728int c = n &gt;&gt; 28; // 11111111 11111111 11111111 11111110 = -2int d = n &gt;&gt; 29; // 11111111 11111111 11111111 11111111 = -1 还有一种不带符号的右移运算，使用&gt;&gt;&gt;，它的特点是符号位跟着动，因此，对一个负数进行&gt;&gt;&gt;右移，它会变成正数，原因是最高位的1变成了0：int n = -536870912;int a = n &gt;&gt;&gt; 1; // 01110000 00000000 00000000 00000000 = 1879048192int b = n &gt;&gt;&gt; 2; // 00111000 00000000 00000000 00000000 = 939524096int c = n &gt;&gt;&gt; 29; // 00000000 00000000 00000000 00000111 = 7int d = n &gt;&gt;&gt; 31; // 00000000 00000000 00000000 00000001 = 1 对byte和short类型进行移位时，会首先转换为int再进行位移。仔细观察可发现，左移实际上就是不断地×2，右移实际上就是不断地÷2。 位运算位运算是按位进行与、或、非和异或的运算。与运算的规则是，必须两个数同时为1，结果才为1：n = 0 &amp; 0; // 0n = 0 &amp; 1; // 0n = 1 &amp; 0; // 0n = 1 &amp; 1; // 1 或运算的规则是，只要任意一个为1，结果就为1：n = 0 | 0; // 0n = 0 | 1; // 1n = 1 | 0; // 1n = 1 | 1; // 1 非运算的规则是，0和1互换：n = ~0; // 1n = ~1; // 0 异或运算的规则是，如果两个数不同，结果为1，否则为0：n = 0 ^ 0; // 0n = 0 ^ 1; // 1n = 1 ^ 0; // 1n = 1 ^ 1; // 0 对两个整数进行位运算，实际上就是按位对齐，然后依次对每一位进行运算。例如：public class Main { public static void main(String[] args) { int i = 167776589; // 00001010 00000000 00010001 01001101 int n = 167776512; // 00001010 00000000 00010001 00000000 System.out.println(i &amp; n); // 167776512 }} 运算优先级在Java的计算表达式中，运算优先级从高到低依次是：()! ~ ++ –* / %+ -&lt;&lt; &gt;&gt; &gt;&gt;&gt;&amp;|+= -= *= /=记不住也没关系，只需要加括号就可以保证运算的优先级正确。 类型自动提升与强制转型在运算过程中，如果参与运算的两个数类型不一致，那么计算结果为较大类型的整型。例如，short和int计算，结果总是int，原因是short首先自动被转型为int也可以将结果强制转型，即将大范围的整数转型为小范围的整数。强制转型使用(类型)，例如，将int强制转型为short：int i = 12345;short s = (short) i; // 12345 小结整数运算的结果永远是精确的；运算结果会自动提升；可以强制转型，但超出范围的强制转型会得到错误的结果；应该选择合适范围的整型（int或long），没有必要为了节省内存而使用byte和short进行整数运算。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础_Java程序基础-1.基本数据类型","date":"2020-02-16T13:05:49.195Z","path":"2020/02/16/Java基础_Java程序基础-1/","text":"1.基本数据类型 基本数据类型是CPU可以直接进行运算的类型。Java定义了以下几种基本数据类型：整数类型：byte，short，int，long浮点数类型：float，double字符类型：char布尔类型：boolean 不同的数据类型占用的字节数不一样。我们看一下Java基本数据类型占用的字节数：a表示一个字节 byte │ a │ short │ a │ a │ int │ a │ a │ a │ a │ long │ a │ a │ a │ a │ a │ a │ a │ a │ float │ a │ a │ a │ a │ double │ a │ a │ a │ a │ a │ a │ a │ a │ char │ a │ a │ byte恰好就是一个字节，而long和double需要8个字节。 整型 对于整型类型，Java只定义了带符号的整型，因此，最高位的bit表示符号位（0表示正数，1表示负数）。各种整型能表示的最大范围如下：byte：-128 ~ 127short: -32768 ~ 32767int: -2147483648 ~ 2147483647long: -9223372036854775808 ~ 9223372036854775807 浮点型 浮点类型的数就是小数，因为小数用科学计数法表示的时候，小数点是可以“浮动”的，如1234.5可以表示成12.345x102，也可以表示成1.2345x103，所以称为浮点数。下面是定义浮点数的例子：float f1 = 3.14f;float f2 = 3.14e38f; // 科学计数法表示的3.14x10^38double d = 1.79e308;double d2 = -1.79e308;double d3 = 4.9e-324; // 科学计数法表示的4.9x10^-324 对于float类型，需要加上f后缀。浮点数可表示的范围非常大，float类型可最大表示3.4x1038，而double类型可最大表示1.79x10308。 布尔类型 布尔类型boolean只有true和false两个值，布尔类型总是关系运算的计算结果：boolean b1 = true;boolean b2 = false;boolean isGreater = 5 &gt; 3; // 计算结果为trueint age = 12;boolean isAdult = age &gt;= 18; // 计算结果为false Java语言对布尔类型的存储并没有做规定，因为理论上存储布尔类型只需要1 bit，但是通常JVM内部会把boolean表示为4字节整数。 字符类型 字符类型char表示一个字符。Java的char类型除了可表示标准的ASCII外，还可以表示一个Unicode字符： 注意char类型使用单引号’，且仅有一个字符，要和双引号”的字符串类型区分开。 常量 定义变量的时候，如果加上final修饰符，这个变量就变成了常量：final double PI = 3.14; // PI是一个常量double r = 5.0;double area = PI * r * r;PI = 300; // compile error! 常量在定义时进行初始化后就不可再次赋值，再次赋值会导致编译错误。常量的作用是用有意义的变量名来避免魔术数字（Magic number），例如，不要在代码中到处写3.14，而是定义一个常量。如果将来需要提高计算精度，我们只需要在常量的定义处修改，例如，改成3.1416，而不必在所有地方替换3.14。根据习惯，常量名通常全部大写。 var关键字（java 10 开始使用）有些时候，类型的名字太长，写起来比较麻烦。例如：StringBuilder sb = new StringBuilder(); 这个时候，如果想省略变量类型，可以使用var关键字：var sb = new StringBuilder(); 编译器会根据赋值语句自动推断出变量sb的类型是StringBuilder。对编译器来说，语句：var sb = new StringBuilder(); 实际上会自动变成：StringBuilder sb = new StringBuilder(); 因此，使用var定义变量，仅仅是少写了变量类型而已。 小结Java提供了两种变量类型：基本类型和引用类型基本类型包括整型，浮点型，布尔型，字符型。变量可重新赋值，等号是赋值语句，不是数学意义的等号。常量在初始化后不可重新赋值，使用常量便于理解程序意图。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]}]