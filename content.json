[{"title":"Mybatis","date":"2020-03-26T00:08:55.607Z","path":"2020/03/26/Mybatis/","text":"一、简介1.1、什么是Mybatis MyBatis 是一款优秀的持久层框架， 它支持自定义 SQL、存储过程以及高级映射。 MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。 MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。 如何获得Mybatis？ 推荐使用maven仓库： 123456&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt; 1.2、持久化数据持久化 持久化就是将程序的数据在瞬时状态和持久状态转化的过程 内存：断电即失 使用数据库（jdbc）、io文件持久化。 1.3、持久层完成持久化工程的代码块（Dao层） 1.4、为什么需要Mybatis？ 方便 传统的JDBC代码太复杂与高耦合。 为了简化操作 优点： 简单易学 灵活 ql和代码的分离，提高了可维护性。 提供映射标签，支持对象与数据库的orm字段关系映射 提供对象关系映射标签，支持对象关系组建维护 提供xml标签，支持编写动态sql。 二、第一个Mybatis程序思路：搭建环境–&gt;导入Mybatis–&gt;编写代码–&gt;测试！ 2.1、环境环境： JDK1.8 Mysql5.5或5.7 maven 3.6.1 IDEA 基础： JDBC Mysql Java基础 Maven Junit 2.2、搭建环境 创建表，插入数据 12345678910111213CREATE DATABASE `mybatis`;use `mybatis`;CREATE TABLE `user`( `id` INT(20) NOT NULL PRIMARY KEY, `name` VARCHAR(30) DEFAULT NULL, `pwd` VARCHAR(30) DEFAULT NULL)ENGINE=INNODB DEFAULT CHARSET=utf8;INSERT INTO `user`(`id`,`name`,`pwd`) VALUES(1,'张三','123456'),(2,'李四','654321') 新建项目 新建一个普通的Maven项目作为父工程（删除src目录）（注意配置IDEA中的Maven,如下：） 导入maven依赖 12345678910111213141516171819202122&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2.3、创建模块 在刚刚的父工程处右键选择Module，创建一个普通的maven项目作为子项目 编写mybatis核心配置文件 在src/main/resources下面创建一个mybatis-config.xml文件内容如下： 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=UTC\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; 编写mybatis工具类 创建一个dao包，在dao包同级创建一个utils包，新建一个类MybatisUtils.java 1234567891011121314151617181920212223242526272829package com.ght.utils;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;//sqlSessionFactory --&gt; sqlSessionpublic class MybatisUtils &#123; private static SqlSessionFactory sqlSessionFactory; static &#123; String resource = \"mybatis-config.xml\"; InputStream inputStream; try &#123; inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static SqlSession getSqlSession()&#123; return sqlSessionFactory.openSession(); &#125;&#125; 2.4、编写代码 实体类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.ght.pojo;public class User &#123; private int id; private String name; private String pwd; public User() &#123; &#125; public User(int id, String name, String pwd) &#123; this.id = id; this.name = name; this.pwd = pwd; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPwd() &#123; return pwd; &#125; public void setPwd(String pwd) &#123; this.pwd = pwd; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + \", pwd='\" + pwd + '\\'' + '&#125;'; &#125;&#125; Dao接口 123456789package com.ght.dao;import com.ght.pojo.User;import java.util.List;public interface UserDao &#123; public abstract List&lt;User&gt; getUserList();&#125; 接口实现类(在mybatis中就是***Mapper.xml配置文件) 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!--namespace=绑定一个对应的Dao/Mapper接口--&gt;&lt;mapper namespace=\"com.ght.dao.UserDao\"&gt; &lt;!--查询语句,id=对应的方法名字--&gt; &lt;select id=\"getUserList\" resultType=\"com.ght.pojo.User\"&gt; select * from user; &lt;/select&gt;&lt;/mapper&gt; 2.5、测试junit测试 123456789101112131415161718192021222324package com.ght.dao;import com.ght.pojo.User;import com.ght.utils.MybatisUtils;import org.apache.ibatis.session.SqlSession;import org.junit.Test;import java.util.List;public class UserDaoTest &#123; @Test public void test()&#123; //获取sqlSession对象 SqlSession sqlSession = MybatisUtils.getSqlSession(); //执行sql UserDao userDao = sqlSession.getMapper(UserDao.class); List&lt;User&gt; userList = userDao.getUserList(); for (User user : userList) &#123; System.out.print(user); &#125; sqlSession.close(); &#125;&#125; 可能会出现的报错： org.apache.ibatis.binding.BindingException: Type interface com.ght.dao.UserDao is not known to the MapperRegistry. 需要在mybatis核心配置文件configuration中注册实现UserDao接口的xml配置文件,添加如下代码 123&lt;mappers&gt; &lt;mapper resource=\"com/ght/dao/UserMapper.xml\" /&gt;&lt;/mappers&gt; 写的UserMapper.xml配置文件，无法被导出或者生效的问题，解决方案： ​ 在pom.xml的build下面加个resources 123456789101112&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 谁的空指针异常就检查Mybatis工具类中谁的作用域以及声明是否正确。 三、CRUD3.1、namespacenamespace中的包名要和dao/mapper接口的名字一致。 3.2、select选择，查询语句 123&lt;select id=\"getUserList\" resultType=\"com.ght.pojo.User\"&gt; select * from user;&lt;/select&gt; id：就是对用的namespace中的方法名； resultType：Sql语句执行的返回值（自定义类型和基本类型） parameterType：参数类型 3.3、insert插入 3.4、update更新 3.5、delect删除 四者的具体使用如下代码： UserDao接口 12345678910111213141516171819202122package com.ght.dao;import com.ght.pojo.User;import java.util.List;public interface UserMapper &#123; //查询全部用户 public abstract List&lt;User&gt; getUserList(); //根据ID查询用户 User getUserById(int id); //insert一个用户 int addUser(User user); //更改一个用户 int updataUser(User user); //删除一个用户 int removeUser(int id);&#125; UserMapper.xml 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!--namespace=绑定一个对应的Dao/Mapper接口--&gt;&lt;mapper namespace=\"com.ght.dao.UserMapper\"&gt; &lt;!--查询语句,id=对应的方法名字--&gt; &lt;select id=\"getUserList\" resultType=\"com.ght.pojo.User\"&gt; select * from mybatis.user; &lt;/select&gt; &lt;select id=\"getUserById\" resultType=\"com.ght.pojo.User\" parameterType=\"int\"&gt; select * from mybatis.user where id=#&#123;id&#125;; &lt;/select&gt; &lt;insert id=\"addUser\" parameterType=\"com.ght.pojo.User\"&gt; insert into mybatis.user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;); &lt;/insert&gt; &lt;update id=\"updataUser\" parameterType=\"com.ght.pojo.User\"&gt; update mybatis.user set name = #&#123;name&#125;,pwd = #&#123;pwd&#125; where id = #&#123;id&#125;; &lt;/update&gt; &lt;delete id=\"removeUser\" parameterType=\"int\"&gt; delete from mybatis.user where id=#&#123;id&#125;; &lt;/delete&gt;&lt;/mapper&gt; Junit测试类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124package com.ght.dao;import com.ght.pojo.User;import com.ght.utils.MybatisUtils;import org.apache.ibatis.session.SqlSession;import org.junit.Test;import java.util.List;public class UserDaoTest &#123; @Test public void test()&#123; SqlSession sqlSession = null; try&#123; //获取sqlSession对象 sqlSession = MybatisUtils.getSqlSession(); //执行sql UserMapper userDao = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; userList = userDao.getUserList(); for (User user : userList) &#123; System.out.println(user); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; sqlSession.close(); &#125; &#125; @Test public void getUserById() &#123; SqlSession sqlSession = null; try &#123; //获取sqlSession对象 sqlSession = MybatisUtils.getSqlSession(); //执行sql UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.getUserById(1); System.out.print(user); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; sqlSession.close(); &#125; &#125; @Test public void addUser()&#123; SqlSession sqlSession = null; try &#123; //获取sqlSession对象 sqlSession = MybatisUtils.getSqlSession(); //执行sql UserMapper mapper = sqlSession.getMapper(UserMapper.class); int i = mapper.addUser(new User(10, \"哈哈\", \"456456\")); if(i&gt;0)&#123; System.out.println(\"插入成功\"); &#125; //提交事务 sqlSession.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; sqlSession.close(); &#125; &#125; @Test public void upUser()&#123; SqlSession sqlSession = null; try &#123; //获取sqlSession对象 sqlSession = MybatisUtils.getSqlSession(); //执行sql UserMapper mapper = sqlSession.getMapper(UserMapper.class); int i = mapper.updataUser(new User(4, \"呵呵\", \"123456\")); if(i&gt;0)&#123; System.out.println(\"更新成功\"); &#125; //提交事务 sqlSession.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; sqlSession.close(); &#125; &#125; @Test public void removeUser()&#123; SqlSession sqlSession = null; try &#123; //获取sqlSession对象 sqlSession = MybatisUtils.getSqlSession(); //执行sql UserMapper mapper = sqlSession.getMapper(UserMapper.class); mapper.removeUser(1); //提交事务 sqlSession.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; sqlSession.close(); &#125; &#125;&#125; 总结：增删改都需要提交事务( sqlSession.commit() )","categories":[],"tags":[]},{"title":"注解","date":"2020-03-23T06:20:31.751Z","path":"2020/03/23/注解/","text":"注解 概念：说明程序的，给计算机看。 注释：用文字描述程序的，给程序员看的。 定义：注解(Annotation)，也叫元数据，一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。 概念描述： JDK1.5之后的新特性 说明程序的 使用注解：@注解名称 作用分类： 编写文档：通过代码里标识的注解生成文档【生成doc文档】 代码分析：通过代码里标识的注解对代码进行分析【使用反射】 编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】 JDK中预定义的一些注解 @Override - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。 @Deprecated - 标记过时方法。如果使用该方法，会报编译警告。 @SuppressWarnings - 指示编译器去忽略注解中声明的警告。 一般传递参数all @SuppressWarnings(&quot;all&quot;) 自定义注解 格式： 元注解 public @interface 注解名称{} 本质：注解本质上就是一个接口，该接口默认继承Annotation接口 public interface Myanno extends java.lang.annotation.Annotation{} 属性：接口中的抽象方法 要求： 属性的返回值类型有下列取值 基本数据类型 String 枚举 注解 以上类型的数组 定义了属性，在使用时需要给属性赋值 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。 如果只是一个属性需要赋值，并且属性的名称是value，value可以忽略，直接定义值即可。 数组赋值时，值使用{}包裹。如果数组中只有一个值，{}可以省略 元注解：用于描述注解的注解 @Target : 被它描述的注解能够作用的位置 ElementType取值: TYPE:可以作用于类上 METHOD:可以作用于方法上 FIELD:可以作用于成员变量上 &lt;!--￼0--&gt; @Documented : 被它描述的注解是否被抽取到api文档中 @Inherited : 被它描述的注解是否被子类继承 在程序使用（解析）注解:获取注解中定义的属性值 代码如下: MyAnno03.java 1234567891011package annotation;import java.lang.annotation.*;@Target(ElementType.TYPE) //表示该注解只能作用于类上@Retention(RetentionPolicy.RUNTIME) //当前被描述的注解，会保留到class字节码文件中，并被JVM读取到public @interface MyAnno03 &#123; String className(); String methodName();&#125; ReflectTest.java 123456789101112131415161718192021222324252627282930package annotation;import java.lang.reflect.Method;/* 假设为一个框架类 */@MyAnno03(className = \"reflect.Student\",methodName = \"sleep\")public class ReflectTest &#123; public static void main(String[] args) throws Exception &#123; /* 调用注解中的属性来获取值 */ Class&lt;ReflectTest&gt; reflectTestClass = ReflectTest.class; MyAnno03 annotation = reflectTestClass.getAnnotation(MyAnno03.class); String className = annotation.className(); String methodName = annotation.methodName(); //3.加载该类进内存 Class cls = Class.forName(className); //4.创建对象 Object obj = cls.newInstance(); //5.获取方法对象 Method method = cls.getMethod(methodName); //6.执行方法 method.invoke(obj); &#125;&#125; 小结: 以后大多数时候，我们会使用注解，而不是自定义注解 注解给谁用？ 编译器 解释程序 注解不是程序的一部分，可以理解为注解就是一个标签","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"反射","date":"2020-03-22T09:58:22.978Z","path":"2020/03/22/反射/","text":"反射 框架：半成品软件。可以在框架的基础上进行软件开发，简化编码 反射：将类的各个组成部分封装为其他对象，这就是反射机制 好处： 可以在程序运行过程中，操作这些对象。 可以解耦，提高程序的可扩展性。 获取Class对象的方式： Class.forName(&quot;全类名&quot;)：将字节码文件加载进内存，返回Class对象 类名.class：通过类名的属性class获取 对象.getClass() : getClass()方法在Object类中定义着 结论： 同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。 Class对象的功能： 获取功能： 获取成员变量们 Field[] getFields()：获取所有public修饰的成员变量 Field getField(String name)：获取指定名称的public修饰的成员变量 Field[] getDeclaredFields()：获取所有的成员变量，不考虑修饰符 Field getDeclaredField(String name)：获取指定名称的成员变量，不考虑修饰符 获取构造方法们 Constructor&lt;?&gt;[] getConstructors() Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes) Constructor&lt;?&gt;[] getDeclaredConstructors() Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes) 获取成员方法们 Method[] getMethods() Method getMethod(String name, 类&lt;?&gt;... parameterTypes) Method[] getDeclaredMethods() Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes) 获取类名 String getName() Field对象的使用 操作： 设置值 void set(Object obj, Object value) 获取值 get(Object obj) 忽略访问权限修饰符的安全检查（即便是private，也能获取到值） setAccessible(true)：暴力反射 Constructor对象的使用 创建对象： T newInstance(Object...initargs) 如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance Method对象的使用 执行方法： Object invoke(Object obj, Object... args) 1234Class aClass = Class.forName(\"ght.基础加强.Person\");Method method1 = aClass.getMethod(\"eat\");Person p1 = new Person();method1.invoke(p1); 案例： 需求：写一个”框架”类，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法 实现： 配置文件 反射 步骤： 将需要创建的对象的全类名和需要执行的方法定义在配置文件中 在程序中加载读取配置文件 使用反射技术来加载类文件进内存 创建对象 执行方法 代码如下: Student.java 1234567package reflect;public class Student &#123; public void sleep()&#123; System.out.println(\"睡觉\"); &#125;&#125; pro.properties 12className=reflect.StudentmethodName=sleep ReflectTest.java 123456789101112131415161718192021222324252627282930313233343536373839package reflect;import java.io.InputStream;import java.lang.reflect.Method;import java.util.Properties;/* 假设为一个框架类 */public class ReflectTest &#123; public static void main(String[] args) throws Exception &#123; //可以创建任意类的对象，可以去执行任意方法// Person p = new Person();// p.eat();// Student stu = new Student();//// stu.sleep(); //1.加载配置文件 //1.1创建Properties对象 Properties pro = new Properties(); //1.2加载配置文件，转换为一个集合 //1.2.1获取class目录下的配置文件信息 ClassLoader classLoader = ReflectTest.class.getClassLoader(); InputStream is = classLoader.getResourceAsStream(\"reflect/pro.properties\"); pro.load(is); //2.获取配置文件中定义的数据 String className = pro.getProperty(\"className\"); String methodName = pro.getProperty(\"methodName\"); //3.加载该类进内存 Class cls = Class.forName(className); //4.创建对象 Object obj = cls.newInstance(); //5.获取方法对象 Method method = cls.getMethod(methodName); //6.执行方法 method.invoke(obj); &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"IO流","date":"2020-03-15T02:51:00.135Z","path":"2020/03/15/IO流/","text":"一、IO概述1.1&nbsp;什么是IO我们把数据的传输，可以看作是一种数据的流动，按照流动的方向，以内存为基准，分为输入input和输出output，即流向内存是输入流，流出内存是输出流。 Java中I/O操作主要是指使用Java.io包下的内容，进行输入，输出操作。输入也叫作读取数据，输出也叫作写出数据。 1.2&nbsp;IO的分类根据数据的流向分为：输入流和输出流 输入流：把数据从其他设备上读取到内存中的流。 输出流：把数据从内存中写出到其他设备上的流。 根据数据的类型分为：字节流和字符流 字节流：以字节为单位，读写数据的流。 字符流：以字符为单位，读写数据的流。 1.3&nbsp;最顶层的四个父类 输入流 输出流 字节流 字节输入流InputStream 字节输出流OutputStream 字符流 字符输入流Reader 字符输出流Writer 二、字节流与字符流2.1&nbsp;一切皆为字节一切文件数据（文本、图片、视频等）在存储时，都是以二进制数字的形式保存，都是一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。 2.2&nbsp;字节输出流java.io.OutputStream 直接已知子类：ByteArrayOutputStream, FileOutputStream, FilterOutputStream, ObjectOutputStream, OutputStream, PipedOutputStream void close() 关闭此输出流并释放与此流相关联的任何系统资源。 void flush() 刷新此输出流并强制任何缓冲的输出字节被写出。 void write(byte[] b) 将 b.length字节从指定的字节数组写入此输出流。 void write(byte[] b, int off, int len) 从指定的字节数组写入 len个字节，从偏移 off开始输出到此输出流。 abstract void write(int b) 将指定的字节写入此输出流。 使用步骤： 创建一个FileOutputStream对象，构造方法中传递写入数据的目的地 调用FileOutputStream对象中的方法write，将数据写入到文件中 释放资源 代码： 12345678910111213141516171819202122232425262728293031import java.io.File;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;public class Demo01OutputStream &#123; public static void main(String[] args) &#123; File file = new File(\"dest.txt\"); FileOutputStream os= null; try&#123; os = new FileOutputStream(file,true); //如果为true，追加输出 String msg = \"IO is so easy\"; byte[] datas = msg.getBytes(); //字符串--&gt;字节数组（编码） os.write(datas,0,datas.length); os.flush(); &#125;catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if(os!=null)&#123; os.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 2.3 字节输入流使用步骤： 创建源 选择流 操作 释放资源 123456789101112131415161718192021222324252627282930313233343536import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;public class Demo02OutputStream &#123; public static void main(String[] args) &#123; //1.创建源 File file = new File(\"b.txt\"); FileInputStream input= null; //2.选择流 try &#123; input = new FileInputStream(file); //3.操作 int temp; while((temp=input.read()) != -1)&#123; System.out.print((char)temp); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125;finally &#123; //4.释放资源 try &#123; if(input!=null)&#123; input.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 手动添加缓冲容器 1234567891011121314151617181920212223242526272829303132import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;public class Demo02IutputStream &#123; public static void main(String[] args) &#123; File file = new File(\"b.txt\"); FileInputStream input= null; try &#123; input = new FileInputStream(file); byte[] car = new byte[3]; //缓冲容器 int len = -1; while ((len=input.read(car)) != -1)&#123; String str = new String(car,0,len); System.out.println(str); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if(input!=null)&#123; input.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 2.4&nbsp;拷贝文件内容原理：直接将字节输入流和字节输出流结合起来 1234567891011121314151617181920212223242526272829303132333435363738394041package IO;import java.io.*;public class CopyFile &#123; public static void main(String[] args) &#123; File file1 = new File(\"b.txt\"); //源文件 File file2 = new File(\"dest.txt\"); //目标文件名 FileInputStream is = null; FileOutputStream os = null; try &#123; is = new FileInputStream(file1); os = new FileOutputStream(file2); byte[] car = new byte[3]; //缓冲容器 int len = -1; while ((len=is.read(car)) != -1)&#123; os.write(car,0,len); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if(os!=null)&#123; os.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if(is!=null)&#123; is.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 2.5&nbsp;字符输入流使用方法大同小异，只需要将字节输入流中的FileInputStream修改为FileReader 具体实现如下： 1234567891011121314151617181920212223242526272829303132import java.io.File;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;public class Demo01Reader &#123; public static void main(String[] args) &#123; File file = new File(\"b.txt\"); FileReader input= null; try &#123; input = new FileReader(file); char[] car = new char[1024]; //缓冲容器 int len = -1; while ((len=input.read(car)) != -1)&#123; String str = new String(car,0,len); System.out.println(str); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if(input!=null)&#123; input.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 2.6&nbsp;字符输出流代码实现： 123456789101112131415161718192021222324252627import java.io.*;public class Demo02Writer &#123; public static void main(String[] args) &#123; File file = new File(\"dest.txt\"); FileWriter os = null; try &#123; os = new FileWriter(file,true); String msg = \"IO is so easy\\r\\n中文字符\\r\\n\"; char[] datas = msg.toCharArray();//字符串--&gt;字符数组 os.write(datas,0,datas.length); os.flush(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if (os!=null)&#123; os.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 2.7&nbsp;字节数组流（扩展）字节数组输入流字符数组流主要应用于网络传输 特点： 操作字节数组 字节数组不要太大 可以不释放资源，因为源码中这是一个空方法 代码如下： 1234567891011121314151617181920212223242526272829303132package IO;import java.io.*;public class Demo01ByteArrayInputStream &#123; public static void main(String[] args) &#123; //1.创建源 byte[] src = \"talk is cheap show me the code\".getBytes(); InputStream input= null; //使用了多态 try &#123; //2.选择流 input = new ByteArrayInputStream(src); //3.操作 byte[] car = new byte[5]; //缓冲容器 int len = -1; while ((len=input.read(car)) != -1)&#123; String str = new String(car,0,len); System.out.println(str); &#125; &#125;catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if(input!=null)&#123; //这里可以不使用close方法。字节数组流的特点 input.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 字节数组输出流1234567891011121314151617181920212223242526272829303132333435package IO;import java.io.ByteArrayOutputStream;import java.io.IOException;public class Demo02ByteArrayOutputStream &#123; public static void main(String[] args) &#123; //1.创建源 byte[] dest = null; ByteArrayOutputStream baos = null; //使用了多态 try &#123; //2.选择流 baos = new ByteArrayOutputStream(); //3.操作 String msg = \"show me the code\"; //缓冲容器 byte[] datas = msg.getBytes(); baos.write(datas,0,datas.length); baos.flush(); //获取数据 dest = baos.toByteArray(); //输出字节数组 System.out.println(new String(dest,0,baos.size()));//打印 &#125;catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if(baos!=null)&#123; //这里可以不使用close方法。字节数组流的特点 baos.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 综合对接各个流实现要求：将一张图片或者是文件读取到字节数组中，再由字节数组流拷贝一份，这样做的原因是因为任何形式的文件或者是图片都可以读到字节数组中，免去了文件中中文编码的问题或者是拷贝后图片打不开的情况。 综合使用了FileInputStream，FileOutputStream,ByteArrayInputStream,ByteArrayOutputStream 以下是完成的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package IO;import java.io.*;public class ZongHe &#123; public static void main(String[] args) &#123; byte[] datas = fileToByteArray(\"b.txt\"); //从b.txt到b-byte.txt,图片也可这样使用 byteArrayToFile(datas,\"b-byte.txt\"); &#125; /* 1.文件读取到字节数组 首先文件读取到程序 FileInputStream 再由程序到字节数组 ByteArraOutputStream */ public static byte[] fileToByteArray(String filepath) &#123; File file = new File(filepath); FileInputStream is = null; ByteArrayOutputStream baos = null; try &#123; is = new FileInputStream(file); baos = new ByteArrayOutputStream(); //操作 //创建缓冲区 byte[] flush = new byte[5]; int len = -1; //将文件读取到缓冲区中 while ((len=is.read(flush))!= -1)&#123; //写入到字节数组 baos.write(flush,0,len); &#125; baos.flush(); //返回一个字节数组 return baos.toByteArray(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); return null; &#125; catch (IOException e) &#123; e.printStackTrace(); return null; &#125; &#125; /* 2.字节数组写出到文件 首先字节数组到程序 ByteArrayInputStream 再从程序写到文件 FileOutputStream */ public static void byteArrayToFile(byte[] datas,String filepath)&#123; //获取字节数组数据源 ByteArrayInputStream bais = new ByteArrayInputStream(datas); FileOutputStream os = null; try&#123; //filepath为保存的文件路径，由变量传入 os = new FileOutputStream(filepath); byte[] flush = new byte[5]; int len = -1; //将字节数组读取到缓冲区中。 while ((len=bais.read(flush)) != -1)&#123; //再由缓冲区写到对应的文件。 os.write(flush,0,len); &#125; os.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if(os!=null)&#123; os.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 三、字节缓冲流与字符缓冲流字节缓冲流相比于字节流性能更好，效率更好 3.1&nbsp;字节缓冲输入流构造方法 BufferedInputStream(InputStream in) 创建一个 BufferedInputStream并保存其参数，输入流 in ，供以后使用。 BufferedInputStream(InputStream in, int size) 创建 BufferedInputStream具有指定缓冲区大小，并保存其参数，输入流 in ，供以后使用。 3.2&nbsp;字节缓冲输出流构造方法 BufferedOutputStream(OutputStream out) 创建一个新的缓冲输出流，以将数据写入指定的底层输出流。 BufferedOutputStream(OutputStream out, int size) 创建一个新的缓冲输出流，以便以指定的缓冲区大小将数据写入指定的底层输出流。 3.3&nbsp;二者结合应用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.io.*;/** * * 代码中注释部分由try的()中替代 */public class CopyFile &#123; public static void main(String[] args) &#123; long t1 = System.currentTimeMillis(); copy(\"b.txt\",\"dest.txt\"); long t2 = System.currentTimeMillis(); System.out.println(t2-t1); &#125; private static void copy(String srcPath,String destPath)&#123; File file1 = new File(srcPath); File file2 = new File(destPath);// InputStream is = null;// OutputStream os = null; try(BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file1)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(file2))) &#123;// bis = new BufferedInputStream(new FileInputStream(file1));// bos = new BufferedOutputStream(new FileOutputStream(file2)); byte[] car = new byte[3]; //缓冲容器 int len = -1; while ((len=bis.read(car)) != -1)&#123; bos.write(car,0,len); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;// finally &#123;// try &#123;// if(bos!=null)&#123;// bos.close();// &#125;// &#125; catch (IOException e) &#123;// e.printStackTrace();// &#125;// try &#123;// if(bis!=null)&#123;// bis.close();// &#125;// &#125; catch (IOException e) &#123;// e.printStackTrace();// &#125;//// &#125; &#125;&#125; 3.4&nbsp;字符缓冲输入流字符缓冲输入流有一个特有的方法 String readLine() 读一行文字。 所以BufferedReader在使用自己特有的方法时声明过程中不能使用多态 构造方法 BufferedReader(Reader in) 创建使用默认大小的输入缓冲区的缓冲字符输入流。 BufferedReader(Reader in, int sz) 创建使用指定大小的输入缓冲区的缓冲字符输入流。 3.5&nbsp;字符缓冲输出流字符缓冲输出流也有一个特有的方法 void newLine() 分隔符。 构造方法 BufferedWriter(Writer out) 创建使用默认大小的输出缓冲区的缓冲字符输出流。 BufferedWriter(Writer out, int sz) 创建一个新的缓冲字符输出流，使用给定大小的输出缓冲区。 3.6&nbsp;二者结合应用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.io.*;/** * * 代码中注释部分由try的()中替代 */public class CopyFile &#123; public static void main(String[] args) &#123; long t1 = System.currentTimeMillis(); ziFucopy(\"b.txt\",\"ziFu-copy-b.txt\"); long t2 = System.currentTimeMillis(); System.out.println(t2-t1); &#125; private static void ziFucopy(String srcPath,String destPath)&#123; File file1 = new File(srcPath); File file2 = new File(destPath);// BufferedReader br = null;// BufferedWriter bw = null; try(BufferedReader br = new BufferedReader(new FileReader(file1)); BufferedWriter bw = new BufferedWriter(new FileWriter(file2))) &#123;// br = new BufferedReader(new FileReader(file1));// bw = new BufferedWriter(new FileWriter(file2)); String line = null; while ((line=br.readLine()) != null)&#123; bw.write(line); bw.newLine(); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;// finally &#123;// try &#123;// if(bw!=null)&#123;// bw.close();// &#125;// &#125; catch (IOException e) &#123;// e.printStackTrace();// &#125;// try &#123;// if(br!=null)&#123;// br.close();// &#125;// &#125; catch (IOException e) &#123;// e.printStackTrace();// &#125;//// &#125; &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"多线程","date":"2020-03-13T07:55:32.699Z","path":"2020/03/13/多线程/","text":"一、多线程我们在这之前，学习的程序在没有跳转语句的前提下，都是自上而下依次执行的；那么现在要设计一个程序，边打游戏边听歌，怎么设计？ 要解决上述的问题，就要使用多线程或者多进程来解决。 1.1&nbsp;并发与并行 并发：指两个或多个事件在同一个时间段内发生。 并行：指两个或多个事件在同一个时刻发生（同时发生）。 1.2&nbsp;线程与进程 进程：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程度可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。 线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 总而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程。 线程调度: 分时调度 所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间。 抢占式调度 优先让优先级高的线程使用CPU,如果线程的优先级相同，那么会随机选择一个，Java使用的是抢占式调度 1.3&nbsp;创建线程类Java中使用java.lang.Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。 Java中通过继承Thread类来创建并启动多线程的步骤如下： 定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务，因此把run()方法称为线程执行体。 创建Thread子类的实例，即创建了线程对象 调用线程对象的start()方法来启动该线程 测试类： Demo01Thread.java 123456789101112131415161718192021/* 创建多线程程序的第一种方式：创建Thread类的子类 java.lang.Thread类：是描述线程的类，我们想要实现多线程程序，就必须继承Thread类 步骤： 1.创建一个Thread类的子类 2.在Thread类的子类中重写Thread类中的run方法，设置线程任务（开始线程要做什么？） 3.创建Thread类的子类对象 4.调用Thread类中的方法start方法，开启新的线程，执行run方法。 void start() 使该线程开始执行；Java 虚拟机调用该线程的 run 方法。 */public class Demo01Thread &#123; public static void main(String[] args) &#123; MyThread myThread = new MyThread(); myThread.start(); for (int i = 0; i &lt; 20 ; i++) &#123; System.out.println(\"main\"+i); &#125; &#125;&#125; MyThread.java 12345678public class MyThread extends Thread &#123; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(\"run\"+i); &#125; &#125;&#125; 1.4&nbsp;Thread类该类中定义了有关线程的一些方法，具体如下： 构造方法： public Thread():分配一个新的线程对象。 public Thread(String name):分配一个指定名字给新的线程对象。 public Thread(Runnable target):分配一个带有指定目标新的线程对象。 public Thread(Runnable target,String name):分配一个带有指定目标新的线程对象并指定名字。 常用方法： public String getName():获取当前线程名称。 public void start():导致此线程开始；Java虚拟机调用此线程的run方法。 public void run():此线程要执行的任务在此处定义代码。 public static void sleep(long millis):使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。 public static Thread currentThread():返回对当前正在执行的线程对象的引用。 获取线程的名称： 1).使用Thread类中的方法getName() String getName() 返回该线程的名称。 2).可以先获取到当前正在执行的线程，使用线程中的方法getName()获取线程的名称 static Thread currentThread() 返回对当前正在执行的线程对象的引用。 Demo01Thread.java 123456public class Demo01Thread &#123; public static void main(String[] args) &#123; MyThread myThread = new MyThread(); myThread.start(); &#125;&#125; MyThread.java 12345678910111213public class MyThread extends Thread &#123; @Override public void run() &#123;//第一种方法 String name = getName(); System.out.println(name);//第二种方法 Thread t = Thread.currentThread(); String name1 = t.getName(); System.out.println(name1); &#125;&#125; 设置线程名称：（了解） 1).使用Thread类中的方法setName(名字) void setName(String name)改变线程的名称，使之与参数name相同。 2).创建一个带参数的构造方法，参数传递线程的名称；调用父类的带参构造方法，把线程名称传递给父类，让父类(Thread)给子线程起一个名字 Thread(String name)分配新的Thread对象。 代码如下： 12345678910111213141516171819/* 创建多线程程序的第一种方式：创建Thread类的子类 java.lang.Thread类：是描述线程的类，我们想要实现多线程程序，就必须继承Thread类 步骤： 1.创建一个Thread类的子类 2.在Thread类的子类中重写Thread类中的run方法，设置线程任务（开始线程要做什么？） 3.创建Thread类的子类对象 4.调用Thread类中的方法start方法，开启新的线程，执行run方法。 void start() 使该线程开始执行；Java 虚拟机调用该线程的 run 方法。 */public class Demo01Thread &#123; public static void main(String[] args) &#123; MyThread_setName mt = new MyThread_setName(); mt.setName(\"李四\"); mt.start(); new MyThread_setName(\"王五\").start(); &#125;&#125; 1234567891011121314public class MyThread_setName extends Thread &#123; public MyThread_setName()&#123;&#125; //第一种方法 public MyThread_setName(String name)&#123; super(name); &#125; //第二种方法 @Override public void run() &#123; System.out.println(Thread.currentThread().getName()); &#125;&#125; 1.5&nbsp;创建线程方式二采用java.lang.Runnable也是非常常见的一种，我们只需要重写run方法即可。 步骤如下： 定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。 创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。 调用线程对象的start()方法来启动线程。 代码如下： 123456public class PrimeRun implements Runnable &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+\"是实现Runnable接口创建的线程\"); &#125;&#125; 1234567public class Demo02Runnable &#123; public static void main(String[] args) &#123; PrimeRun pr = new PrimeRun(); Thread tr = new Thread(pr); tr.start(); &#125;&#125; 实现Runnable接口创建多线程程序的好处： 避免了单继承的局限性 一个类值能继承一个类，类继承了Thread类就不能继承其他的类 实现了Runnable接口，还可以继承其他的类，实现其他的接口 增强了程序的扩展性，降低了程序的耦合性（解耦） 实现Runnable接口的方式，把设置线程任务和开起线程进行了分离（解耦） 1.6&nbsp;解决线程安全Lock锁（JDK1.5之后） 使用步骤： 在成员位置创建一个ReentrantLock（实现Lock接口的一个类）对象 在可能会出现安全问题的代码前调用Lock接口中的方法Lock获取锁 在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁 三个窗口卖票案例： RunnableImpl.java 12345678910111213141516171819202122232425262728import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class RunnableImpl implements Runnable &#123; private int ticket = 100; Lock l = new ReentrantLock(); @Override public void run() &#123; while(ticket&gt;0)&#123; l.lock(); if(ticket&gt;0)&#123; try&#123; Thread.sleep(100); System.out.println(Thread.currentThread().getName()+\"---&gt;正在卖第\"+ticket+\"张票\"); ticket--; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; l.unlock(); &#125; &#125; &#125; &#125;&#125; Demo03Lock.java 123456789101112public class Demo03Lock &#123; public static void main(String[] args) &#123; RunnableImpl ru = new RunnableImpl(); Thread r0 = new Thread(ru); Thread r1 = new Thread(ru); Thread r2 = new Thread(ru); r0.start(); r1.start(); r2.start(); &#125;&#125; 使用了Lock锁就可以避免两个窗口卖到同一张票或者是不存在的票 二、等待唤醒机制1.1 &nbsp;线程间通信概念：多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同 为什么要处理线程间通信： 多个线程并发执行时，在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行，那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。 如何保证线程间通信有效利用资源： 多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。就是多个线程在操作同一份数据时，避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即——等待唤醒机制 1.2 &nbsp;等待唤醒机制什么是等待唤醒机制：线程之间的通信 这是多个线程间的一种协作机制。谈到线程我们经常想到的是线程间的竞争（race），比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。就好比在公司里你和你的同事们，你们可能存在在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。 就是在一个线程进行了规定操作后，就进入等待状态（wait()），等待其他线程执行完他们的指定代码过后，再将其唤醒（notify()）；在有多个线程进行等待时，如果需要，可以使用notifyAll()来唤醒所有的等待线程。 wait/notify就是线程间的一种协作机制。 等待唤醒中的方法 等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下： wait：线程不再活动，不再参与调度，进入wait&nbsp;set中，因此不会浪费CPU资源，也不会去竞争锁了，这时的线程状态即是WAITING。它还要等着别的线程执行一个特别的动作，也即是“通知（notify）”在这个对象上等待的线程从wait set中释放出来，重新进入到调度队列（ready queue）中 notify：则选取所通知对象的wait&nbsp;set中的一个线程释放；例如，餐馆有空位置后，等待就餐最久的顾客最先入座。 notifyAll：则释放所通知对象的wait&nbsp;set上的全部线程。 注意： 哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以它需要再次尝试去获取锁（很可能面临其他线程的竞争），成功后才能在当初调用wait方法之后的地方恢复执行。 总结如下： 如果能获取锁，线程就从WAITING状态变成RUNNABLE状态； 否则，从wait&nbsp;set出来，又进入entry&nbsp;set，线程就从WAITING状态又变成BLOCKED状态 调用wait和notify方法需要注意的细节 wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。 wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都继承了Object类的。 wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。 1.3&nbsp;生产者与消费者问题等待唤醒机制其实就是经典的生产者与消费者的问题 就拿买卖包子例子来举例： 分析：需要一个包子类，包子铺类，消费者类，最后一个测试类。 Baozi.java 123456789101112131415161718192021222324252627282930313233343536373839404142/*包子有皮，馅，false表示有无包子*/public class Baozi &#123; String pi; String xian; boolean flag = false; public Baozi() &#123; &#125; public Baozi(String pi, String xian, boolean flag) &#123; this.pi = pi; this.xian = xian; this.flag = flag; &#125; public String getPi() &#123; return pi; &#125; public void setPi(String pi) &#123; this.pi = pi; &#125; public String getXian() &#123; return xian; &#125; public void setXian(String xian) &#123; this.xian = xian; &#125; public boolean isFlag() &#123; return flag; &#125; public void setFlag(boolean flag) &#123; this.flag = flag; &#125;&#125; BaoziPu.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162* 生产者类：是一个多线程类，可以继承Thread 设置线程任务（run）：生产包子 true：有包子 包子铺调用wait方法进入等待状态 false：无包子 包子铺生产包子，交替生产两种包子 生产好了包子将状态改为true 唤醒消费者线程，吃包子 */public class BaoziPu extends Thread&#123; int count=0; //使用包子对象作为锁对象 private Baozi bz; public BaoziPu(Baozi bz) &#123; this.bz = bz; &#125; @Override public void run() &#123; while(true)&#123; synchronized (bz)&#123; //判断有无包子 if (bz.flag==true) &#123; try &#123; //包子铺调用wait方法进入等待状态 bz.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //被唤醒之后执行，包子铺生产包子 if(count % 2 ==0)&#123; //生产 薄皮三鲜馅包子 bz.pi=\"薄皮\"; bz.xian = \"三鲜馅\"; &#125;else&#123; //生产 冰皮 牛肉大葱馅 bz.pi=\"冰皮\"; bz.xian=\"牛肉大葱馅\"; &#125; count++; System.out.println(\"包子铺正在生产：\"+bz.pi+bz.xian+\"包子\"); //生产包子让线程暂停3秒 try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //生产完成 bz.flag = true; //唤醒吃货线程，吃包子 bz.notify(); System.out.println(\"包子铺已经生产好了\"+bz.pi+bz.xian+\"包子\"); &#125; &#125; &#125;&#125; Chihuo.java 12345678910111213141516171819202122232425262728293031public class Chihuo extends Thread&#123; private Baozi bz; public Chihuo(Baozi bz)&#123; this.bz = bz; &#125; @Override public void run() &#123; while(true)&#123; synchronized (bz)&#123; if(bz.flag==false)&#123; try &#123; //如果没有包子，吃货调用wait方法进入等待状态 bz.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //线程被唤醒之后，有包子，开始吃包子 System.out.println(\"吃货正在吃\"+bz.pi+bz.xian+\"包子\"); bz.flag=false; //唤醒包子铺线程，生产包子 bz.notify(); System.out.println(\"吃货已经把\"+bz.pi+bz.xian+\"包子吃完了，包子铺开始生产包子\"); System.out.println(\"-------------------------------------------------\"); &#125; &#125; &#125;&#125; 测试类Demo.java 1234567public class Demo &#123; public static void main(String[] args) &#123; Baozi bz = new Baozi(); new BaoziPu(bz).start(); new Chihuo(bz).start(); &#125;&#125; 三、线程池2.1&nbsp;线程池思维概述我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会出现一个问题： 如果并发的线程数量很多，并且每个线程都是执行一个 时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。 那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是继续执行其他的任务？ 在Java中可以通过线程池来达到这样的效果。今天我们就来详细讲解一下Java的线程池。 2.2&nbsp;线程池概念 线程池：其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。 由于线程池中有很多操作都是与优化资源相关的，这里就不再赘述，通过一张图来了解线程池的工作原理： 合理利用线程池能够带来三个好处： 降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。 提高响应速度。到任务到达时，任务可以不需要等待线程创建就能立即执行。 提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下（每个线程需要大约1MB内存，线程越多，内存占用越大，最后死机）。 2.3&nbsp;线程池的使用线程池：JDK1.5之后提供的 java.util.concurrent.Executors：线程池的工厂类，用来生成线程池 使用步骤： 使用线程池的工厂类Executors里面提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池 创建一个类，实现Runnable接口，重写run方法，设置线程任务 调用ExecutorService中的方法submit，传递线程任务（实现类），开起线程，执行run方法 调用ExecutorService中的方法shutdown销毁线程池（不建议使用） RunnableImpl.java 1234567public class RunnableImpl implements Runnable &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()); &#125;&#125; Demo.java 1234567891011import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class Demo &#123; public static void main(String[] args) &#123; ExecutorService es = Executors.newFixedThreadPool(2); es.submit(new RunnableImpl()); es.submit(new RunnableImpl()); es.submit(new RunnableImpl()); &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"异常","date":"2020-03-13T01:03:26.595Z","path":"2020/03/13/异常/","text":"一、异常1.1&nbsp;异常概念 异常：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止 在Java等面向对象的编程语言中，异常本事就是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式就是中断处理。 异常指的并不是语法错误，语法错了，编译不通过，不会产生字节码文件，根本不能运行。 1.2&nbsp;异常体系异常机制其实是帮助我们找到程序中的问题，异常的根类是java.lang.Throwable，其下有两个子类： java.lang.Error与java.lang.Exception，平常所说的异常值java.lang.Exception。 1.3&nbsp;异常分类我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。 异常(Exception)的分类：根据在编译时期还是运行时期去检查异常 编译时期异常：checked异常。在编译时期，就会检查，如果没有处理异常，则编译失败。（如日期格式异常） 运行时期异常：runtime异常。在运行时期，检查异常。在编译时期，运行异常不会被编译器检测（不报错）。（如数学异常） Exception：编译期异常，进行编译（写代码）java程序出现的问题 RuntimeException：运行期异常，java程序运行过程中出现的问题 Error：错误 错误就相当于程序就得了一个无法治愈的毛病，必须修改源代码，程序才能继续执行 二、异常的处理2.1&nbsp;throw关键字（抛出异常）作用：可以使用throw关键字在指定的方法中抛出指定的异常 使用格式：throw new xxxException(“产生异常的原因”); 注意： throw关键字必须写在方法的内容 throw关键字后边new的对象必须是Exception或者Exception的子类对象 throw关键字抛出指定的异常对象，我们就必须处理这个异常对象 throw关键字后边创建的是RuntimeException或者RuntimeException的子类对象，我们可以不处理，默认交给JVM处理（打印异常对象，中断程序） throw关键字后边创建的是编译异常（写代码的时候报错），我们就必须处理这个异常，要么throws,要么try…catch 12345678910111213141516171819public class ThrowDemo &#123; public static void main(String[] args) &#123; //int[] arr = null; int[] arr = new int[3]; getElement(arr,3); &#125; public static int getElement(int[] arr , int index)&#123; //校验数组是否为空 if(arr == null )&#123; throw new NullPointerException(\"传递的数组的值是null\");//空指针是运行期异常，默认交给JVM处理 &#125; //校验传递过来的index是否合法 if(index &lt; 0 || index &gt; arr.length-1)&#123; throw new ArrayIndexOutOfBoundsException(\"数组索引越界了\"); &#125; int ele = arr[index]; return ele; &#125;&#125; 2.2&nbsp;Objects非空判断Objects类，它由一些静态的实用方法组成，这些方法是null-save(空指针安全的)或null-tolerant（容忍空指针的），那么在它的源码中，对对象为null的值进行了抛出异常操作。 public static &lt;T&gt; T requireNonNull(T obj):查看指定引用对象不是null. 查看源码发现这里对为null的进行了抛出异常操作： 1234567891011121314import java.util.Objects;public class ObjectsDemo01 &#123; public static void main(String[] args) &#123; method(null); &#125; public static void method(Object obj)&#123; //对传递过来的参数进行合法性判断，判断是否为null// if(obj == null)&#123;// throw new NullPointerException(\"传递的对象的值是null\");// &#125; Objects.requireNonNull(obj,\"传递的对象的值是null\"); &#125;&#125; 2.3&nbsp;声明异常throws声明异常：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后将该方式），那么必须通过throws进行声明，让调用者去处理。 关键字throws运用于方法声明之上，用于表示当前方法不处理异常，而是提醒该方法的调用者来处理异常（抛出异常）. 声明异常格式： 1修饰符 返回值类型 方法名(参数) throws 异常类名1，异常类名2...&#123;...&#125; 声明异常的代码演示： 1234567891011121314151617181920212223242526272829303132/* throws关键字:异常处理的第一种方式，交给别人处理 作用： 当方法内容抛出异常对象的时候，我们就必须处理这个异常对象 可以使用throws关键字处理异常对象，会把异常对象声明抛出给方法的调用者处理（自己不处理，给别人处理），最终交给JVM处理--&gt;中断处理 使用格式：在方法声明时使用 修饰符 返回值类型 方法名(参数列表) throws AAAException,BBBException...&#123; throw new AAAException(\"产生原因\"); throw new BBBException(\"产生原因\"); &#125; 注意： 1.throws关键字必须写在方法声明处 2.throws关键字后边声明的异常必须是Exception或者是Exception的子类 3.方法内部如果抛出了多个异常对象，那么throws后边必须也声明多个异常 如果抛出的异常对象有子父类关系，那么直接声明父类异常即可 4.调用了一个声明抛出异常的方法，交给方法的调用者处理，最终交给JVM要么try...catch自己处理异常 */import java.io.FileNotFoundException;public class ThrowsDemo01 &#123; public static void main(String[] args) throws FileNotFoundException &#123; readfile(\"c:\\\\a.txt\"); &#125; //对传递的文件路径进行合法性的判断 public static void readfile(String filename) throws FileNotFoundException&#123; if(!filename.equals(\"c:\\\\a.txt\"))&#123; throw new FileNotFoundException(\"传递的文件路径不是c:\\\\a.txt\"); &#125; &#125;&#125; 2.4&nbsp;捕获异常如果异常出现的话，会立刻终止程序，所有我们得处理异常： 该方法不处理，而是声明抛出，由该方法的调用者来处理（throws）。 在方法中使用try-catch的语句块来处理异常。 try-catch的方式就是捕获异常。 捕获异常：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行制定方式的处理。 捕获异常语法如下： 123456789101112131415161718192021222324252627282930313233343536import java.io.FileNotFoundException;import java.io.IOException;/* try..catch：处理异常的第二种方式，自己处理异常 格式： try&#123; 可能产生异常的代码 &#125;catch(定义一个异常的变量，用来接收try中抛出的异常对象)&#123; 异常的处理逻辑，产生异常对象之后，怎么处理异常对象 一般在工作中，会把异常的信息记录到一个日志中 &#125; ... catch()&#123; &#125; 注意： 1.try中可能会抛出多个异常对象，那么就可以使用多个catch来处理这些异常对象 2.如果try中产生了异常，那么就会执行catch中的异常处理逻辑，执行完毕后，继续执行try...catch后面的代码 如果try中没有产生异常，那么久不会catch中异常的逻辑，执行完毕后，继续执行try...catch后面的代码 */public class TrycatchDemo01 &#123; public static void main(String[] args) &#123; try&#123; readfile(\"a:\\\\a.tx\"); &#125;catch (IOException e)&#123; //try中抛出什么异常对象，catch就定义什么异常变量，用来接收这个异常对象 System.out.println(\"catch - 传递的文件后缀名不是.txt\"); &#125; System.out.println(\"后续代码\"); &#125; public static void readfile(String filename) throws IOException &#123; if(!filename.endsWith(\".txt\"))&#123; throw new FileNotFoundException(\"文件的后缀名不对\"); &#125; &#125;&#125; finally代码块 finally不能单独使用，必须和try一起使用 finally一般用于资源释放（资源回放），无论程序是否出现异常，最后都要释放资源（IO） 三、自定义异常3.1 &nbsp;概述我们说了Java中不同的异常类，分别表示着某一种具体的异常情况，那么在开发中总是有些异常情况是sun没有定义的，这个时候我们就可以自己来自定义异常。 在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常，这些异常和可能在JDK中没有定义过，例如年龄负数问题，考试成绩负数问题。 什么是自定义异常类： 在开发中根据自己业务的异常情况来定义的异常类. 例如：RegisterException。一个注册异常类。 异常类如何定义 自定义一个编译期异常：自定义类 并继承于 java.lang.Exception。 自定义一个运行时期的异常类：自定义类 并继承与 java.lang.RuntimeException。 3.2&nbsp;代码演示1234567891011121314151617181920212223242526/* 自定义异常类： java提供的异常类，不够我们使用，需要自己定义一些异常类 格式： public class XXXException extends Exception | RuntimeException&#123; 添加一个空参数的构造方法 添加一个带异常信息的构造方法 &#125; 注意： 1.自定义异常类一般都是以Exception结尾，说明该类是一个异常类 2.自定义异常类，必须继承Exception或者RuntimeException 继承Exception：那么自定义的异常类就是一个编译期异常，如果方法内部抛出了编译期异常，就必须处理这个异常，那么throws，要么try..catch 继承RuntimeException：那么自定义的异常就是一个运行期异常，无需处理，交给JVM处理（中断处理） */public class RegisterException extends RuntimeException &#123; public RegisterException()&#123; super(); &#125; /* 添加一个带异常信息的构造方法 查看API中的其他异常类的源码发现所有的异常类都会有一个带异常信息的构造方法，方法内部会调用父类带异常信息的处理方法，让父类来处理这个异常信息 */ public RegisterException(String message)&#123; super(message); &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Map集合","date":"2020-03-05T09:27:22.285Z","path":"2020/03/05/Map集合/","text":"Map集合1public interface Map&lt;K,V&gt; Map集合的特点： Map集合是一个双列集合，一个元素包含两个值（key，value） Map集合中的元素，key与value的数据类型可以相同，也可以不同 Map集合中的元素，key是不可以重复的，value是可以重复的 Map集合中的元素，key与value是一一对应 一、Map接口常用的实现类1、HashMap 基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 2、LinkedHashMap Map 接口的哈希表和链接列表实现，具有可预知的迭代顺序。此实现与 HashMap 的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序通常就是将键插入到映射中的顺序（插入顺序）。注意，如果在映射中重新插入 键，则插入顺序不受影响。 3、Hashtable 最早期的双列集合，1.0版本开始就有 二、Map接口中常用的方法12345678V put(K key, V value) 将指定的值与此映射中的指定键关联（可选操作）。 V remove(Object key) 如果存在一个键的映射关系，则将其从此映射中移除（可选操作）。 V get(Object key) 返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null。 boolean containsKey(Object key) 如果此映射包含指定键的映射关系，则返回 true。 三、Map集合遍历键查找值的方法1、使用keyset12Set&lt;K&gt; keySet() 返回此映射中包含的键的 Set 视图。 步骤： 把Map集合中所有的key取出来存储到Set集合中 使用迭代器或者是增强for遍历Set集合，获取到每一个key 使用get(key)通过key获取value 代码演示： 123456789101112131415161718192021222324252627package Map集合;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Set;public class Demo01 &#123; public static void main(String[] args) &#123; Map&lt;String ,Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"张三\",18); map.put(\"李四\",19); map.put(\"王五\",20); System.out.println(map); //1.把Map集合中所有的key取出来存储到Set集合中 Set&lt;String&gt; set = map.keySet(); //2.使用迭代器遍历Set集合，获取到每一个key Iterator&lt;String&gt; it = set.iterator(); while (it.hasNext())&#123; String key = it.next(); Integer value = map.get(key); System.out.println(key+\"=\"+value); &#125; &#125;&#125; 2、Entry&lt;K,V&gt;键值对对象 map集合遍历的第二种方式，使用Entry对象遍历 步骤： 使用Map集合中的方法entrySet()，把Map集合中多个entry对象取出来，存储到一个Set集合中 遍历Set集合，获取每一个Entry对象 使用Entry对象中的方法getkey()和getValue()获取键与值 1234567891011121314151617181920import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Set;public class Demo02 &#123; public static void main(String[] args) &#123; Map&lt;String ,Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"zs\",18); map.put(\"ls\",19); map.put(\"ww\",20); System.out.println(map); //&#123;ww=20, ls=19, zs=18&#125; for ( Map.Entry&lt;String,Integer&gt; entry : map.entrySet()) &#123; String key = entry.getKey(); Integer value = entry.getValue(); System.out.println(key+\"=\"+value); &#125; &#125;&#125; 四、HashMap存储自定义类型的键值练习：每个学员（姓名，年龄）都有自己的家庭住址，那么，既然有对应关系，则将学生对象和家庭住址存储到map集合中。学生作为键，家庭住址作为值。 注：学生姓名和年龄相同视为同一个学生。 分析：由于基本数据类型都重写了equals和toString方法，所以HashMap可以不存储重复的键， 所以自定义类型中也需要重写equals和toString方法才可以做到相同效果。 Student类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.Objects;public class Student &#123; private String name; private String age; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return Objects.equals(name, student.name) &amp;&amp; Objects.equals(age, student.age); &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", age='\" + age + '\\'' + '&#125;'; &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125; public Student() &#123; &#125; public Student(String name, String age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAge() &#123; return age; &#125; public void setAge(String age) &#123; this.age = age; &#125;&#125; HashMapDemo类 12345678910111213141516171819202122232425import java.util.HashMap;import java.util.Map;import java.util.Set;public class HashMapDemo &#123; public static void main(String[] args) &#123; method01(); &#125; private static void method01 ()&#123; HashMap&lt;Student,String&gt; map = new HashMap&lt;&gt;(); map.put(new Student(\"zs\",\"18\"),\"北京\"); map.put(new Student(\"zs\",\"18\"),\"上海\"); map.put(new Student(\"ls\",\"18\"),\"成都\"); map.put(new Student(\"ww\",\"20\"),\"成都\"); Set&lt;Map.Entry&lt;Student, String&gt;&gt; set = map.entrySet(); for (Map.Entry&lt;Student,String&gt; m : set)&#123; Student key = m.getKey(); String value = m.getValue(); System.out.println(key+\"-----&gt;\"+value); &#125; &#125;&#125; 返回值： 123Student&#123;name='ls', age='18'&#125;-----&gt;成都Student&#123;name='zs', age='18'&#125;-----&gt;上海Student&#123;name='ww', age='20'&#125;-----&gt;成都 五、LinkedHashMap&nbsp;&nbsp;我们知道HashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，那么我们要保证有序，还要速度快怎么办呢？ 在HashMap下面有一个子类LinkedHashMap，它是链表和哈希表组合的一个数据存储结构 123456789101112import java.util.LinkedHashMap;public class LinkedHashMapDemo &#123; public static void main(String[] args) &#123; LinkedHashMap&lt;String,String&gt; linked = new LinkedHashMap&lt;&gt;(); linked.put(\"a\",\"a\"); linked.put(\"c\",\"c\"); linked.put(\"b\",\"b\"); linked.put(\"a\",\"d\"); System.out.println(linked); &#125;&#125; 返回值： 1&#123;a=d, c=c, b=b&#125; 六、Hashtable底层也是一个哈希表，是一个线程安全的集合，是单线程集合，速度慢，不能存储空值。 HashMap：底层是一个哈希表，是一个线程不安全的集合，是多线程的集合，速度快，可以存储空值（其他集合也可以）。 Hashtable和Vector集合一样，在jdk1.2版本后都被更先进的集合（HashMap和ArrayList）取代了。 但是Hashtable的子类Properties到现在一直都在使用，Properties集合是一个唯一和IO流相结合的集合。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"HashSet集合存储自定义类型数据时的踩坑","date":"2020-03-05T08:52:25.334Z","path":"2020/03/05/HashSet集合存储自定义元素踩坑/","text":"问题说明：由于基本数据类型的包装类重写了hashCode方法和equals方法，所以当使用包装类时HashSet集合不存储重复元素，可以当往HashSet集合中存储自定义类型元素时，比如存储学生类，HashSet就无法做到不存储重复元素 解决办法：需要在自定义类中重写hashCode方法和equals方法才能做到HashSet不存储重复元素 如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.Objects;public class Student &#123; private String name; private int age; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return age == student.age &amp;&amp; Objects.equals(name, student.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Set集合","date":"2020-03-05T08:10:56.101Z","path":"2020/03/05/Set集合/","text":"Set集合java.util.Set接口 extends Collection接口 Set接口的特点： 不允许存储重复元素 没有索引，没有带索引的方法，也不能使用普通的for循环遍历 java.util.HashSet集合 implements Set接口 不允许存储重复元素 没有索引，没有带索引的方法，也不能使用普通的for循环遍历 是一个无序集合，存储元素和取出元素的顺序有可能不一致 底层是一个哈希表结构（查询的速度非常快） 1234567891011121314151617181920public class Demo01 &#123; public static void main(String[] args) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); set.add(1); set.add(3); set.add(2); set.add(1); System.out.println(set);//[1, 2, 3] //使用迭代器遍历set集合 Iterator&lt;Integer&gt; it = set.iterator(); while(it.hasNext())&#123; int se = it.next(); System.out.println(se);//1,2,3 &#125; //使用增强for遍历set集合 for(Integer n : set)&#123; System.out.println(n); &#125; &#125;&#125; 哈希值哈希值：是一个十进制的整数，由系统随机给出（就是对象的地址值，是一个逻辑地址，是模拟出来得到的地址，不是数据实际存储的物理地址） 在object类中有一个方法，可以获取对象的哈希值 12int hashCode() 返回该对象的哈希码值。 123456789101112public class gethash &#123; public static void main(String[] args) &#123; Person p1 = new Person(); int h1 = p1.hashCode(); System.out.println(h1); Person p2 = new Person(); int h2 = p2.hashCode(); System.out.println(h2); //注意：对象的地址值其实就是使用的十六进制过后的哈希值 &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"List集合","date":"2020-03-04T14:27:30.053Z","path":"2020/03/04/List集合/","text":"List集合java.util.List接口 extends Collection接口 List接口的特点： 有序的集合，存储元素和取出元素的顺序是一致的 有索引，包含了一些带索引的方法 允许存储重复的元素 List接口中带索引的方法（特有） 1234public void add(int index, E element) 在列表的指定位置插入指定元素（可选操作）。public E get(int index) 返回列表中指定位置的元素。 public E remove(int index) 移除列表中指定位置的元素（可选操作）。 public E set(int index, E element) 用指定元素替换列表中指定位置的元素（可选操作）。 注意：操作索引的时候，一定要防止索引越界异常 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package List集合的使用;import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class Demo01 &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); list.add(\"d\"); //因为ArrayList的父类AbstractList的父类AbstractCollection重写了toString方法 System.out.println(list);//[a, b, c, d]//add方法：在指定索引位置添加元素 list.add(2,\"Ilovejava\"); System.out.println(list);//[a, b, Ilovejava, c, d]//get方法：返回指定位置的元素 String l = list.get(1); System.out.println(l);//b//remove方法：移除列表中指定位置的元素 list.remove(list.size()-1); System.out.println(list);//[a, b, Ilovejava, c]//set方法：用指定元素替换列表中指定位置的元素 list.set(list.size()-1,\"W\"); System.out.println(list);//[a, b, Ilovejava, W] //List集合遍历有3种方式 //1.使用普通for循环 for (int i = 0; i &lt; list.size(); i++) &#123; String li = list.get(i); System.out.println(li); &#125; //2.使用Iterator迭代器 Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext())&#123; String i = it.next(); System.out.println(i); &#125; //3.使用增强for for (String st : list) &#123; System.out.println(st); &#125; &#125;&#125; LinkedList集合java.util.LinkedList集合 implements List接口 底层是一个链表结构：增删快，查询慢 里边包含了大量操作首尾元素的方法 注意：使用LinkedList集合的特有方法，不能使用多态。 LinkedList的常用方法： 12345678910111213141516void addFirst(E e) 将指定元素插入此列表的开头。 void addLast(E e) 将指定元素添加到此列表的结尾。 E getFirst() 返回此列表的第一个元素。 E getLast() 返回此列表的最后一个元素。 E pop() 从此列表所表示的堆栈处弹出一个元素。 void push(E e) 将元素推入此列表所表示的堆栈。 E removeFirst() 移除并返回此列表的第一个元素。 E removeLast() 移除并返回此列表的最后一个元素。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Demo02 &#123; public static void main(String[] args) &#123; show01(); &#125; private static void show01() &#123; LinkedList&lt;String&gt; linked = new LinkedList&lt;&gt;(); //使用add方法添加元素 linked.add(\"a\"); linked.add(\"b\"); linked.add(\"c\"); System.out.println(linked);//[a, b, c] //void addFirst(E e):将指定元素插入此列表的开头。 linked.addFirst(\"IloveJava\"); System.out.println(linked);//[IloveJava, a, b, c] //void addLast(E e):将指定元素添加到此列表的结尾。 linked.addLast(\"com\"); System.out.println(linked);//[IloveJava, a, b, c, com] //E getFirst():返回此列表的第一个元素。 String first = linked.getFirst(); System.out.println(first);//IloveJava //E getLast():返回此列表的最后一个元素。 String last = linked.getLast(); System.out.println(last);//com //E pop():从此列表所表示的堆栈处弹出一个元素。(相当于getFirst()) String pop = linked.pop(); System.out.println(pop);//IloveJava //void push(E e):将元素推入此列表所表示的堆栈。(相当于addFirst()) linked.push(\"cn\"); System.out.println(linked);//[cn, a, b, c, com] //E removeFirst():移除并返回此列表的第一个元素。 String s = linked.removeFirst(); System.out.println(\"被移除的元素是：\"+s);//cn //E removeLast():移除并返回此列表的最后一个元素。 String l = linked.removeLast(); System.out.println(\"被移除的元素是：\"+l);//com &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java字符串的常量池","date":"2020-03-02T11:55:52.171Z","path":"2020/03/02/Java字符串的常量池/","text":"解释如下：","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"ArrayList集合（实现了List接口）","date":"2020-03-02T08:19:01.094Z","path":"2020/03/02/ArrayList集合/","text":"ArrayList集合数组的长度不可以发生改变，但是ArrayList集合的长度是可以随意变化的。 但是ArrayList集合的长度是可以随意变化的。（底层是一个数组结构，查询快，增删慢） 对于ArrayList来说，有一个尖括号&lt;E&gt;代表泛型。 泛型：也就是装在集合当中的所有元素，全部都是统一的什么类型。 注意：泛型只能是引用类型，不能是基本类型。 注意事项： 对于ArrayLIst集合来说，直接打印得到的不是地址值，而是内容。 如果内容是空，得到的是空的中括号：[] 12345678910111213public class Demo2&#123; public static void main(String[] args)&#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); System.out.println(list); list.add(\"张三\") System.out.println(list); list.add(\"李四\"); list.add(\"王五\"); System.out.println(list); &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java-API","date":"2020-03-02T03:03:48.820Z","path":"2020/03/02/java中常用API/","text":"一、什么是API概述：API，应用程序编程接口，java API是一本程序员的字典，是JDK中提供给我们使用的类的说明文档。这些类将底层的代码实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可，所以我们可以通过查询API的方式，来学习Java提供的类，并得知如何使用它们。 1、Scanner类获取键盘输入到程序当中。 Scanner类的功能：可以实现键盘输入数据，到程序中。 如何使用： 导包 1import 包路径.类名称 如果需要使用的目标类，和当前类位于同一个包下，则可以省略导包语句不写。 只有java.lang包下的内容不需要导包，其他的包都需要import语句。 创建 1类名称 对象名 = new 类名称() 使用 1对象名.成员方法名() 2、Random类Random类的功能：生成随机数的类 ​ 如何使用： 导包 1import 包路径.类名称 如果需要使用的目标类，和当前类位于同一个包下，则可以省略导包语句不写。 只有java.lang包下的内容不需要导包，其他的包都需要import语句。 创建 1类名称 对象名 = new 类名称() 使用 1对象名.成员方法名() 其他的类参考Java api 参考文档","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"java内存","date":"2020-02-29T12:06:14.126Z","path":"2020/02/29/java内存划分/","text":"Java内存Java的内存需要划分成5个部分： 1、栈（Stack）：存放的都是方法中的局部变量。方法的运行一定要在栈中运行。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;局部变量：方法的参数，或者是方法{}内部的变量 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用域：一旦超出作用域，立刻从栈内存中消失。 2、堆（Heap）：凡是new出来的东西，都在堆当中。 ​ 堆内存里面的东西都有一个地址值：16进制 ​ 堆内存里面的数据，都有默认值。规则： 如果是整数 默认值为0 如果是浮点数 默认值是0.0 如果是字符 默认值是’\\u0000’ 如果是布尔 默认值是false 如果是引用类型 默认值是null 3、方法区（Method Area）：存储.class相关信息，包含方法的信息。 4、本地方法栈（Native Method Stack）：与操作系统相关。 5、寄存器（pc Register）：与CPU相关。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"idea启动tomcat乱码问题","date":"2020-02-26T08:38:14.939Z","path":"2020/02/26/idea启动tomcat乱码问题/","text":"idea启动tomcat中文乱码解决方法第一次使用idea启动Tomcat的时候控制台可能出现中文乱码的问题 解决方法如下 1.设置项目编码为UTF-8 2.打开idea安装目录的bin目录下进入bin目录找到idea.exe.vmoptions和idea64.exe.vmoptions文件 在这两个文件里面加上如下代码 1-Dfile.encoding&#x3D;UTF-8 在idaeatomcat配置文件会出现该选择 然后重启idea 如果还是有乱码可能是idea的缓存问题 清除缓存重启就好了 清除缓存的方式 重启之后解决了乱码问题","categories":[],"tags":[{"name":"idea","slug":"idea","permalink":"http://yoursite.com/tags/idea/"}]},{"title":"JavaWeb","date":"2020-02-19T13:27:16.795Z","path":"2020/02/19/JavaWeb/","text":"1、Web服务器1.1、技术讲解ASP： 微软：国内最早流行的就是ASP; 在HTML中嵌入了VB的脚本，ASP + COM； 在ASP开发中，基本一个页面都有几千行的业务代码，页面极其混乱 维护成本高 C# IIS php PHP开发速度很快，功能很强大，跨平台，代码很简单 无法承载大访问量的情况（局限性） JSP/Servlet： B/S：浏览器和服务器 C/S：客户端与服务器 sun公司主推的B/S架构 基本Java语言的（所有的大公司，或者一些开源的组件，都是java写的） 可以承载三高问题带来的影响；高并发，高可用，高性能 语法像ASP； 2、Web服务器服务器是一种被动的操作，用来接收用户的请求。 Tomcat服务器 Tomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同开发而成。由于有了Sun 的参与和支持，最新的Servlet 和JSP 规范总是能在Tomcat 中得到体现，Tomcat 5支持最新的Servlet 2.4 和JSP 2.0 规范。因为Tomcat 技术先进、性能稳定，而且免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。 Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。对于一个初学者来说，可以这样认为，当在一台机器上配置好Apache 服务器，可利用它响应HTML（标准通用标记语言下的一个应用）页面的访问请求。实际上Tomcat是Apache 服务器的扩展，但运行时它是独立运行的，所以当你运行tomcat 时，它实际上作为一个与Apache 独立的进程单独运行的。 3、Tomcat3.1、下载Tomcat服务器去Tomcat官网下载Tomcat过后解压即可使用。版本为8.5或者9.0 3.2、Tomcat的启动和部署双击bin文件夹下的startup启动，打开浏览器输入localhost:8080进入Tomcat网页即打开成功。 可能的问题： Java环境变量没有配置 闪退问题：需要配置兼容性 可以修改端口号： conf文件中的server.xml文件，第69行可以修改端 Tomcat：8080 mysql：3306 http：80 https：443 3.3 发布一个Web网站将自己写的网站，放到服务器（Tomcat）中指定的web应用的文件夹（webapps）下，就可以访问了 目录结构： 12345678910111213--webapps：Tomcat服务器的web目录 -ROOT -xxxxxx：自己网站的目录名 -WEB-INF -classes：java程序 -lib：web应用所依赖的jar包 -web.xml ：网站配置文件 -index.html -static -css -style.css -js -img 4、HTTP4.1、什么是HTTPhttp是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。 传输： 文本：html，字符串 超文本：图片，音乐，视频，定位，地图。。。。 80 https：安全的 443 4.2 两个时代 http 1.0 HTTP/1.0：客户端可以与web服务器连接后，只能获得一个web资源，如果请求失败，断开连接 http 2.0 HTTP/1.1：客户端可以与web服务器连接后，获得多个web资源 4.3、Http请求 客户端—发请求—服务器 百度： 12345Request URL: https://www.baidu.com/Request Method: GET Status Code: 200 OK Remote Address: 14.215.177.38:443Referrer Policy: no-referrer-when-downgrade 12345Accept: text/html;Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9Cache-Control: max-age=0Connection: keep-alive 1、请求行 请求行中的请求方式：GET 请求方式：Get，Post，HEAD，Delete，put，tract get：请求能够携带的参数比较少，大小有限制，会在浏览器地址栏显示内容，不安全，但高效。 post：请求能够携带的参数没有限制，大小没有限制，不会在浏览器地址栏显示内容，安全，但不高效。 2、消息头123456Accept: 告诉浏览器，他所支持的数据类型Accept-Encoding: 支持哪种编码格式Accept-Language: 告诉浏览器，他的语言环境Cache-Control: 缓存控制Connection: 告诉浏览器，请求完成是断开还是保持连接HOST：主机 4.4、Http响应 服务器—响应—客户端 百度： 1234Cache-Control: private 缓存控制Connection: keep-alive 保持连接Content-Encoding: gzip 编码Content-Type: text/html;charset=utf-8 类型 1、响应头12345678Accept: 告诉浏览器，他所支持的数据类型Accept-Encoding: 支持哪种编码格式Accept-Language: 告诉浏览器，他的语言环境Cache-Control: 缓存控制Connection: 告诉浏览器，请求完成是断开还是保持连接HOST：主机Refresh：告诉浏览器，多久刷新一次Location：让网页重新定位 2、响应状态码（重点）200：请求响应成功 404：找不到资源 3xx：请求重定向 重定向：你重新到我给你的新位置去 5xx：500服务器代码错误 502网关错误 常见面试题： 当你的浏览器中地址栏输入地址并回车的一瞬间到页面能够展示回来，经历了什么？ 5、Maven1、在javaweb开发中，需要使用大量的jar包，我们手动去导入 2、如何能够让一个东西自动帮我导入和配置这个jar包，由此maven诞生了 5.1、Maven项目架构管理工具我们目前用来导入jar包的 Maven的核心思想：约定大于配置 有约束，不要去违反 Maven会规定好你该如何去编写我们的java代码，必须要按照这个规范来 5.2、下载安装Maven5.3、配置环境变量 M2_HOME maven目录下的bin目录 MAVEN_HOME maven的目录 在系统的path中配置 %MAVEN_HOME%\\bin 5.4、配置阿里云镜像目录中conf文件夹下的setting.xml 镜像：mirrors 作用：加速我们的下载 国内建议使用阿里云的镜像（百度搜） 12345&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;*,!jeecg,!jeecg-snapshots&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt; 5.5、本地仓库目录中conf文件夹下的setting.xml 在本地的仓库，远程的仓库； 建立一个本地仓库： 在maven的目录建立文件夹：maven-repo 修改localrepository中的默认地址，指向maven-repo 5.6、在IDEA中使用Maven1、创建一个Maven项目 idea自动导入包，会去阿里云下载很多的配置文件。都保存在maven-repo本地仓库中。 检查maven配置 可以在如下图片处，配置文件标记 5.7 在IDEA中配置Tomcat5.8、pom.xmlpom.xml是maven的核心配置文件 5.9、存在问题1、maven由于他的约定大于配置，我们之后可能会遇到我们写的配置文件，无法被导出或者生效的问题，解决方案： ​ 在web.xml的build下面加个resources 123456789101112&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 在build中配置resources解决此问题。 2、maven 3.6.2 ​ ​ 解决方法：降低到版本3.6.1 3、Tomcat闪退： ​ 解决方法：配置%JAVA_HOME% 4、IDEA中每次都要重复配置Maven ​ 解决方法：在全局配置中设置，不要设置项目。 5、maven默认web项目中的web.xml的版本问题 ​ 解决方法：直接复制Tomcat中的默认web.xml的配置信息 6、Servletsun公司Servlet接口默认的两个实现类：GenericServlet、HttpServlet 6.1、Servlet简介 Servlet就是sun公司开发动态web的一门技术 sun在这些API中提供一个借口叫作：Servlet，如果你想开发一个Servlet程序，只需要完成两个小步骤： 编写一个类：实现Servlet接口 把开发好的Java类部署到web服务器中。 把实现了Servlet接口的Java程序叫作，Servlet 6.2、HttpServlet1、构建一个普通的Maven项目，删掉里面的src项目，以后我们的学习就在这个项目里面建立Moudel；这个空的工程就是Maven主工程； 2、关于Servlet父子工程 父项目的pom.xml中会有 123&lt;modules&gt; &lt;module&gt;servlet-01&lt;/module&gt;&lt;/modules&gt; 父项目的pom.xml中会有 12345&lt;parent&gt; &lt;artifactId&gt;javaweb-02-servlet&lt;/artifactId&gt; &lt;groupId&gt;com.ght&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/parent&gt; 3、Maven环境优化 修改web.xml为最新版本 将maven的结构搭建完整 4、编写一个Servlet程序 编写一个普通类 实现Servlet接口： 12345678910111213public class HelloServlet extends HttpServlet &#123; //由于get或者post只是请求实现的不同的方式，可以相互调用，业务逻辑都一样； @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; PrintWriter writer = resp.getWriter(); writer.print(\"hello，Servlet\"); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; 5、编写Servlet的映射 ​ 为什么需要映射：因为写的是Java程序，但是要通过浏览器访问，而浏览器需要连接web服务器，所以我们需要在web服务中注册我们写的Servlet 12345678910&lt;!--注册Servlet--&gt;&lt;servlet&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;servlet-class&gt;com.ght.servlet.HelloServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 6、配置Tomcat 7、启动测试 6.3、Mapping问题一个Servlet可以指定一个映射路径 一个Servlet可以指定多个映射路径 一个Servlet可以指定通用映射路径 可以自定义后缀实现请求映射 *.xxxx。 注：不能xxx/*.xxxx 优先级问题 指定了固有的映射路径优先级最高，如果找不到就会走默认的处理请求 6.4、ServletContextweb容器在启动的时候，它会为每个web 程序都创建一个ServletContext对象，它代表当前的web应用： 获取context对象： 1ServletContext context = this.getServletContext(); 1、共享数据我在这个Servlet中保存的数据，可以在另外一个servlet中拿到 setcontext.java 12345678910111213141516171819202122232425package com.ght.servlet;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class setcontext extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setContentType(\"text/html\"); resp.setCharacterEncoding(\"utf-8\"); ServletContext context = this.getServletContext(); String username = \"小明\"; context.setAttribute(\"username\",username); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; getcontext.java 123456789101112131415161718192021222324252627package com.ght.servlet;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.Writer;public class getcontext extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setContentType(\"text/html\"); resp.setCharacterEncoding(\"utf-8\"); ServletContext context = this.getServletContext(); String username = (String)context.getAttribute(\"username\"); resp.getWriter().print(\"名字\"+username); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; web.xml 1234567891011121314151617181920212223242526272829303132&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" version=\"3.1\" metadata-complete=\"true\"&gt; &lt;servlet&gt; &lt;servlet-name&gt;set&lt;/servlet-name&gt; &lt;servlet-class&gt;com.ght.servlet.setcontext&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;set&lt;/servlet-name&gt; &lt;url-pattern&gt;/set&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;get&lt;/servlet-name&gt; &lt;servlet-class&gt;com.ght.servlet.getcontext&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;get&lt;/servlet-name&gt; &lt;url-pattern&gt;/get&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 2、获取初始化参数12345678910111213141516171819202122package com.ght.servlet;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class servletDemo03 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; ServletContext context = this.getServletContext(); String url = context.getInitParameter(\"url\"); resp.getWriter().print(url); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; web.xml 12345678&lt;servlet&gt; &lt;servlet-name&gt;gp&lt;/servlet-name&gt; &lt;servlet-class&gt;com.ght.servlet.servletDemo03&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;gp&lt;/servlet-name&gt; &lt;url-pattern&gt;/gp&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 3、请求转发浏览器地址不会改变 转发到/gp，/gp指向ServletDemo03 123456789101112131415161718192021package com.ght.servlet;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class ServletDemo04 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; ServletContext context = this.getServletContext(); context.getRequestDispatcher(\"/gp\").forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; web.xml 12345678&lt;servlet&gt; &lt;servlet-name&gt;sd4&lt;/servlet-name&gt; &lt;servlet-class&gt;com.ght.servlet.ServletDemo04&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;sd4&lt;/servlet-name&gt; &lt;url-pattern&gt;/sd4&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 4、读取配置文件​ properties 在Java目录下新建properties 在resources目录下新建properties 发现：都被打包到了同一个路径下：classes，我们称这个路径为classpath 使用流将读取配置文件中的信息 123456789101112131415161718192021222324252627package com.ght.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.InputStream;import java.util.Properties;public class ServletDemo05 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; InputStream is = this.getServletContext().getResourceAsStream(\"/WEB-INF/classes/aa.properties\"); Properties prop = new Properties(); prop.load(is); String user = prop.getProperty(\"username\"); String pass = prop.getProperty(\"password\"); resp.getWriter().print(user+\":\"+pass); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; aa.properties 12username=rootpassword=123456 6.5、HttpServletResponseWeb服务器接受到客户端的http请求，针对这个请求，分别创建一个代表请求的HttpServletRequest对象，代表响应的一个HttpServletResponse； 如果要获取客户端请求过来的参数：找HttpServletRequest 如果要给客户端响应一些信息：找HttpServletResponse 1、简单分类负责向浏览器发送数据的方法 12ServletOutputStream getOutputStream() throws IOException;PrintWriter getWriter() throws IOException; 负责向浏览器发送响应头的方法 12345678910111213141516171819void setCharacterEncoding(String var1);void setContentLength(int var1);void setContentLengthLong(long var1);void setContentType(String var1); void setDateHeader(String var1, long var2);void addDateHeader(String var1, long var2);void setHeader(String var1, String var2);void addHeader(String var1, String var2);void setIntHeader(String var1, int var2);void addIntHeader(String var1, int var2); 2、下载文件1、下载文件 要获取下载文件的路径 下载的文件名 设置让浏览器支持下载我们需要的东西 获取下载文件的输入流 创建缓冲区 获取OutputStream对象 将FileOutputStream流写入buffer缓冲区 使用OutputStream将缓冲区中的数据输出到客户端 12345678910111213141516171819202122232425262728293031323334353637383940package com.ght.servlet;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.FileInputStream;import java.io.IOException;import java.net.URLEncoder;public class FileServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1. 要获取下载文件的路径 String filepath = \"D:\\\\environment\\\\javaweb-02-servlet\\\\response\\\\src\\\\main\\\\resources\\\\图片.png\"; //2. 下载的文件名 String fileName = filepath.substring(filepath.lastIndexOf(\"\\\\\")+1); //3. 设置让浏览器支持下载(\"Content-Disposition\")我们需要的东西,设置编码防止中文文件名乱码的情况 resp.setHeader(\"Content-Disposition\",\"attachment;filename=\"+URLEncoder.encode(fileName,\"UTF-8\")); //4. 获取下载文件的输入流 FileInputStream in = new FileInputStream(filepath); //5. 创建缓冲区 int len = 0; byte[] buffer = new byte[1024]; //6. 获取OutputStream对象 ServletOutputStream out = resp.getOutputStream(); //7. 将FileOutputStream流写入buffer缓冲区,使用OutputStream将缓冲区中的数据输出到客户端 while((len=in.read(buffer)) != -1) &#123; out.write(buffer, 0, len); &#125; in.close(); out.close(); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; 3、验证码功能验证码怎么来的？ 现在前后端分离时代。 前端实现 后端实现，需要用到Java的图片类，生产一个图片 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.ght.servlet;import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.awt.*;import java.awt.image.BufferedImage;import java.io.IOException;import java.util.Random;public class ImageServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //如何让浏览器3秒刷新一次 resp.setHeader(\"refresh\",\"3\"); //在内存中创建一个图片 BufferedImage image = new BufferedImage(80,20,BufferedImage.TYPE_INT_RGB); //得到图片 Graphics2D g = (Graphics2D)image.getGraphics();//笔 //设置背景图片颜色 g.setColor(Color.white); g.fillRect(0,0,80,20); //给图片写数据 g.setColor(Color.BLUE); g.setFont(new Font(null,Font.BOLD,20)); g.drawString(makeNum(),0,20); //告诉浏览器，这个请求用图片的方式打开 resp.setContentType(\"image/jpeg\"); //网站存在缓存，不让浏览器缓存 resp.setDateHeader(\"expires\",-1); resp.setHeader(\"Cache-Control\",\"no-cache\"); resp.setHeader(\"Pragme\",\"no-cache\"); //把图片写在浏览器 ImageIO.write(image,\"jpg\",resp.getOutputStream()); &#125; private String makeNum()&#123; Random random = new Random(); String num = random.nextInt(9999999)+\"\"; StringBuffer sb = new StringBuffer(); //如果生成的数没有7位，就用0补全 for (int i = 0; i &lt; 7-num.length() ; i++) &#123; sb.append(\"0\"); &#125; num = sb.toString()+num; return num; &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; 不要忘记在web.xml中注册 4、实现重定向（重点） 一个web资源B收到客户端A请求后，B会通知A客户端去访问另一个web资源C，这个过程叫重定向。 常见场景： 用户登录（登录成功后请求另一个界面） index.jsp 12345678910111213&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Login&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"/login\" method=\"post\"&gt; 账号：&lt;input type=\"text\" name=\"username\"&gt; 密码：&lt;input type=\"password\" name=\"password\"&gt; &lt;input type=\"submit\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; responsetest.java 12345678910111213141516171819202122package com.ght.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class Responsetest extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String username = req.getParameter(\"username\"); String password = req.getParameter(\"password\"); resp.sendRedirect(\"/success.jsp\"); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; 面试题：请你聊聊重定向和转发的区别？ 相同点： 页面都会实现跳转 不同点： 请求转发的时候，url不会产生变化； 重定向的时候，url地址栏会发生变化； 6.6、HttpServletRequest获取前端参数的值、请求转发12345678910111213141516171819202122232425262728293031package com.ght.servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.Arrays;public class RequestTest extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.setCharacterEncoding(\"utf-8\"); resp.setCharacterEncoding(\"utf-8\"); String username = req.getParameter(\"username\"); String password = req.getParameter(\"password\"); String[] hobbies = req.getParameterValues(\"hobbies\"); System.out.println(username); System.out.println(password); System.out.println(Arrays.toString(hobbies)); //请求转发这里的/是代表当前的web项目 req.getRequestDispatcher(\"/success.jsp\").forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; 1234567891011121314151617&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;login&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"/login\" method=\"post\"&gt; 用户名：&lt;input name=\"username\"&gt; 密码：&lt;input type=\"password\" name=\"password\"&gt; &lt;input type=\"checkbox\" name=\"hobbies\" value=\"唱歌\"&gt;唱歌 &lt;input type=\"checkbox\" name=\"hobbies\" value=\"电影\"&gt;电影 &lt;input type=\"checkbox\" name=\"hobbies\" value=\"读书\"&gt;读书 &lt;input type=\"submit\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"Javaweb","slug":"Javaweb","permalink":"http://yoursite.com/tags/Javaweb/"}]},{"title":"Java面向对象","date":"2020-02-18T00:50:06.074Z","path":"2020/02/18/Java面向对象/","text":"1.概述面向对象编程，是一种通过对象的方式，把现实世界映射到计算机模型的一种编程方法。现实世界中，我们定义了“人”这种抽象概念，而具体的人则是“小明”、“小红”、“小军”等一个个具体的人。所以，“人”可以定义为一个类（class），而具体的人则是实例（instance）：现实世界 计算机模型 Java代码 人 类 / class class Person { }小明 实例 / ming Person ming = new Person()小红 实例 / hong Person hong = new Person()小军 实例 / jun Person jun = new Person() 定义class在Java中，创建一个类，例如，给这个类命名为Person，就是定义一个class： 1234class Person &#123; public String name; public int age;&#125; 一个class可以包含多个字段（field），字段用来描述一个类的特征。上面的Person类，我们定义了两个字段，一个是String类型的字段，命名为name，一个是int类型的字段，命名为age。public是用来修饰字段的，它表示这个字段可以被外部访问。 创建实例定义了class，只是定义了对象模版，而要根据对象模版创建出真正的对象实例，必须用new操作符。new操作符可以创建一个实例，然后，我们需要定义一个引用类型的变量来指向这个实例： Person ming = new Person();上述代码创建了一个Person类型的实例，并通过变量ming指向它。注意区分Person ming是定义Person类型的变量ming，而new Person()是创建Person实例。 有了指向这个实例的变量，我们就可以通过这个变量来操作实例。访问实例变量可以用变量.字段，例如： 1234567ming.name &#x3D; &quot;Xiao Ming&quot;; &#x2F;&#x2F; 对字段name赋值ming.age &#x3D; 12; &#x2F;&#x2F; 对字段age赋值System.out.println(ming.name); &#x2F;&#x2F; 访问字段namePerson hong &#x3D; new Person();hong.name &#x3D; &quot;Xiao Hong&quot;;hong.age &#x3D; 15; 上述两个变量分别指向两个不同的实例，它们在内存中的结构如下： 123456789101112 ┌──────────────────┐ming ──────&gt;│Person instance │ ├──────────────────┤ │name &#x3D; &quot;Xiao Ming&quot;│ │age &#x3D; 12 │ └──────────────────┘ ┌──────────────────┐hong ──────&gt;│Person instance │ ├──────────────────┤ │name &#x3D; &quot;Xiao Hong&quot;│ │age &#x3D; 15 │ └──────────────────┘ 两个instance拥有class定义的name和age字段，且各自都有一份独立的数据，互不干扰。 小结在OOP中，class和instance是“模版”和“实例”的关系；定义class就是定义了一种数据类型，对应的instance是这种数据类型的实例；class定义的field，在每个instance都会拥有各自的field，且互不干扰；通过new操作符创建新的instance，然后用变量指向它，即可通过变量来引用这个instance；访问实例字段的方法是变量名.字段名；指向instance的变量都是引用变量。 2.方法一个class可以包含多个field，例如，我们给Person类就定义了两个field： 1234class Person &#123; public String name; public int age;&#125; 但是，直接把field用public暴露给外部可能会破坏封装性。比如，代码可以这样写：Person ming = new Person();ming.name = “Xiao Ming”;ming.age = -99; // age设置为负数 显然，直接操作field，容易造成逻辑混乱。为了避免外部代码直接去访问field，我们可以用private修饰field，拒绝外部访问: 1234class Person &#123; private String name; private int age;&#125; 把field从public改成private，外部代码不能访问这些field，那我们定义这些field有什么用？怎么才能给它赋值？怎么才能读取它的值？所以我们需要使用方法（method）来让外部代码可以间接修改field： 1234567891011121314151617181920212223242526272829303132public class Main &#123; public static void main(String[] args) &#123; Person ming = new Person(); ming.setName(\"Xiao Ming\"); // 设置name ming.setAge(12); // 设置age System.out.println(ming.getName() + \", \" + ming.getAge()); &#125;&#125;class Person &#123; private String name; private int age; public String getName() &#123; return this.name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return this.age; &#125; public void setAge(int age) &#123; if (age &lt; 0 || age &gt; 100) &#123; throw new IllegalArgumentException(\"invalid age value\"); &#125; this.age = age; &#125;&#125; 虽然外部代码不能直接修改private字段，但是，外部代码可以调用方法setName()和setAge()来间接修改private字段。在方法内部，我们就有机会检查参数对不对。比如，setAge()就会检查传入的参数，参数超出了范围，直接报错。这样，外部代码就没有任何机会把age设置成不合理的值。同样，外部代码不能直接读取private字段，但可以通过getName()和getAge()间接获取private字段的值。所以，一个类通过定义方法，就可以给外部代码暴露一些操作的接口，同时，内部自己保证逻辑一致性。调用方法的语法是实例变量.方法名(参数);。一个方法调用就是一个语句，所以不要忘了在末尾加;。例如：ming.setName(“Xiao Ming”);。 定义方法从上面的代码可以看出，定义方法的语法是： 1234修饰符 方法返回类型 方法名(方法参数列表) &#123; 若干方法语句; return 方法返回值;&#125; 方法返回值通过return语句实现，如果没有返回值，返回类型设置为void，可以省略return。 private方法 有public方法，自然就有private方法。和private字段一样，private方法不允许外部调用，那我们定义private方法有什么用？定义private方法的理由是内部方法是可以调用private方法的。例如： 12345678910111213141516171819202122232425public class Main &#123; public static void main(String[] args) &#123; Person ming &#x3D; new Person(); ming.setBirth(2008); System.out.println(ming.getAge()); &#125;&#125;class Person &#123; private String name; private int birth; public void setBirth(int birth) &#123; this.birth &#x3D; birth; &#125; public int getAge() &#123; return calcAge(2019); &#x2F;&#x2F; 调用private方法 &#125; &#x2F;&#x2F; private方法: private int calcAge(int currentYear) &#123; return currentYear - this.birth; &#125;&#125; 观察上述代码，calcAge()是一个private方法，外部代码无法调用，但是，内部方法getAge()可以调用它。此外，我们还注意到，这个Person类只定义了birth字段，没有定义age字段，获取age时，通过方法getAge()返回的是一个实时计算的值，并非存储在某个字段的值。这说明方法可以封装一个类的对外接口，调用方不需要知道也不关心Person实例在内部到底有没有age字段。 this变量在方法内部，可以使用一个隐含的变量this，它始终指向当前实例。因此，通过this.field就可以访问当前实例的字段。如果没有命名冲突，可以省略this。例如： 1234567class Person &#123; private String name; public String getName() &#123; return name; // 相当于this.name &#125;&#125; 但是，如果有局部变量和字段重名，那么局部变量优先级更高，就必须加上this： 1234567class Person &#123; private String name; public void setName(String name) &#123; this.name = name; // 前面的this不可少，少了就变成局部变量name了 &#125;&#125; 方法参数方法可以包含0个或任意个参数。方法参数用于接收传递给方法的变量值。调用方法时，必须严格按照参数的定义一一传递。例如： 123456class Person &#123; ... public void setNameAndAge(String name, int age) &#123; ... &#125;&#125; 调用这个setNameAndAge()方法时，必须有两个参数，且第一个参数必须为String，第二个参数必须为int：Person ming = new Person();ming.setNameAndAge(“Xiao Ming”); // 编译错误：参数个数不对ming.setNameAndAge(12, “Xiao Ming”); // 编译错误：参数类型不对 可变参数可变参数用类型…定义，可变参数相当于数组类型： 1234567class Group &#123; private String[] names; public void setNames(String... names) &#123; this.names &#x3D; names; &#125;&#125; 上面的setNames()就定义了一个可变参数。调用时，可以这么写： 12345Group g &#x3D; new Group();g.setNames(&quot;Xiao Ming&quot;, &quot;Xiao Hong&quot;, &quot;Xiao Jun&quot;); &#x2F;&#x2F; 传入3个Stringg.setNames(&quot;Xiao Ming&quot;, &quot;Xiao Hong&quot;); &#x2F;&#x2F; 传入2个Stringg.setNames(&quot;Xiao Ming&quot;); &#x2F;&#x2F; 传入1个Stringg.setNames(); &#x2F;&#x2F; 传入0个String 参数绑定调用方把参数传递给实例方法时，调用时传递的值会按参数位置一一绑定。那什么是参数绑定？我们先观察一个基本类型参数的传递： 12345678910111213141516171819202122public class Main &#123; public static void main(String[] args) &#123; Person p = new Person(); int n = 15; // n的值为15 p.setAge(n); // 传入n的值 System.out.println(p.getAge()); // 15 n = 20; // n的值改为20 System.out.println(p.getAge()); // 15还是20? &#125;&#125;class Person &#123; private int age; public int getAge() &#123; return this.age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 运行代码，从结果可知，修改外部的局部变量n，不影响实例p的age字段，原因是setAge()方法获得的参数，复制了n的值，因此，p.age和局部变量n互不影响。结论：基本类型参数的传递，是调用方值的复制。双方各自的后续修改，互不影响。 我们再看一个传递引用参数的例子： 12345678910111213141516171819202122public class Main &#123; public static void main(String[] args) &#123; Person p = new Person(); String[] fullname = new String[] &#123; \"Homer\", \"Simpson\" &#125;; p.setName(fullname); // 传入fullname数组 System.out.println(p.getName()); // \"Homer Simpson\" fullname[0] = \"Bart\"; // fullname数组的第一个元素修改为\"Bart\" System.out.println(p.getName()); // \"Homer Simpson\"还是\"Bart Simpson\"? &#125;&#125;class Person &#123; private String[] name; public String getName() &#123; return this.name[0] + \" \" + this.name[1]; &#125; public void setName(String[] name) &#123; this.name = name; &#125;&#125; 注意到setName()的参数现在是一个数组。一开始，把fullname数组传进去，然后，修改fullname数组的内容，结果发现，实例p的字段p.name也被修改了！结论：引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方 小结方法可以让外部代码安全地访问实例字段；方法是一组执行语句，并且可以执行任意逻辑；方法内部遇到return时返回，void表示不返回任何值（注意和返回null不同）；外部代码通过public方法操作实例，内部代码可以调用private方法；理解方法的参数绑定。 3.方法重载在一个类中，我们可以定义多个方法。如果有一系列方法，它们的功能都是类似的，只有参数有所不同，那么，可以把这一组方法名做成同名方法。例如，在Hello类中，定义多个hello()方法： 1234567891011121314151617class Hello &#123; public void hello() &#123; System.out.println(\"Hello, world!\"); &#125; public void hello(String name) &#123; System.out.println(\"Hello, \" + name + \"!\"); &#125; public void hello(String name, int age) &#123; if (age &lt; 18) &#123; System.out.println(\"Hi, \" + name + \"!\"); &#125; else &#123; System.out.println(\"Hello, \" + name + \"!\"); &#125; &#125;&#125; 这种方法名相同，但各自的参数不同，称为方法重载（Overload）。注意：方法重载的返回值类型通常都是相同的。方法重载的目的是，功能类似的方法使用同一名字，更容易记住，因此，调用起来更简单。 小结方法重载是指多个方法的方法名相同，但各自的参数不同；重载方法应该完成类似的功能，参考String的indexOf()；重载方法返回值类型应该相同。 4.构造方法创建实例的时候，我们经常需要同时初始化这个实例的字段，例如： 123Person ming &#x3D; new Person();ming.setName(&quot;小明&quot;);ming.setAge(12); 初始化对象实例需要3行代码，而且，如果忘了调用setName()或者setAge()，这个实例内部的状态就是不正确的。能否在创建对象实例时就把内部字段全部初始化为合适的值？完全可以。这时，我们就需要构造方法。创建实例的时候，实际上是通过构造方法来初始化实例的。我们先来定义一个构造方法，能在创建Person实例的时候，一次性传入name和age，完成初始化： 12345678910111213141516171819202122232425public class Main &#123; public static void main(String[] args) &#123; Person p &#x3D; new Person(&quot;Xiao Ming&quot;, 15); System.out.println(p.getName()); System.out.println(p.getAge()); &#125;&#125;class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.name &#x3D; name; this.age &#x3D; age; &#125; public String getName() &#123; return this.name; &#125; public int getAge() &#123; return this.age; &#125;&#125; 由于构造方法是如此特殊，所以构造方法的名称就是类名。构造方法的参数没有限制，在方法内部，也可以编写任意语句。但是，和普通方法相比，构造方法没有返回值（也没有void），调用构造方法，必须用new操作符。 默认构造方法是不是任何class都有构造方法？是的。那前面我们并没有为Person类编写构造方法，为什么可以调用new Person()？原因是如果一个类没有定义构造方法，编译器会自动为我们生成一个默认构造方法，它没有参数，也没有执行语句，类似这样： 1234class Person &#123; public Person() &#123; &#125;&#125; 要特别注意的是，如果我们自定义了一个构造方法，那么，编译器就不再自动创建默认构造方法 如果既要能使用带参数的构造方法，又想保留不带参数的构造方法，那么只能把两个构造方法都定义出来： 123456789101112131415161718192021222324252627public class Main &#123; public static void main(String[] args) &#123; Person p1 &#x3D; new Person(&quot;Xiao Ming&quot;, 15); &#x2F;&#x2F; 既可以调用带参数的构造方法 Person p2 &#x3D; new Person(); &#x2F;&#x2F; 也可以调用无参数构造方法 &#125;&#125;class Person &#123; private String name; private int age; public Person() &#123; &#125; public Person(String name, int age) &#123; this.name &#x3D; name; this.age &#x3D; age; &#125; public String getName() &#123; return this.name; &#125; public int getAge() &#123; return this.age; &#125;&#125; 没有在构造方法中初始化字段时，引用类型的字段默认是null，数值类型的字段用默认值，int类型默认值是0，布尔类型默认值是false： 1234567class Person &#123; private String name; &#x2F;&#x2F; 默认初始化为null private int age; &#x2F;&#x2F; 默认初始化为0 public Person() &#123; &#125;&#125; 也可以对字段直接进行初始化： 1234class Person &#123; private String name &#x3D; &quot;Unamed&quot;; private int age &#x3D; 10;&#125; 那么问题来了：既对字段进行初始化，又在构造方法中对字段进行初始化： 123456789class Person &#123; private String name &#x3D; &quot;Unamed&quot;; private int age &#x3D; 10; public Person(String name, int age) &#123; this.name &#x3D; name; this.age &#x3D; age; &#125;&#125; 当我们创建对象的时候，new Person(“Xiao Ming”, 12)得到的对象实例，字段的初始值是啥？在Java中，创建对象实例的时候，按照如下顺序进行初始化：先初始化字段，例如，int age = 10;表示字段初始化为10，double salary;表示字段默认初始化为0，String name;表示引用类型字段默认初始化为null；执行构造方法的代码进行初始化。因此，构造方法的代码由于后运行，所以，new Person(“Xiao Ming”, 12)的字段值最终由构造方法的代码确定。 多构造方法可以定义多个构造方法，在通过new操作符调用的时候，编译器通过构造方法的参数数量、位置和类型自动区分： 1234567891011121314151617class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.name &#x3D; name; this.age &#x3D; age; &#125; public Person(String name) &#123; this.name &#x3D; name; this.age &#x3D; 12; &#125; public Person() &#123; &#125;&#125; 如果调用new Person(“Xiao Ming”, 20);，会自动匹配到构造方法public Person(String, int)。如果调用new Person(“Xiao Ming”);，会自动匹配到构造方法public Person(String)。如果调用new Person();，会自动匹配到构造方法public Person()。一个构造方法可以调用其他构造方法，这样做的目的是便于代码复用。调用其他构造方法的语法是this(…)： 1234567891011121314151617class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.name &#x3D; name; this.age &#x3D; age; &#125; public Person(String name) &#123; this(name, 18); &#x2F;&#x2F; 调用另一个构造方法Person(String, int) &#125; public Person() &#123; this(&quot;Unnamed&quot;); &#x2F;&#x2F; 调用另一个构造方法Person(String) &#125;&#125; 小结实例在创建时通过new操作符会调用其对应的构造方法，构造方法用于初始化实例；没有定义构造方法时，编译器会自动创建一个默认的无参数构造方法；可以定义多个构造方法，编译器根据参数自动判断；可以在一个构造方法内部调用另一个构造方法，便于代码复用。 5.继承在前面的章节中，我们已经定义了Person类： 123456789class Person &#123; private String name; private int age; public String getName() &#123;...&#125; public void setName(String name) &#123;...&#125; public int getAge() &#123;...&#125; public void setAge(int age) &#123;...&#125;&#125; 现在，假设需要定义一个Student类，字段如下： 123456789101112class Student &#123; private String name; private int age; private int score; public String getName() &#123;...&#125; public void setName(String name) &#123;...&#125; public int getAge() &#123;...&#125; public void setAge(int age) &#123;...&#125; public int getScore() &#123; … &#125; public void setScore(int score) &#123; … &#125;&#125; 仔细观察，发现Student类包含了Person类已有的字段和方法，只是多出了一个score字段和相应的getScore()、setScore()方法。能不能在Student中不要写重复的代码？这个时候，继承就派上用场了。 继承是面向对象编程中非常强大的一种机制，它首先可以复用代码。当我们让Student从Person继承时，Student就获得了Person的所有功能，我们只需要为Student编写新增的功能。Java使用extends关键字来实现继承： 123456789101112131415161718class Person &#123; private String name; private int age; public String getName() &#123;...&#125; public void setName(String name) &#123;...&#125; public int getAge() &#123;...&#125; public void setAge(int age) &#123;...&#125;&#125;class Student extends Person &#123; &#x2F;&#x2F; 不要重复name和age字段&#x2F;方法, &#x2F;&#x2F; 只需要定义新增score字段&#x2F;方法: private int score; public int getScore() &#123; … &#125; public void setScore(int score) &#123; … &#125;&#125; 可见，通过继承，Student只需要编写额外的功能，不再需要重复代码。在OOP的术语中，我们把Person称为超类（super class），父类（parent class），基类（base class），把Student称为子类（subclass），扩展类（extended class）。 继承树注意到我们在定义Person的时候，没有写extends。在Java中，没有明确写extends的类，编译器会自动加上extends Object。所以，任何类，除了Object，都会继承自某个类。下图是Person、Student的继承树： 12345678910111213┌───────────┐│ Object │└───────────┘ ▲ │┌───────────┐│ Person │└───────────┘ ▲ │┌───────────┐│ Student │└───────────┘ Java只允许一个class继承自一个类，因此，一个类有且仅有一个父类。只有Object特殊，它没有父类。类似的，如果我们定义一个继承自Person的Teacher，它们的继承树关系如下： 1234567891011121314 ┌───────────┐ │ Object │ └───────────┘ ▲ │ ┌───────────┐ │ Person │ └───────────┘ ▲ ▲ │ │ │ │┌───────────┐ ┌───────────┐│ Student │ │ Teacher │└───────────┘ └───────────┘ protected继承有个特点，就是子类无法访问父类的private字段或者private方法。例如，Student类就无法访问Person类的name和age字段： 12345678910class Person &#123; private String name; private int age;&#125;class Student extends Person &#123; public String hello() &#123; return &quot;Hello, &quot; + name; &#x2F;&#x2F; 编译错误：无法访问name字段 &#125;&#125; 这使得继承的作用被削弱了。为了让子类可以访问父类的字段，我们需要把private改为protected。用protected修饰的字段可以被子类访问： 12345678910class Person &#123; protected String name; protected int age;&#125;class Student extends Person &#123; public String hello() &#123; return &quot;Hello, &quot; + name; &#x2F;&#x2F; OK! &#125;&#125; 因此，protected关键字可以把字段和方法的访问权限控制在继承树内部，一个protected字段和方法可以被其子类，以及子类的子类所访问，后面我们还会详细讲解。 supersuper关键字表示父类（超类）。子类引用父类的字段时，可以用super.fieldName。例如： 12345class Student extends Person &#123; public String hello() &#123; return &quot;Hello, &quot; + super.name; &#125;&#125; 实际上，这里使用super.name，或者this.name，或者name，效果都是一样的。编译器会自动定位到父类的name字段。但是，在某些时候，就必须使用super。我们来看一个例子： 1234567891011121314151617181920212223public class Main &#123; public static void main(String[] args) &#123; Student s &#x3D; new Student(&quot;Xiao Ming&quot;, 12, 89); &#125;&#125;class Person &#123; protected String name; protected int age; public Person(String name, int age) &#123; this.name &#x3D; name; this.age &#x3D; age; &#125;&#125;class Student extends Person &#123; protected int score; public Student(String name, int age, int score) &#123; this.score &#x3D; score; &#125;&#125; 运行上面的代码，会得到一个编译错误，大意是在Student的构造方法中，无法调用Person的构造方法。这是因为在Java中，任何class的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句super();，所以，Student类的构造方法实际上是这样： 12345678class Student extends Person &#123; protected int score; public Student(String name, int age, int score) &#123; super(); &#x2F;&#x2F; 自动调用父类的构造方法 this.score &#x3D; score; &#125;&#125; 但是，Person类并没有无参数的构造方法，因此，编译失败。解决方法是调用Person类存在的某个构造方法。例如： 12345678class Student extends Person &#123; protected int score; public Student(String name, int age, int score) &#123; super(name, age); &#x2F;&#x2F; 调用父类的构造方法Person(String, int) this.score &#x3D; score; &#125;&#125; 这样就可以正常编译了！因此我们得出结论：如果父类没有默认的构造方法，子类就必须显式调用super()并给出参数以便让编译器定位到父类的一个合适的构造方法。这里还顺带引出了另一个问题：即子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。 向上转型如果一个引用变量的类型是Student，那么它可以指向一个Student类型的实例： 1Student s &#x3D; new Student(); 如果一个引用类型的变量是Person，那么它可以指向一个Person类型的实例： 1Person p &#x3D; new Person(); 现在问题来了：如果Student是从Person继承下来的，那么，一个引用类型为Person的变量，能否指向Student类型的实例？ 1Person p &#x3D; new Student(); &#x2F;&#x2F; ??? 测试一下就可以发现，这种指向是允许的！这是因为Student继承自Person，因此，它拥有Person的全部功能。Person类型的变量，如果指向Student类型的实例，对它进行操作，是没有问题的！这种把一个子类类型安全地变为父类类型的赋值，被称为向上转型（upcasting）。向上转型实际上是把一个子类型安全地变为更加抽象的父类型： 1234Student s &#x3D; new Student();Person p &#x3D; s; &#x2F;&#x2F; upcasting, okObject o1 &#x3D; p; &#x2F;&#x2F; upcasting, okObject o2 &#x3D; s; &#x2F;&#x2F; upcasting, ok 注意到继承树是Student &gt; Person &gt; Object，所以，可以把Student类型转型为Person，或者更高层次的Object。 向下转型和向上转型相反，如果把一个父类类型强制转型为子类类型，就是向下转型（downcasting）。例如： 1234Person p1 &#x3D; new Student(); &#x2F;&#x2F; upcasting, okPerson p2 &#x3D; new Person();Student s1 &#x3D; (Student) p1; &#x2F;&#x2F; okStudent s2 &#x3D; (Student) p2; &#x2F;&#x2F; runtime error! ClassCastException! 如果测试上面的代码，可以发现：Person类型p1实际指向Student实例，Person类型变量p2实际指向Person实例。在向下转型的时候，把p1转型为Student会成功，因为p1确实指向Student实例，把p2转型为Student会失败，因为p2的实际类型是Person，不能把父类变为子类，因为子类功能比父类多，多的功能无法凭空变出来。因此，向下转型很可能会失败。失败的时候，Java虚拟机会报ClassCastException。为了避免向下转型出错，Java提供了instanceof操作符，可以先判断一个实例究竟是不是某种类型： 12345678910Person p &#x3D; new Person();System.out.println(p instanceof Person); &#x2F;&#x2F; trueSystem.out.println(p instanceof Student); &#x2F;&#x2F; falseStudent s &#x3D; new Student();System.out.println(s instanceof Person); &#x2F;&#x2F; trueSystem.out.println(s instanceof Student); &#x2F;&#x2F; trueStudent n &#x3D; null;System.out.println(n instanceof Student); &#x2F;&#x2F; false 区分继承和组合在使用继承时，我们要注意逻辑一致性。考察下面的Book类： 12345class Book &#123; protected String name; public String getName() &#123;...&#125; public void setName(String name) &#123;...&#125;&#125; 这个Book类也有name字段，那么，我们能不能让Student继承自Book呢？ 123class Student extends Book &#123; protected int score;&#125; 显然，从逻辑上讲，这是不合理的，Student不应该从Book继承，而应该从Person继承。究其原因，是因为Student是Person的一种，它们是is关系，而Student并不是Book。实际上Student和Book的关系是has关系。具有has关系不应该使用继承，而是使用组合，即Student可以持有一个Book实例： 1234class Student extends Person &#123; protected Book book; protected int score;&#125; 因此，继承是is关系，组合是has关系。 小结继承是面向对象编程的一种强大的代码复用方式；Java只允许单继承，所有类最终的根类是Object；protected允许子类访问父类的字段和方法；子类的构造方法可以通过super()调用父类的构造方法；可以安全地向上转型为更抽象的类型；可以强制向下转型，最好借助instanceof判断；子类和父类的关系是is，has关系不能用继承。 6.多态、final、super在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为覆写（Override）。例如，在Person类中，我们定义了run()方法： 12345class Person &#123; public void run() &#123; System.out.println(&quot;Person.run&quot;); &#125;&#125; 在子类Student中，覆写这个run()方法： 123456class Student extends Person &#123; @Override public void run() &#123; System.out.println(&quot;Student.run&quot;); &#125;&#125; 注意：方法名相同，方法参数相同，但方法返回值不同，也是不同的方法。加上@Override可以让编译器帮助检查是否进行了正确的覆写。希望进行覆写，但是不小心写错了方法签名，编译器会报错。 1234567891011121314public class Main &#123; public static void main(String[] args) &#123; &#125;&#125;class Person &#123; public void run() &#123;&#125;&#125;public class Student extends Person &#123; @Override &#x2F;&#x2F; Compile error! public void run(String s) &#123;&#125;&#125;@Override不是必需的。 多态多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。例如： 12Person p &#x3D; new Student();p.run(); &#x2F;&#x2F; 无法确定运行时究竟调用哪个run()方法 有童鞋会问，从上面的代码一看就明白，肯定调用的是Student的run()方法啊。但是，假设我们编写这样一个方法： 1234public void runTwice(Person p) &#123; p.run(); p.run();&#125; 它传入的参数类型是Person，我们是无法知道传入的参数实际类型究竟是Person，还是Student，还是Person的其他子类，因此，也无法确定调用的是不是Person类定义的run()方法。所以，多态的特性就是，运行期才能动态决定调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法。这种不确定性的方法调用，究竟有什么作用？我们还是来举栗子。假设我们定义一种收入，需要给它报税，那么先定义一个Income类： 123456class Income &#123; protected double income; public double getTax() &#123; return income * 0.1; &#x2F;&#x2F; 税率10% &#125;&#125; 对于工资收入，可以减去一个基数，那么我们可以从Income派生出SalaryIncome，并覆写getTax()： 123456789class Salary extends Income &#123; @Override public double getTax() &#123; if (income &lt;&#x3D; 5000) &#123; return 0; &#125; return (income - 5000) * 0.2; &#125;&#125; 如果你享受国务院特殊津贴，那么按照规定，可以全部免税： 123456class StateCouncilSpecialAllowance extends Income &#123; @Override public double getTax() &#123; return 0; &#125;&#125; 现在，我们要编写一个报税的财务软件，对于一个人的所有收入进行报税，可以这么写： 1234567public double totalTax(Income... incomes) &#123; double total &#x3D; 0; for (Income income: incomes) &#123; total &#x3D; total + income.getTax(); &#125; return total;&#125; 代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Main &#123; public static void main(String[] args) &#123; &#x2F;&#x2F; 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税: Income[] incomes &#x3D; new Income[] &#123; new Income(3000), new Salary(7500), new StateCouncilSpecialAllowance(15000) &#125;; System.out.println(totalTax(incomes)); &#125; public static double totalTax(Income... incomes) &#123; double total &#x3D; 0; for (Income income: incomes) &#123; total &#x3D; total + income.getTax(); &#125; return total; &#125;&#125;class Income &#123; protected double income; public Income(double income) &#123; this.income &#x3D; income; &#125; public double getTax() &#123; return income * 0.1; &#x2F;&#x2F; 税率10% &#125;&#125;class Salary extends Income &#123; public Salary(double income) &#123; super(income); &#125; @Override public double getTax() &#123; if (income &lt;&#x3D; 5000) &#123; return 0; &#125; return (income - 5000) * 0.2; &#125;&#125;class StateCouncilSpecialAllowance extends Income &#123; public StateCouncilSpecialAllowance(double income) &#123; super(income); &#125; @Override public double getTax() &#123; return 0; &#125;&#125; 观察totalTax()方法：利用多态，totalTax()方法只需要和Income打交道，它完全不需要知道Salary和StateCouncilSpecialAllowance的存在，就可以正确计算出总的税。如果我们要新增一种稿费收入，只需要从Income派生，然后正确覆写getTax()方法就可以。把新的类型传入totalTax()，不需要修改任何代码。可见，多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。 覆写Object方法 因为所有的class最终都继承自Object，而Object定义了几个重要的方法： 123toString()：把instance输出为String；equals()：判断两个instance是否逻辑相等；hashCode()：计算一个instance的哈希值。 调用super在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过super来调用。例如： 1234567891011121314class Person &#123; protected String name; public String hello() &#123; return &quot;Hello, &quot; + name; &#125;&#125;class Student extends Person &#123; @Override public String hello() &#123; &#x2F;&#x2F; 调用父类的hello()方法: return super.hello() + &quot;!&quot;; &#125;&#125; final继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为final。用final修饰的方法不能被Override： 12345678910111213class Person &#123; protected String name; public final String hello() &#123; return &quot;Hello, &quot; + name; &#125;&#125;Student extends Person &#123; &#x2F;&#x2F; compile error: 不允许覆写 @Override public String hello() &#123; &#125;&#125; 如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为final。用final修饰的类不能被继承： 1234567final class Person &#123; protected String name;&#125;&#x2F;&#x2F; compile error: 不允许继承自PersonStudent extends Person &#123;&#125; 对于一个类的实例字段，同样可以用final修饰。用final修饰的字段在初始化后不能被修改。例如： 123class Person &#123; public final String name &#x3D; &quot;Unamed&quot;;&#125; 对final字段重新赋值会报错： 12Person p &#x3D; new Person();p.name &#x3D; &quot;New Name&quot;; &#x2F;&#x2F; compile error! 以在构造方法中初始化final字段： 123456class Person &#123; public final String name; public Person(String name) &#123; this.name &#x3D; name; &#125;&#125; 这种方法更为常用，因为可以保证实例一旦创建，其final字段就不可修改。 小结子类可以覆写父类的方法（Override），覆写在子类中改变了父类方法的行为；Java的方法调用总是作用于运行期对象的实际类型，这种行为称为多态；final修饰符有多种作用：final修饰的方法可以阻止被覆写；final修饰的class可以阻止被继承；final修饰的field必须在创建对象时初始化，随后不可修改。 7.抽象类简述：由于多态的存在，每个子类都可以覆写父类的方法，例如： 12345678910111213class Person &#123; public void run() &#123; … &#125;&#125;class Student extends Person &#123; @Override public void run() &#123; … &#125;&#125;class Teacher extends Person &#123; @Override public void run() &#123; … &#125;&#125; 从Person类派生的Student和Teacher都可以覆写run()方法。 如果父类Person的run()方法没有实际意义，能否去掉方法的执行语句？ 123class Person &#123; public void run(); &#x2F;&#x2F; Compile Error!&#125; 答案是不行，会导致编译错误，因为定义方法的时候，必须有实现方法的语句。 能不能去掉父类的run()方法？答案还是不行，因为去掉父类的run()方法，就失去了多态的特性。例如，runTwice()就无法编译： 1234public void runTwice(Person p) &#123; p.run(); &#x2F;&#x2F; Person没有run()方法，会导致编译错误 p.run();&#125; 如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法： 123class Person &#123; public abstract void run();&#125; 把一个方法声明为abstract，表示它是一个抽象方法，本身没有实现任何方法语句。因为这个抽象方法本身是无法执行的，所以，Person类也无法被实例化。编译器会告诉我们，无法编译Person类，因为它包含抽象方法。必须把Person类本身也声明为abstract，才能正确编译它： 123abstract class Person &#123; public abstract void run();&#125; 抽象类如果一个class定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用abstract修饰。因为无法执行抽象方法，因此这个类也必须申明为抽象类（abstract class）。使用abstract修饰的类就是抽象类。我们无法实例化一个抽象类：Person p = new Person(); // 编译错误 无法实例化的抽象类有什么用？因为抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”。例如，Person类定义了抽象方法run()，那么，在实现子类Student的时候，就必须覆写run()方法： 1234567891011121314151617public class Main &#123; public static void main(String[] args) &#123; Person p &#x3D; new Student(); &#x2F;&#x2F;向上转型 p.run(); &#125;&#125;abstract class Person &#123; public abstract void run();&#125;class Student extends Person &#123; @Override public void run() &#123; System.out.println(&quot;Student.run&quot;); &#125;&#125; 面向抽象编程当我们定义了抽象类Person，以及具体的Student、Teacher子类的时候，我们可以通过抽象类Person类型去引用具体的子类的实例： 12Person s &#x3D; new Student();Person t &#x3D; new Teacher(); 这种引用抽象类的好处在于，我们对其进行方法调用，并不关心Person类型变量的具体子类型：// 不关心Person变量的具体子类型: 12s.run();t.run(); 同样的代码，如果引用的是一个新的子类，我们仍然不关心具体类型：// 同样不关心新的子类是如何实现run()方法的： 12Person e &#x3D; new Employee();e.run(); 这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。 面向抽象编程的本质就是：上层代码只定义规范（例如：abstract class Person）；不需要子类就可以实现业务逻辑（正常编译）；具体的业务逻辑由不同的子类实现，调用者并不关心。 小结通过abstract定义的方法是抽象方法，它只有定义，没有实现。抽象方法定义了子类必须实现的接口规范；定义了抽象方法的class必须被定义为抽象类，从抽象类继承的子类必须实现抽象方法；如果不实现抽象方法，则该子类仍是一个抽象类；面向抽象编程使得调用者只关心抽象方法的定义，不关心子类的具体实现。 8.接口在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。如果一个抽象类没有字段，所有方法全部都是抽象方法： 1234abstract class Person &#123; public abstract void run(); public abstract String getName();&#125; 就可以把该抽象类改写为接口：interface。在Java中，使用interface可以声明一个接口： 1234interface Person &#123; void run(); String getName();&#125; 所谓interface，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是public abstract的，所以这两个修饰符不需要写出来（写不写效果都一样）。 当一个具体的class去实现一个interface时，需要使用implements关键字。举个例子： 1234567891011121314151617class Student implements Person &#123; private String name; public Student(String name) &#123; this.name &#x3D; name; &#125; @Override public void run() &#123; System.out.println(this.name + &quot; run&quot;); &#125; @Override public String getName() &#123; return this.name; &#125;&#125; 我们知道，在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个interface，例如： 123class Student implements Person, Hello &#123; &#x2F;&#x2F; 实现了两个interface ...&#125; 术语注意区分术语：Java的接口特指interface的定义，表示一个接口类型和一组方法签名，而编程接口泛指接口规范，如方法签名，数据格式，网络协议等。抽象类和接口的对比如下： abstract class interface继承 只能extends一个class 可以implements多个interface字段 可以定义实例字段 不能定义实例字段抽象方法 可以定义抽象方法 可以定义抽象方法非抽象方法 可以定义非抽象方法 可以定义default方法 接口继承一个interface可以继承自另一个interface。interface继承自interface使用extends，它相当于扩展了接口的方法。例如： 12345678interface Hello &#123; void hello();&#125;interface Person extends Hello &#123; void run(); String getName();&#125; 此时，Person接口继承自Hello接口，因此，Person接口现在实际上有3个抽象方法签名，其中一个来自继承的Hello接口。 继承关系合理设计interface和abstract class的继承关系，可以充分复用代码。一般来说，公共逻辑适合放在abstract class中，具体逻辑放到各个子类，而接口层次代表抽象程度。可以参考Java的集合类定义的一组接口、抽象类以及具体子类的继承关系： 12345678910111213141516171819202122┌───────────────┐│ Iterable │└───────────────┘ ▲ ┌───────────────────┐ │ │ Object │┌───────────────┐ └───────────────────┘│ Collection │ ▲└───────────────┘ │ ▲ ▲ ┌───────────────────┐ │ └──────────│AbstractCollection │┌───────────────┐ └───────────────────┘│ List │ ▲└───────────────┘ │ ▲ ┌───────────────────┐ └──────────│ AbstractList │ └───────────────────┘ ▲ ▲ │ │ │ │ ┌────────────┐ ┌────────────┐ │ ArrayList │ │ LinkedList │ └────────────┘ └────────────┘ 在使用的时候，实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为接口比抽象类更抽象： 123List list &#x3D; new ArrayList(); &#x2F;&#x2F; 用List接口引用具体子类的实例Collection coll &#x3D; list; &#x2F;&#x2F; 向上转型为Collection接口Iterable it &#x3D; coll; &#x2F;&#x2F; 向上转型为Iterable接口 default方法在接口中，可以定义default方法。例如，把Person接口的run()方法改为default方法： 12345678910111213141516171819202122232425public class Main &#123; public static void main(String[] args) &#123; Person p &#x3D; new Student(&quot;Xiao Ming&quot;); p.run(); &#125;&#125;interface Person &#123; String getName(); default void run() &#123; System.out.println(getName() + &quot; run&quot;); &#125;&#125;class Student implements Person &#123; private String name; public Student(String name) &#123; this.name &#x3D; name; &#125; public String getName() &#123; return this.name; &#125;&#125; 实现类可以不必覆写default方法。default方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是default方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。default方法和抽象类的普通方法是有所不同的。因为interface没有字段，default方法无法访问字段，而抽象类的普通方法可以访问实例字段。 小结Java的接口（interface）定义了纯抽象规范，一个类可以实现多个接口；接口也是数据类型，适用于向上转型和向下转型；接口的所有方法都是抽象方法，接口不能定义实例字段；接口可以定义default方法（JDK&gt;=1.8）。 9.静态字段与方法在一个class中定义的字段，我们称之为实例字段。实例字段的特点是，每个实例都有独立的字段，各个实例的同名字段互不影响。还有一种字段，是用static修饰的字段，称为静态字段：static field。实例字段在每个实例中都有自己的一个独立“空间”，但是静态字段只有一个共享“空间”，所有实例都会共享该字段。举个例子： 1234567891011121314151617181920212223242526272829class Person &#123; public String name; public int age; &#x2F;&#x2F; 定义静态字段number: public static int number;&#125;public class Main &#123; public static void main(String[] args) &#123; Person ming &#x3D; new Person(&quot;Xiao Ming&quot;, 12); Person hong &#x3D; new Person(&quot;Xiao Hong&quot;, 15); ming.number &#x3D; 88; System.out.println(hong.number); hong.number &#x3D; 99; System.out.println(ming.number); &#125;&#125;class Person &#123; public String name; public int age; public static int number; public Person(String name, int age) &#123; this.name &#x3D; name; this.age &#x3D; age; &#125;&#125; 输出：8899 对于静态字段，无论修改哪个实例的静态字段，效果都是一样的：所有实例的静态字段都被修改了，原因是静态字段并不属于实例： 12345678910111213141516 ┌──────────────────┐ming ──&gt;│Person instance │ ├──────────────────┤ │name &#x3D; &quot;Xiao Ming&quot;│ │age &#x3D; 12 │ │number ───────────┼──┐ ┌─────────────┐ └──────────────────┘ │ │Person class │ │ ├─────────────┤ ├───&gt;│number &#x3D; 99 │ ┌──────────────────┐ │ └─────────────┘hong ──&gt;│Person instance │ │ ├──────────────────┤ │ │name &#x3D; &quot;Xiao Hong&quot;│ │ │age &#x3D; 15 │ │ │number ───────────┼──┘ └──────────────────┘ 虽然实例可以访问静态字段，但是它们指向的其实都是Person class的静态字段。所以，所有实例共享一个静态字段。因此，不推荐用实例变量.静态字段去访问静态字段，因为在Java程序中，实例对象并没有静态字段。在代码中，实例对象能访问静态字段只是因为编译器可以根据实例类型自动转换为类名.静态字段来访问静态对象。推荐用类名来访问静态字段。可以把静态字段理解为描述class本身的字段（非实例字段）。对于上面的代码，更好的写法是： 12Person.number &#x3D; 99;System.out.println(Person.number); 静态方法有静态字段，就有静态方法。用static修饰的方法称为静态方法。调用实例方法必须通过一个实例变量，而调用静态方法则不需要实例变量，通过类名就可以调用。静态方法类似其它编程语言的函数。例如： 1234567891011121314public class Main &#123; public static void main(String[] args) &#123; Person.setNumber(99); System.out.println(Person.number); &#125;&#125;class Person &#123; public static int number; public static void setNumber(int value) &#123; number &#x3D; value; &#125;&#125; 因为静态方法属于class而不属于实例，因此，静态方法内部，无法访问this变量，也无法访问实例字段，它只能访问静态字段。通过实例变量也可以调用静态方法，但这只是编译器自动帮我们把实例改写成类名而已。通常情况下，通过实例变量访问静态字段和静态方法，会得到一个编译警告。静态方法经常用于工具类。例如： 12Arrays.sort()Math.random() 静态方法也经常用于辅助方法。注意到Java程序的入口main()也是静态方法。 接口的静态字段因为interface是一个纯抽象类，所以它不能定义实例字段。但是，interface是可以有静态字段的，并且静态字段必须为final类型： 1234public interface Person &#123; public static final int MALE &#x3D; 1; public static final int FEMALE &#x3D; 2;&#125; 实际上，因为interface的字段只能是public static final类型，所以我们可以把这些修饰符都去掉，上述代码可以简写为： 12345public interface Person &#123; &#x2F;&#x2F; 编译器会自动加上public statc final: int MALE &#x3D; 1; int FEMALE &#x3D; 2;&#125; 编译器会自动把该字段变为public static final类型。 小结静态字段属于所有实例“共享”的字段，实际上是属于class的字段；调用静态方法不需要实例，无法访问this，但可以访问静态字段和其他静态方法；静态方法常用于工具类和辅助方法。 10.包在前面的代码中，我们把类和接口命名为Person、Student、Hello等简单名字。在现实中，如果小明写了一个Person类，小红也写了一个Person类，现在，小白既想用小明的Person，也想用小红的Person，怎么办？如果小军写了一个Arrays类，恰好JDK也自带了一个Arrays类，如何解决类名冲突？在Java中，我们使用package来解决名字冲突。Java定义了一种名字空间，称之为包：package。一个类总是属于某个包，类名（比如Person）只是一个简写，真正的完整类名是包名.类名。例如：小明的Person类存放在包ming下面，因此，完整类名是ming.Person；小红的Person类存放在包hong下面，因此，完整类名是hong.Person；小军的Arrays类存放在包mr.jun下面，因此，完整类名是mr.jun.Arrays；JDK的Arrays类存放在包java.util下面，因此，完整类名是java.util.Arrays。在定义class的时候，我们需要在第一行声明这个class属于哪个包。小明的Person.java文件： 1234package ming; &#x2F;&#x2F; 申明包名mingpublic class Person &#123;&#125; 小军的Arrays.java文件： 1234package mr.jun; &#x2F;&#x2F; 申明包名mr.junpublic class Arrays &#123;&#125; 在Java虚拟机执行的时候，JVM只看完整类名，因此，只要包名不同，类就不同。包可以是多层结构，用.隔开。例如：java.util。 要特别注意：包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。 我们还需要按照包结构把上面的Java文件组织起来。假设以package_sample作为根目录，src作为源码目录，那么所有文件结构就是： 123456789package_sample└─ src ├─ hong │ └─ Person.java │ ming │ └─ Person.java └─ mr └─ jun └─ Arrays.java 即所有Java文件对应的目录层次要和包的层次一致。 编译后的.class文件也需要按照包结构存放。如果使用IDE，把编译后的.class文件放到bin目录下，那么，编译的文件结构就是： 123456789package_sample└─ bin ├─ hong │ └─ Person.class │ ming │ └─ Person.class └─ mr └─ jun └─ Arrays.class 编译的命令相对比较复杂，我们需要在src目录下执行javac命令： 1javac -d ..&#x2F;bin ming&#x2F;Person.java hong&#x2F;Person.java mr&#x2F;jun&#x2F;Arrays.java 在IDE中，会自动根据包结构编译所有Java源码，所以不必担心使用命令行编译的复杂命令。 包作用域位于同一个包的类，可以访问包作用域的字段和方法。不用public、protected、private修饰的字段和方法就是包作用域。例如，Person类定义在hello包下面： 12345678package hello;public class Person &#123; &#x2F;&#x2F; 包作用域: void hello() &#123; System.out.println(&quot;Hello!&quot;); &#125;&#125; Main类也定义在hello包下面： 12345678package hello;public class Main &#123; public static void main(String[] args) &#123; Person p &#x3D; new Person(); p.hello(); &#x2F;&#x2F; 可以调用，因为Main和Person在同一个包 &#125;&#125; import在一个class中，我们总会引用其他的class。例如，小明的ming.Person类，如果要引用小军的mr.jun.Arrays类，他有三种写法：第一种，直接写出完整类名，例如： 12345678&#x2F;&#x2F; Person.javapackage ming;public class Person &#123; public void run() &#123; mr.jun.Arrays arrays &#x3D; new mr.jun.Arrays(); &#125;&#125; 很显然，每次写完整类名比较痛苦。因此，第二种写法是用import语句，导入小军的Arrays，然后写简单类名： 1234567891011&#x2F;&#x2F; Person.javapackage ming;&#x2F;&#x2F; 导入完整类名:import mr.jun.Arrays;public class Person &#123; public void run() &#123; Arrays arrays &#x3D; new Arrays(); &#125;&#125; 在写import的时候，可以使用*，表示把这个包下面的所有class都导入进来（但不包括子包的class）： 1234567891011&#x2F;&#x2F; Person.javapackage ming;&#x2F;&#x2F; 导入mr.jun包的所有class:import mr.jun.*;public class Person &#123; public void run() &#123; Arrays arrays &#x3D; new Arrays(); &#125;&#125; 我们一般不推荐这种写法，因为在导入了多个包后，很难看出Arrays类属于哪个包。还有一种import static的语法，它可以导入一个类的静态字段和静态方法： 1234567891011package main;&#x2F;&#x2F; 导入System类的所有静态字段和静态方法:import static java.lang.System.*;public class Main &#123; public static void main(String[] args) &#123; &#x2F;&#x2F; 相当于调用System.out.println(…) out.println(&quot;Hello, world!&quot;); &#125;&#125; import static很少使用。 Java编译器最终编译出的.class文件只使用完整类名，因此，在代码中，当编译器遇到一个class名称时：如果是完整类名，就直接根据完整类名查找这个class；如果是简单类名，按下面的顺序依次查找：查找当前package是否存在这个class；查找import的包是否包含这个class；查找java.lang包是否包含这个class。如果按照上面的规则还无法确定类名，则编译报错。 编写class的时候，编译器会自动帮我们做两个import动作：默认自动import当前package的其他class；默认自动import java.lang.*。自动导入的是java.lang包，但类似java.lang.reflect这些包仍需要手动导入。如果有两个class名称相同，例如，mr.jun.Arrays和java.util.Arrays，那么只能import其中一个，另一个必须写完整类名。 最佳实践为了避免名字冲突，我们需要确定唯一的包名。推荐的做法是使用倒置的域名来确保唯一性。例如：org.apacheorg.apache.commons.logcom.liaoxuefeng.sample子包就可以根据功能自行命名。要注意不要和java.lang包的类重名，即自己的类不要使用这些名字：StringSystemRuntime…要注意也不要和JDK常用类重名：java.util.Listjava.text.Formatjava.math.BigInteger… 小结Java内建的package机制是为了避免class命名冲突；JDK的核心类使用java.lang包，编译器会自动导入；JDK的其它常用类定义在java.util.*，java.math.*，java.text.*，……；包名推荐使用倒置的域名，例如org.apache。 11.作用域在Java中，我们经常看到public、protected、private这些修饰符。在Java中，这些修饰符可以用来限定访问作用域。 public定义为public的class、interface可以被其他任何类访问： 123456package abc;public class Hello &#123; public void hi() &#123; &#125;&#125; 上面的Hello是public，因此，可以被其他包的类访问： 12345678package xyz;class Main &#123; void foo() &#123; &#x2F;&#x2F; Main可以访问Hello Hello h &#x3D; new Hello(); &#125;&#125; 定义为public的field、method可以被其他类访问，前提是首先有访问class的权限： 123456package abc;public class Hello &#123; public void hi() &#123; &#125;&#125; 上面的hi()方法是public，可以被其他类调用，前提是首先要能访问Hello类： 12345678package xyz;class Main &#123; void foo() &#123; Hello h &#x3D; new Hello(); h.hi(); &#125;&#125; private定义为private的field、method无法被其他类访问： 1234567891011package abc;public class Hello &#123; &#x2F;&#x2F; 不能被其他类调用: private void hi() &#123; &#125; public void hello() &#123; this.hi(); &#125;&#125; 实际上，确切地说，private访问权限被限定在class的内部，而且与方法声明顺序无关。推荐把private方法放到后面，因为public方法定义了类对外提供的功能，阅读代码的时候，应该先关注public方法： 12345678910package abc;public class Hello &#123; public void hello() &#123; this.hi(); &#125; private void hi() &#123; &#125;&#125; 由于Java支持嵌套类，如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问private的权限： 123456789101112131415161718public class Main &#123; public static void main(String[] args) &#123; Inner i &#x3D; new Inner(); i.hi(); &#125; &#x2F;&#x2F; private方法: private static void hello() &#123; System.out.println(&quot;private hello!&quot;); &#125; &#x2F;&#x2F; 静态内部类: static class Inner &#123; public void hi() &#123; Main.hello(); &#125; &#125;&#125; 定义在一个class内部的class称为嵌套类（nested class），Java支持好几种嵌套类。 protectedprotected作用于继承关系。定义为protected的字段和方法可以被子类访问，以及子类的子类： 1234567package abc;public class Hello &#123; &#x2F;&#x2F; protected方法: protected void hi() &#123; &#125;&#125; 上面的protected方法可以被继承的类访问： 123456789package xyz;class Main extends Hello &#123; void foo() &#123; Hello h &#x3D; new Hello(); &#x2F;&#x2F; 可以访问protected方法: h.hi(); &#125;&#125; package最后，包作用域是指一个类允许访问同一个package的没有public、private修饰的class，以及没有public、protected、private修饰的字段和方法。 1234567package abc;&#x2F;&#x2F; package权限的类:class Hello &#123; &#x2F;&#x2F; package权限的方法: void hi() &#123; &#125;&#125; 只要在同一个包，就可以访问package权限的class、field和method： 12345678910package abc;class Main &#123; void foo() &#123; &#x2F;&#x2F; 可以访问package权限的类: Hello h &#x3D; new Hello(); &#x2F;&#x2F; 可以调用package权限的方法: h.hi(); &#125;&#125; 注意，包名必须完全一致，包没有父子关系，com.apache和com.apache.abc是不同的包。 局部变量在方法内部定义的变量称为局部变量，局部变量作用域从变量声明处开始到对应的块结束。方法参数也是局部变量。 1234567891011121314package abc;public class Hello &#123; void hi(String name) &#123; &#x2F;&#x2F; ① String s &#x3D; name.toLowerCase(); &#x2F;&#x2F; ② int len &#x3D; s.length(); &#x2F;&#x2F; ③ if (len &lt; 10) &#123; &#x2F;&#x2F; ④ int p &#x3D; 10 - len; &#x2F;&#x2F; ⑤ for (int i&#x3D;0; i&lt;10; i++) &#123; &#x2F;&#x2F; ⑥ System.out.println(); &#x2F;&#x2F; ⑦ &#125; &#x2F;&#x2F; ⑧ &#125; &#x2F;&#x2F; ⑨ &#125; &#x2F;&#x2F; ⑩&#125; 我们观察上面的hi()方法代码：方法参数name是局部变量，它的作用域是整个方法，即①～⑩；变量s的作用域是定义处到方法结束，即②～⑩；变量len的作用域是定义处到方法结束，即③～⑩；变量p的作用域是定义处到if块结束，即⑤～⑨；变量i的作用域是for循环，即⑥～⑧。使用局部变量时，应该尽可能把局部变量的作用域缩小，尽可能延后声明局部变量。 finalJava还提供了一个final修饰符。final与访问权限不冲突，它有很多作用。用final修饰class可以阻止被继承： 123456789package abc;&#x2F;&#x2F; 无法被继承:public final class Hello &#123; private int n &#x3D; 0; protected void hi(int t) &#123; long i &#x3D; t; &#125;&#125; 用final修饰method可以阻止被子类覆写： 1234567package abc;public class Hello &#123; &#x2F;&#x2F; 无法被覆写: protected final void hi() &#123; &#125;&#125; 用final修饰field可以阻止被重新赋值： 12345678package abc;public class Hello &#123; private final int n &#x3D; 0; protected void hi() &#123; this.n &#x3D; 1; &#x2F;&#x2F; error! &#125;&#125; 用final修饰局部变量可以阻止被重新赋值： 1234567package abc;public class Hello &#123; protected void hi(final int t) &#123; t &#x3D; 1; &#x2F;&#x2F; error! &#125;&#125; 小结Java内建的访问权限包括public、protected、private和package权限；Java在方法内部定义的变量是局部变量，局部变量的作用域从变量声明开始，到一个块结束；final修饰符不是访问权限，它可以修饰class、field和method；一个.java文件只能包含一个public类，但可以包含多个非public类。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础_数组操作-3.多维数组","date":"2020-02-17T06:48:50.886Z","path":"2020/02/17/Java基础_数组操作-3/","text":"二维数组二维数组就是数组的数组。定义一个二维数组如下： 12345678910public class Main &#123; public static void main(String[] args) &#123; int[][] ns &#x3D; &#123; &#123; 1, 2, 3, 4 &#125;, &#123; 5, 6, 7, 8 &#125;, &#123; 9, 10, 11, 12 &#125; &#125;; System.out.println(ns.length); &#x2F;&#x2F; 3 &#125;&#125; 因为ns包含3个数组，因此，ns.length为3。实际上ns在内存中的结构如下： 123456789 ┌───┬───┬───┬───┐ ┌───┐ ┌──&gt;│ 1 │ 2 │ 3 │ 4 │ns ─────&gt;│░░░│──┘ └───┴───┴───┴───┘ ├───┤ ┌───┬───┬───┬───┐ │░░░│─────&gt;│ 5 │ 6 │ 7 │ 8 │ ├───┤ └───┴───┴───┴───┘ │░░░│──┐ ┌───┬───┬───┬───┐ └───┘ └──&gt;│ 9 │10 │11 │12 │ └───┴───┴───┴───┘ 如果我们定义一个普通数组arr0，然后把ns[0]赋值给它： 1234567891011public class Main &#123; public static void main(String[] args) &#123; int[][] ns &#x3D; &#123; &#123; 1, 2, 3, 4 &#125;, &#123; 5, 6, 7, 8 &#125;, &#123; 9, 10, 11, 12 &#125; &#125;; int[] arr0 &#x3D; ns[0]; System.out.println(arr0.length); &#x2F;&#x2F; 4 &#125;&#125; 实际上arr0就获取了ns数组的第0个元素。因为ns数组的每个元素也是一个数组，因此，arr0指向的数组就是{ 1, 2, 3, 4 }。在内存中，结构如下： 1234567891011 arr0 ─────┐ ▼ ┌───┬───┬───┬───┐ ┌───┐ ┌──&gt;│ 1 │ 2 │ 3 │ 4 │ns ─────&gt;│░░░│──┘ └───┴───┴───┴───┘ ├───┤ ┌───┬───┬───┬───┐ │░░░│─────&gt;│ 5 │ 6 │ 7 │ 8 │ ├───┤ └───┴───┴───┴───┘ │░░░│──┐ ┌───┬───┬───┬───┐ └───┘ └──&gt;│ 9 │10 │11 │12 │ └───┴───┴───┴───┘ 访问二维数组的某个元素需要使用array[row][col]，例如：System.out.println(ns[1][2]); // 7 二维数组的每个数组元素的长度并不要求相同，例如，可以这么定义ns数组： 12345int[][] ns &#x3D; &#123; &#123; 1, 2, 3, 4 &#125;, &#123; 5, 6 &#125;, &#123; 7, 8, 9 &#125;&#125;; 这个二维数组在内存中的结构如下： 123456789 ┌───┬───┬───┬───┐ ┌───┐ ┌──&gt;│ 1 │ 2 │ 3 │ 4 │ns ─────&gt;│░░░│──┘ └───┴───┴───┴───┘ ├───┤ ┌───┬───┐ │░░░│─────&gt;│ 5 │ 6 │ ├───┤ └───┴───┘ │░░░│──┐ ┌───┬───┬───┐ └───┘ └──&gt;│ 7 │ 8 │ 9 │ └───┴───┴───┘ 要打印一个二维数组，可以使用两层嵌套的for循环： 1234567for (int[] arr : ns) &#123; for (int n : arr) &#123; System.out.print(n); System.out.print(&#39;, &#39;); &#125; System.out.println();&#125; 或者使用Java标准库的Arrays.deepToString()： 123456789101112import java.util.Arrays;public class Main &#123; public static void main(String[] args) &#123; int[][] ns &#x3D; &#123; &#123; 1, 2, 3, 4 &#125;, &#123; 5, 6, 7, 8 &#125;, &#123; 9, 10, 11, 12 &#125; &#125;; System.out.println(Arrays.deepToString(ns)); &#125;&#125; 三维数组（基本不使用）三维数组就是二维数组的数组。可以这么定义一个三维数组： 123456789101112131415int[][][] ns &#x3D; &#123; &#123; &#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125; &#125;, &#123; &#123;10, 11&#125;, &#123;12, 13&#125; &#125;, &#123; &#123;14, 15, 16&#125;, &#123;17, 18&#125; &#125;&#125;; 它在内存中的结构如下： 123456789101112131415161718192021 ┌───┬───┬───┐ ┌───┐ ┌──&gt;│ 1 │ 2 │ 3 │ ┌──&gt;│░░░│──┘ └───┴───┴───┘ │ ├───┤ ┌───┬───┬───┐ │ │░░░│─────&gt;│ 4 │ 5 │ 6 │ │ ├───┤ └───┴───┴───┘ │ │░░░│──┐ ┌───┬───┬───┐ ┌───┐ │ └───┘ └──&gt;│ 7 │ 8 │ 9 │ns ────&gt;│░░░│──┘ └───┴───┴───┘ ├───┤ ┌───┐ ┌───┬───┐ │░░░│─────&gt;│░░░│─────&gt;│10 │11 │ ├───┤ ├───┤ └───┴───┘ │░░░│──┐ │░░░│──┐ ┌───┬───┐ └───┘ │ └───┘ └──&gt;│12 │13 │ │ └───┴───┘ │ ┌───┐ ┌───┬───┬───┐ └──&gt;│░░░│─────&gt;│14 │15 │16 │ ├───┤ └───┴───┴───┘ │░░░│──┐ ┌───┬───┐ └───┘ └──&gt;│17 │18 │ └───┴───┘ 如果我们要访问三维数组的某个元素，例如，ns[2][0][1]，只需要顺着定位找到对应的最终元素15即可。理论上，我们可以定义任意的N维数组。但在实际应用中，除了二维数组在某些时候还能用得上，更高维度的数组很少使用。 小结 二维数组就是数组的数组，三维数组就是二维数组的数组；多维数组的每个数组元素长度都不要求相同；打印多维数组可以使用Arrays.deepToString()；最常见的多维数组是二维数组，访问二维数组的一个元素使用array[row][col]。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础_数组操作-2.数组排序","date":"2020-02-17T06:20:24.430Z","path":"2020/02/17/Java基础_数组操作-2/","text":"我们在Java程序基础里介绍了数组这种数据类型。有了数组，我们还需要来操作它。而数组最常见的一个操作就是遍历。 通过for循环就可以遍历数组。因为数组的每个元素都可以通过索引来访问，因此，使用标准的for循环可以完成一个数组的遍历： 123456789public class Main &#123; public static void main(String[] args) &#123; int[] ns &#x3D; &#123; 1, 4, 9, 16, 25 &#125;; for (int i&#x3D;0; i&lt;ns.length; i++) &#123; int n &#x3D; ns[i]; System.out.println(n); &#125; &#125;&#125; 第二种方式是使用for each循环，直接迭代数组的每个元素： 12345678public class Main &#123; public static void main(String[] args) &#123; int[] ns &#x3D; &#123; 1, 4, 9, 16, 25 &#125;; for (int n : ns) &#123; System.out.println(n); &#125; &#125;&#125; 注意：在for (int n : ns)循环中，变量n直接拿到ns数组的元素，而不是索引。显然for each循环更加简洁。但是，for each循环无法拿到数组的索引，因此，到底用哪一种for循环，取决于我们的需要。 打印数组内容 直接打印数组变量，得到的是数组在JVM中的引用地址： 12int[] ns &#x3D; &#123; 1, 1, 2, 3, 5, 8 &#125;;System.out.println(ns); &#x2F;&#x2F; 类似 [I@7852e922 所以为了得到数组的具体内容，使用for each循环来打印它： 1234int[] ns &#x3D; &#123; 1, 1, 2, 3, 5, 8 &#125;;for (int n : ns) &#123; System.out.print(n + &quot;, &quot;);&#125; 使用for each循环打印也很麻烦。幸好Java标准库提供了Arrays.toString()，可以快速打印数组内容：import java.util.Arrays; 123456public class Main &#123; public static void main(String[] args) &#123; int[] ns &#x3D; &#123; 1, 1, 2, 3, 5, 8 &#125;; System.out.println(Arrays.toString(ns)); &#125;&#125; 小结遍历数组可以使用for循环，for循环可以访问数组索引，for each循环直接迭代每个数组元素，但无法获取索引；使用Arrays.toString()可以快速获取数组内容。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础_数组操作-1.遍历数组","date":"2020-02-17T06:16:38.761Z","path":"2020/02/17/Java基础_数组操作-1/","text":"我们在Java程序基础里介绍了数组这种数据类型。有了数组，我们还需要来操作它。而数组最常见的一个操作就是遍历。 通过for循环就可以遍历数组。因为数组的每个元素都可以通过索引来访问，因此，使用标准的for循环可以完成一个数组的遍历： 123456789public class Main &#123; public static void main(String[] args) &#123; int[] ns &#x3D; &#123; 1, 4, 9, 16, 25 &#125;; for (int i&#x3D;0; i&lt;ns.length; i++) &#123; int n &#x3D; ns[i]; System.out.println(n); &#125; &#125;&#125; 第二种方式是使用for each循环，直接迭代数组的每个元素： 12345678public class Main &#123; public static void main(String[] args) &#123; int[] ns &#x3D; &#123; 1, 4, 9, 16, 25 &#125;; for (int n : ns) &#123; System.out.println(n); &#125; &#125;&#125; 注意：在for (int n : ns)循环中，变量n直接拿到ns数组的元素，而不是索引。显然for each循环更加简洁。但是，for each循环无法拿到数组的索引，因此，到底用哪一种for循环，取决于我们的需要。 打印数组内容 直接打印数组变量，得到的是数组在JVM中的引用地址： 12int[] ns &#x3D; &#123; 1, 1, 2, 3, 5, 8 &#125;;System.out.println(ns); &#x2F;&#x2F; 类似 [I@7852e922 所以为了得到数组的具体内容，使用for each循环来打印它： 1234int[] ns &#x3D; &#123; 1, 1, 2, 3, 5, 8 &#125;;for (int n : ns) &#123; System.out.print(n + &quot;, &quot;);&#125; 使用for each循环打印也很麻烦。幸好Java标准库提供了Arrays.toString()，可以快速打印数组内容： 12345678import java.util.Arrays;public class Main &#123; public static void main(String[] args) &#123; int[] ns &#x3D; &#123; 1, 1, 2, 3, 5, 8 &#125;; System.out.println(Arrays.toString(ns)); &#125;&#125; 小结遍历数组可以使用for循环，for循环可以访问数组索引，for each循环直接迭代每个数组元素，但无法获取索引；使用Arrays.toString()可以快速获取数组内容。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础_流程控制-6.break和continue","date":"2020-02-17T06:14:34.758Z","path":"2020/02/17/Java基础_流程控制-6/","text":"无论是while循环还是for循环，有两个特别的语句可以使用，就是break语句和continue语句。break在循环过程中，可以使用break语句跳出当前循环。我们来看一个例子： 123456789101112public class Main &#123; public static void main(String[] args) &#123; int sum &#x3D; 0; for (int i&#x3D;1; ; i++) &#123; sum &#x3D; sum + i; if (i &#x3D;&#x3D; 100) &#123; break; &#125; &#125; System.out.println(sum); &#125;&#125; 使用for循环计算从1到100时，我们并没有在for()中设置循环退出的检测条件。但是，在循环内部，我们用if判断，如果i==100，就通过break退出循环。注意：break跳出的是自己的那一层循环，并不会结束上层循环 continuebreak会跳出当前循环，也就是整个循环都不会执行了。而continue则是提前结束本次循环，直接继续执行下次循环。我们看一个例子： 1234567891011121314public class Main &#123; public static void main(String[] args) &#123; int sum &#x3D; 0; for (int i&#x3D;1; i&lt;&#x3D;10; i++) &#123; System.out.println(&quot;begin i &#x3D; &quot; + i); if (i % 2 &#x3D;&#x3D; 0) &#123; continue; &#x2F;&#x2F; continue语句会结束本次循环 &#125; sum &#x3D; sum + i; System.out.println(&quot;end i &#x3D; &quot; + i); &#125; System.out.println(sum); &#x2F;&#x2F; 25 &#125;&#125; 在多层嵌套的循环中，continue语句同样是结束本次自己所在的循环。 小结 break语句可以跳出当前循环；break语句通常配合if，在满足条件时提前结束整个循环；break语句总是跳出最近的一层循环；continue语句可以提前结束本次循环；continue语句通常配合if，在满足条件时提前结束本次循环。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础_流程控制-5.for循环","date":"2020-02-17T06:12:37.739Z","path":"2020/02/17/Java基础_流程控制-5/","text":"除了while和do while循环，Java使用最广泛的是for循环。for循环的功能非常强大，它使用计数器实现循环。for循环会先初始化计数器，然后，在每次循环前检测循环条件，在每次循环后更新计数器。计数器变量通常命名为i。 我们把1到100求和用for循环改写一下： 123456789public class Main &#123; public static void main(String[] args) &#123; int sum &#x3D; 0; for (int i&#x3D;1; i&lt;&#x3D;100; i++) &#123; sum &#x3D; sum + i; &#125; System.out.println(sum); &#125;&#125; 在for循环执行前，会先执行初始化语句int i=1，它定义了计数器变量i并赋初始值为1，然后，循环前先检查循环条件i&lt;=100，循环后自动执行i++，因此，和while循环相比，for循环把更新计数器的代码统一放到了一起。在for循环的循环体内部，不需要去更新变量i。for循环的结构是： 123for (初始条件; 循环检测条件; 循环后更新计数器) &#123; &#x2F;&#x2F; 执行语句&#125; 如果要计算一个整型数组各个元素的和，可以使用for循环实现： 1234567891011public class Main &#123; public static void main(String[] args) &#123; int[] ns &#x3D; &#123; 1, 4, 9, 16, 25 &#125;; int sum &#x3D; 0; for (int i&#x3D;0; i&lt;ns.length; i++) &#123; System.out.println(&quot;i &#x3D; &quot; + i + &quot;, ns[i] &#x3D; &quot; + ns[i]); sum &#x3D; sum + ns[i]; &#125; System.out.println(&quot;sum &#x3D; &quot; + sum); &#125;&#125; for each循环 for循环经常用来遍历数组，因为通过计数器可以根据索引来访问数组的每个元素： 1234int[] ns &#x3D; &#123; 1, 4, 9, 16, 25 &#125;;for (int i&#x3D;0; i&lt;ns.length; i++) &#123; System.out.println(ns[i]);&#125; Java还提供了另一种for each循环，它可以更简单地遍历数组： 12345678public class Main &#123; public static void main(String[] args) &#123; int[] ns &#x3D; &#123; 1, 4, 9, 16, 25 &#125;; for (int n : ns) &#123; System.out.println(n); &#125; &#125;&#125; 和for循环相比，for each循环的变量n不再是计数器，而是直接对应到数组的每个元素。for each循环的写法也更简洁。但是，for each循环无法指定遍历顺序，也无法获取数组的索引。除了数组外，for each循环能够遍历所有“可迭代”的数据类型，包括List、Map等。 小结 for循环通过计数器可以实现复杂循环；for each循环可以直接遍历数组的每个元素；最佳实践：计数器变量定义在for循环内部，循环体内部不修改计数器；","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础_流程控制-4.while循环","date":"2020-02-17T06:11:28.335Z","path":"2020/02/17/Java基础_流程控制-4/","text":"循环语句就是让计算机根据条件做循环计算，在条件满足时继续循环，条件不满足时退出循环。例如，计算从1到100的和：1 + 2 + 3 + 4 + … + 100 = ? while循环在每次循环开始前，首先判断条件是否成立。如果计算结果为true，就把循环体内的语句执行一遍，如果计算结果为false，那就直接跳到while循环的末尾，继续往下执行。求1到100的和可以用如下代码实现： 1234567891011public class Main &#123; public static void main(String[] args) &#123; int sum &#x3D; 0; &#x2F;&#x2F; 累加的和，初始化为0 int n &#x3D; 1; while (n &lt;&#x3D; 100) &#123; &#x2F;&#x2F; 循环条件是n &lt;&#x3D; 100 sum &#x3D; sum + n; &#x2F;&#x2F; 把n累加到sum中 n ++; &#x2F;&#x2F; n自身加1 &#125; System.out.println(sum); &#x2F;&#x2F; 5050 &#125;&#125; 注意：while循环是先判断循环条件，再循环，因此，有可能一次循环都不做。所以，在写循环条件的时候要避免死循环。 小结 while循环先判断循环条件是否满足，再执行循环语句；while循环可能一次都不执行；编写循环时要注意循环条件，并避免死循环。 do while循环 在Java中，while循环是先判断循环条件，再执行循环。而另一种do while循环则是先执行循环，再判断条件，条件满足时继续循环，条件不满足时退出。 123do &#123; 执行循环语句&#125; while (条件表达式); 可见，do while循环会至少循环一次。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础_流程控制-3.switch多重选择","date":"2020-02-17T06:10:02.512Z","path":"2020/02/17/Java基础_流程控制-3/","text":"除了if语句外，还有一种条件判断switch，是根据某个表达式的结果，分别去执行不同的分支。例如，在游戏中，让用户选择选项：单人模式多人模式退出游戏 这时，switch语句就派上用场了。switch语句根据switch (表达式)计算的结果，跳转到匹配的case结果，然后继续执行后续语句，直到遇到break结束执行。例子： 12345678910111213141516171819public class Main &#123; public static void main(String[] args) &#123; int option &#x3D; 1; switch (option) &#123; case 1: System.out.println(&quot;Selected 1&quot;); break; case 2: System.out.println(&quot;Selected 2&quot;); break; case 3: System.out.println(&quot;Selected 3&quot;); break; default: System.out.println(&quot;Not selected&quot;); break; &#125; &#125;&#125; 如果option的值没有匹配到任何case，例如option = 99，那么，switch语句不会执行任何语句。这时，可以给switch语句加一个default，当没有匹配到任何case时，执行default： 使用switch时，注意case语句并没有花括号{}，而且，case语句具有“穿透性”，如果没有break；会导致继续执行下面的case导致形成意想不到的结果。 switch语句还可以匹配字符串。字符串匹配时，是比较“内容相等”。例如： 12345678910111213141516171819public class Main &#123; public static void main(String[] args) &#123; String fruit &#x3D; &quot;apple&quot;; switch (fruit) &#123; case &quot;apple&quot;: System.out.println(&quot;Selected apple&quot;); break; case &quot;pear&quot;: System.out.println(&quot;Selected pear&quot;); break; case &quot;mango&quot;: System.out.println(&quot;Selected mango&quot;); break; default: System.out.println(&quot;No fruit selected&quot;); break; &#125; &#125;&#125; yield大多数时候，在switch表达式内部，我们会返回简单的值。但是，如果需要复杂的语句，我们也可以写很多语句，放到{…}里，然后，用yield返回一个值作为switch语句的返回值： 1234567891011121314public class Main &#123; public static void main(String[] args) &#123; String fruit &#x3D; &quot;orange&quot;; int opt &#x3D; switch (fruit) &#123; case &quot;apple&quot; -&gt; 1; case &quot;pear&quot;, &quot;mango&quot; -&gt; 2; default -&gt; &#123; int code &#x3D; fruit.hashCode(); yield code; &#x2F;&#x2F; switch语句返回值 &#125; &#125;; System.out.println(&quot;opt &#x3D; &quot; + opt); &#125;&#125; 小结switch语句可以做多重选择，然后执行匹配的case语句后续代码；switch的计算结果必须是整型、字符串或枚举类型；注意千万不要漏写break，建议打开fall-through警告；总是写上default，建议打开missing default警告；从Java 13开始，switch语句升级为表达式，不再需要break，并且允许使用yield返回值。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础_流程控制-2.if判断","date":"2020-02-17T06:08:41.296Z","path":"2020/02/17/Java基础_流程控制-2/","text":"在Java中，如果要根据一个条件来判断是否执行某一语句块时，要用到if语句。 if语句的基本语法 123if (条件) &#123; &#x2F;&#x2F; 条件满足时执行&#125; 根据if的计算结果（true还是false），决定是否执行if语句块（即花括号{}包含的所有语句） 例子： 123456789public class Main &#123; public static void main(String[] args) &#123; int n &#x3D; 70; if (n &gt;&#x3D; 60) &#123; System.out.println(&quot;及格了&quot;); &#125; System.out.println(&quot;END&quot;); &#125;&#125; 当条件n &gt;= 60计算结果为true时，if语句块被执行，将打印”及格了”，否则，if语句块将被跳过。修改n的值可以看到执行效果。{}内可以包含多条语句，不止是及格了一条，但是如果只有一条语句的时候，可以省略{} else if语句还可以编写一个else { … }，当条件判断为false时，将执行else的语句块例子： 1234567891011public class Main &#123; public static void main(String[] args) &#123; int n &#x3D; 70; if (n &gt;&#x3D; 60) &#123; System.out.println(&quot;及格了&quot;); &#125; else &#123; System.out.println(&quot;挂科了&quot;); &#125; System.out.println(&quot;END&quot;); &#125;&#125; 修改上述代码n的值，观察if条件为true或false时，程序执行的语句块。else不是必须的。 还可以用多个if … else if … 12345678910111213public class Main &#123; public static void main(String[] args) &#123; int n &#x3D; 70; if (n &gt;&#x3D; 90) &#123; System.out.println(&quot;优秀&quot;); &#125; else if (n &gt;&#x3D; 60) &#123; System.out.println(&quot;及格了&quot;); &#125; else &#123; System.out.println(&quot;挂科了&quot;); &#125; System.out.println(&quot;END&quot;); &#125;&#125; 在串联使用多个if时，要特别注意判断顺序。正确的方式是按照判断范围从大到小依次判断。使用if时，还要特别注意边界条件。 前面讲过了浮点数在计算机中常常无法精确表示，并且计算可能出现误差，因此，判断浮点数相等用==判断不靠谱以下代码是错误的 12345678910public class Main &#123; public static void main(String[] args) &#123; double x &#x3D; 1 - 9.0 &#x2F; 10; if (x &#x3D;&#x3D; 0.1) &#123; System.out.println(&quot;x is 0.1&quot;); &#125; else &#123; System.out.println(&quot;x is NOT 0.1&quot;); &#125; &#125;&#125; 正确的方法是利用差值小于某个临界值来判断： 12345678910public class Main &#123; public static void main(String[] args) &#123; double x &#x3D; 1 - 9.0 &#x2F; 10; if (Math.abs(x - 0.1) &lt; 0.00001) &#123; System.out.println(&quot;x is 0.1&quot;); &#125; else &#123; System.out.println(&quot;x is NOT 0.1&quot;); &#125; &#125;&#125; 判断引用类型相等 在Java中，判断值类型的变量是否相等，可以使用==运算符。但是，判断引用类型的变量是否相等，==表示“引用是否相等”，或者说，是否指向同一个对象。例如，下面的两个String类型，它们的内容是相同的，但是，分别指向不同的对象，用==判断，结果为false： 12345678910111213public class Main &#123; public static void main(String[] args) &#123; String s1 &#x3D; &quot;hello&quot;; String s2 &#x3D; &quot;HELLO&quot;.toLowerCase(); System.out.println(s1); System.out.println(s2); if (s1 &#x3D;&#x3D; s2) &#123; System.out.println(&quot;s1 &#x3D;&#x3D; s2&quot;); &#125; else &#123; System.out.println(&quot;s1 !&#x3D; s2&quot;); &#125; &#125;&#125; 输出：s1 != s2 要判断引用类型的变量内容是否相等，必须使用equals()方法： 1234567891011121314public class Main &#123; public static void main(String[] args) &#123; String s1 &#x3D; &quot;hello&quot;; String s2 &#x3D; &quot;HELLO&quot;.toLowerCase(); System.out.println(s1); System.out.println(s2); if (s1.equals(s2)) &#123; System.out.println(&quot;s1 equals s2&quot;); &#125; else &#123; System.out.println(&quot;s1 not equals s2&quot;); &#125; &#125;&#125;输出：s1 equals s2 注意：执行语句s1.equals(s2)时，如果变量s1为null，会报空指针异常NullPointerException： 12345678public class Main &#123; public static void main(String[] args) &#123; String s1 &#x3D; null; if (s1.equals(&quot;hello&quot;)) &#123; System.out.println(&quot;hello&quot;); &#125; &#125;&#125; 如果要处理NullPointerException，可以使用短路运算符&amp;&amp; 123456789public class Main &#123; public static void main(String[] args) &#123; String s1 &#x3D; null; if (s1 !&#x3D; null &amp;&amp; s1.equals(&quot;hello&quot;)) &#123; System.out.println(&quot;hello&quot;); &#125; &#125;&#125;还可以把一定不是null的对象&quot;hello&quot;放到前面：例如：if (&quot;hello&quot;.equals(s)) &#123; ... &#125;。 小结if … else可以做条件判断，else是可选的；不推荐省略花括号{}；多个if … else串联要特别注意判断顺序；要注意if的边界条件；要注意浮点数判断相等不能直接用==运算符；引用类型判断内容相等要使用equals()，注意避免空指针异常NullPointerException。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础_流程控制-1.输入与输出","date":"2020-02-17T05:22:02.614Z","path":"2020/02/17/Java基础_流程控制-1/","text":"输出在前面的代码中，我们总是使用System.out.println()来向屏幕输出一些内容。println是print line的缩写，表示输出并换行。因此，如果输出后不想换行，可以用print() 格式化输出如果要把数据显示成我们期望的格式，就需要使用格式化输出的功能。格式化输出使用System.out.printf()，通过使用占位符%?，printf()可以把后面的参数格式化成指定格式： 1234567public class Main &#123; public static void main(String[] args) &#123; double d &#x3D; 3.1415926; System.out.printf(&quot;%.2f\\n&quot;, d); &#x2F;&#x2F; 显示两位小数3.14 System.out.printf(&quot;%.4f\\n&quot;, d); &#x2F;&#x2F; 显示4位小数3.1416 &#125;&#125; 以下是Java中的多种占位符： 占位符 说明%d 格式化输出整数%x 格式化输出十六进制整数%f 格式化输出浮点数%e 格式化输出科学计数法表示的浮点数%s 格式化字符串 由于%表示占位符，因此，连续两个%%表示一个%字符本身（占位符本身还有更详细的格式化参数，这里就不再赘述） 输入和输出相比，Java的输入就要复杂得多。 123456789101112import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner scanner &#x3D; new Scanner(System.in); &#x2F;&#x2F; 创建Scanner对象 System.out.print(&quot;Input your name: &quot;); &#x2F;&#x2F; 打印提示 String name &#x3D; scanner.nextLine(); &#x2F;&#x2F; 读取一行输入并获取字符串 System.out.print(&quot;Input your age: &quot;); &#x2F;&#x2F; 打印提示 int age &#x3D; scanner.nextInt(); &#x2F;&#x2F; 读取一行输入并获取整数 System.out.printf(&quot;Hi, %s, you are %d\\n&quot;, name, age); &#x2F;&#x2F; 格式化输出 &#125;&#125; 首先，我们通过import语句导入java.util.Scanner，import是导入某个类的语句，必须放到Java源代码的开头，后面我们在Java的package中会详细讲解如何使用import。然后，创建Scanner对象并传入System.in。System.out代表标准输出流，而System.in代表标准输入流。直接使用System.in读取用户输入虽然是可以的，但需要更复杂的代码，而通过Scanner就可以简化后续的代码。有了Scanner对象后，要读取用户输入的字符串，使用scanner.nextLine()，要读取用户输入的整数，使用scanner.nextInt()。Scanner会自动转换数据类型，因此不必手动转换。 小结Java提供的输出包括：System.out.println() / print() / printf()，其中printf()可以格式化输出；Java提供Scanner对象来方便输入，读取对应的类型可以使用：scanner.nextLine() / nextInt() / nextDouble() /","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础","date":"2020-02-16T13:05:49.195Z","path":"2020/02/16/Java基础/","text":"1.基本数据类型 基本数据类型是CPU可以直接进行运算的类型。Java定义了以下几种基本数据类型：整数类型：byte，short，int，long浮点数类型：float，double字符类型：char布尔类型：boolean 不同的数据类型占用的字节数不一样。我们看一下Java基本数据类型占用的字节数：a表示一个字节 byte │ a │ short │ a │ a │ int │ a │ a │ a │ a │ long │ a │ a │ a │ a │ a │ a │ a │ a │ float │ a │ a │ a │ a │ double │ a │ a │ a │ a │ a │ a │ a │ a │ char │ a │ a │ byte恰好就是一个字节，而long和double需要8个字节。 整型对于整型类型，Java只定义了带符号的整型，因此，最高位的bit表示符号位（0表示正数，1表示负数）。各种整型能表示的最大范围如下： 1234byte：-128 ~ 127short: -32768 ~ 32767int: -2147483648 ~ 2147483647long: -9223372036854775808 ~ 9223372036854775807 浮点型浮点类型的数就是小数，因为小数用科学计数法表示的时候，小数点是可以“浮动”的，如1234.5可以表示成12.345x102，也可以表示成1.2345x103，所以称为浮点数。下面是定义浮点数的例子： 12345float f1 = 3.14f;float f2 = 3.14e38f; // 科学计数法表示的3.14x10^38double d = 1.79e308;double d2 = -1.79e308;double d3 = 4.9e-324; // 科学计数法表示的4.9x10^-324 对于float类型，需要加上f后缀。浮点数可表示的范围非常大，float类型可最大表示3.4x1038，而double类型可最大表示1.79x10308。 布尔类型布尔类型boolean只有true和false两个值，布尔类型总是关系运算的计算结果： 12345boolean b1 = true;boolean b2 = false;boolean isGreater = 5 &gt; 3; // 计算结果为trueint age = 12;boolean isAdult = age &gt;= 18; // 计算结果为false Java语言对布尔类型的存储并没有做规定，因为理论上存储布尔类型只需要1 bit，但是通常JVM内部会把boolean表示为4字节整数。 字符类型字符类型char表示一个字符。Java的char类型除了可表示标准的ASCII外，还可以表示一个Unicode字符： 注意char类型使用单引号’，且仅有一个字符，要和双引号”的字符串类型区分开。 常量定义变量的时候，如果加上final修饰符，这个变量就变成了常量： 1234final double PI = 3.14; // PI是一个常量double r = 5.0;double area = PI * r * r;PI = 300; // compile error! 常量在定义时进行初始化后就不可再次赋值，再次赋值会导致编译错误。常量的作用是用有意义的变量名来避免魔术数字（Magic number），例如，不要在代码中到处写3.14，而是定义一个常量。如果将来需要提高计算精度，我们只需要在常量的定义处修改，例如，改成3.1416，而不必在所有地方替换3.14。根据习惯，常量名通常全部大写。 var关键字（java 10 开始使用）有些时候，类型的名字太长，写起来比较麻烦。例如：StringBuilder sb = new StringBuilder(); 这个时候，如果想省略变量类型，可以使用var关键字：var sb = new StringBuilder(); 编译器会根据赋值语句自动推断出变量sb的类型是StringBuilder。对编译器来说，语句：var sb = new StringBuilder(); 实际上会自动变成：StringBuilder sb = new StringBuilder(); 因此，使用var定义变量，仅仅是少写了变量类型而已。 小结Java提供了两种变量类型：基本类型和引用类型基本类型包括整型，浮点型，布尔型，字符型。变量可重新赋值，等号是赋值语句，不是数学意义的等号。常量在初始化后不可重新赋值，使用常量便于理解程序意图。 2.整数运算Java的整数运算遵循四则运算规则，可以使用任意嵌套的小括号。四则运算规则和初等数学一致。 整数的数值表示不但是精确的，而且整数运算永远是精确的，即使是除法也是精确的，因为两个整数相除只能得到结果的整数部分： 1int x = 12345 / 67; // 184 求余运算使用%： 1int y = 12345 % 67; // 12345÷67的余数是17 特别注意：整数的除法对于除数为0时运行时将报错，但编译不会报错。 溢出要特别注意，整数由于存在范围限制，如果计算结果超出了范围，就会产生溢出，而溢出不会出错，却会得到一个奇怪的结果 要解决上面的问题，可以把int换成long类型，由于long可表示的整型范围更大，所以结果就不会溢出： 12345678long x = 2147483640;long y = 15;long sum = x + y;System.out.println(sum); // 2147483655还有一种简写的运算符，即+=，-=，*=，/=，它们的使用方法如下：n += 100; // 3409, 相当于 n = n + 100;n -= 100; // 3309, 相当于 n = n - 100; 自增/自减Java还提供了++运算和–运算，它们可以对一个整数进行加1和减1的操作：// 自增/自减运算 注意++写在前面和后面计算结果是不同的，++n表示先加1再引用n，n++表示先引用n再加1。不建议把++运算混入到常规运算中，容易自己把自己搞懵了。 移位运算在计算机中，整数总是以二进制的形式表示。例如，int类型的整数7使用4字节表示的二进制如下：00000000 0000000 0000000 00000111 可以对整数进行移位运算。对整数7左移1位将得到整数14，左移两位将得到整数28： 1234567891011121314151617181920212223242526int n = 7; // 00000000 00000000 00000000 00000111 = 7int a = n &lt;&lt; 1; // 00000000 00000000 00000000 00001110 = 14int b = n &lt;&lt; 2; // 00000000 00000000 00000000 00011100 = 28int c = n &lt;&lt; 28; // 01110000 00000000 00000000 00000000 = 1879048192int d = n &lt;&lt; 29; // 11100000 00000000 00000000 00000000 = -536870912左移29位时，由于最高位变成1，因此结果变成了负数。类似的，对整数7进行右移，结果如下：int n = 7; // 00000000 00000000 00000000 00000111 = 7int a = n &gt;&gt; 1; // 00000000 00000000 00000000 00000011 = 3int b = n &gt;&gt; 2; // 00000000 00000000 00000000 00000001 = 1int c = n &gt;&gt; 3; // 00000000 00000000 00000000 00000000 = 0如果对一个负数进行右移，最高位的1不动，结果仍然是一个负数：int n = -536870912;int a = n &gt;&gt; 1; // 11110000 00000000 00000000 00000000 = -268435456int b = n &gt;&gt; 2; // 10111000 00000000 00000000 00000000 = -134217728int c = n &gt;&gt; 28; // 11111111 11111111 11111111 11111110 = -2int d = n &gt;&gt; 29; // 11111111 11111111 11111111 11111111 = -1还有一种不带符号的右移运算，使用&gt;&gt;&gt;，它的特点是符号位跟着动，因此，对一个负数进行&gt;&gt;&gt;右移，它会变成正数，原因是最高位的1变成了0：int n = -536870912;int a = n &gt;&gt;&gt; 1; // 01110000 00000000 00000000 00000000 = 1879048192int b = n &gt;&gt;&gt; 2; // 00111000 00000000 00000000 00000000 = 939524096int c = n &gt;&gt;&gt; 29; // 00000000 00000000 00000000 00000111 = 7int d = n &gt;&gt;&gt; 31; // 00000000 00000000 00000000 00000001 = 1 对byte和short类型进行移位时，会首先转换为int再进行位移。仔细观察可发现，左移实际上就是不断地×2，右移实际上就是不断地÷2。 位运算位运算是按位进行与、或、非和异或的运算。与运算的规则是，必须两个数同时为1，结果才为1： 1234n = 0 &amp; 0; // 0n = 0 &amp; 1; // 0n = 1 &amp; 0; // 0n = 1 &amp; 1; // 1 或运算的规则是，只要任意一个为1，结果就为1： 1234n = 0 | 0; // 0n = 0 | 1; // 1n = 1 | 0; // 1n = 1 | 1; // 1 非运算的规则是，0和1互换： 12n = ~0; // 1n = ~1; // 0 异或运算的规则是，如果两个数不同，结果为1，否则为0： 1234n = 0 ^ 0; // 0n = 0 ^ 1; // 1n = 1 ^ 0; // 1n = 1 ^ 1; // 0 对两个整数进行位运算，实际上就是按位对齐，然后依次对每一位进行运算。例如： 1234567public class Main &#123; public static void main(String[] args) &#123; int i = 167776589; // 00001010 00000000 00010001 01001101 int n = 167776512; // 00001010 00000000 00010001 00000000 System.out.println(i &amp; n); // 167776512 &#125;&#125; 运算优先级在Java的计算表达式中，运算优先级从高到低依次是： 12345678()! ~ ++ --\\* / %\\+ -&lt;&lt; &gt;&gt; &gt;&gt;&gt;&amp;|\\+= -= *= /= 记不住也没关系，只需要加括号就可以保证运算的优先级正确。 类型自动提升与强制转型在运算过程中，如果参与运算的两个数类型不一致，那么计算结果为较大类型的整型。例如，short和int计算，结果总是int，原因是short首先自动被转型为int也可以将结果强制转型，即将大范围的整数转型为小范围的整数。强制转型使用(类型)，例如，将int强制转型为short： 12int i = 12345;short s = (short) i; // 12345 小结整数运算的结果永远是精确的；运算结果会自动提升；可以强制转型，但超出范围的强制转型会得到错误的结果；应该选择合适范围的整型（int或long），没有必要为了节省内存而使用byte和short进行整数运算。 3.浮点数的运算浮点数运算和整数运算相比，只能进行加减乘除这些数值计算，不能做位运算和移位运算。在计算机中，浮点数虽然表示的范围大，但是，浮点数有个非常重要的特点，就是浮点数常常无法精确表示。 浮点数0.1在计算机中就无法精确表示，因为十进制的0.1换算成二进制是一个无限循环小数，很显然，无论使用float还是double，都只能存储一个0.1的近似值。但是，0.5这个浮点数又可以精确地表示。因为浮点数常常无法精确表示，因此，浮点数运算会产生误差： 123456789public class Main &#123; public static void main(String[] args) &#123; double x = 1.0 / 10; double y = 1 - 9.0 / 10; // 观察x和y是否相等: System.out.println(x); System.out.println(y); &#125;&#125; 结果：0.10.09999999999999998 浮点数的比较由于浮点数存在运算误差，所以比较两个浮点数是否相等常常会出现错误的结果。正确的比较方法是判断两个浮点数之差的绝对值是否小于一个很小的数： 12345678// 比较x和y是否相等，先计算其差的绝对值:double r = Math.abs(x - y);// 再判断绝对值是否足够小:if (r &lt; 0.00001) &#123; // 可以认为相等&#125; else &#123; // 不相等&#125; 浮点数在内存的表示方法和整数比更加复杂。Java的浮点数完全遵循IEEE-754标准，这也是绝大多数计算机平台都支持的浮点数标准表示方法。 溢出整数运算在除数为0时会报错，而浮点数运算在除数为0时，不会报错，但会返回几个特殊值：NaN表示Not a NumberInfinity表示无穷大-Infinity表示负无穷大例如： 123double d1 = 0.0 / 0; // NaNdouble d2 = 1.0 / 0; // Infinitydouble d3 = -1.0 / 0; // -Infinity 这三种特殊值在实际运算中很少碰到，我们只需要了解即可。 强制转型可以将浮点数强制转型为整数。在转型时，浮点数的小数部分会被丢掉。如果转型后超过了整型能表示的最大范围，将返回整型的最大值。例如： 12345int n1 = (int) 12.3; // 12int n2 = (int) 12.7; // 12int n2 = (int) -12.7; // -12int n3 = (int) (12.7 + 0.5); // 13int n4 = (int) 1.2e20; // 2147483647 如果要进行四舍五入，可以对浮点数加上0.5再强制转型： 1234567public class Main &#123; public static void main(String[] args) &#123; double d = 2.6; int n = (int) (d + 0.5); System.out.println(n); &#125;&#125; 小结浮点数常常无法精确表示，并且浮点数的运算结果可能有误差；比较两个浮点数通常比较它们的绝对值之差是否小于一个特定值；整型和浮点型运算时，整型会自动提升为浮点型；可以将浮点型强制转为整型，但超出范围后将始终返回整型的最大值。 4.布尔运算对于布尔类型boolean，永远只有true和false两个值。布尔运算是一种关系运算，包括以下几类： 1234567891011比较运算符：&gt;，&gt;=，&lt;，&lt;=，==，!=与运算 &amp;&amp;或运算 ||非运算 !下面是一些示例：boolean isGreater = 5 &gt; 3; // trueint age = 12;boolean isZero = age == 0; // falseboolean isNonZero = !isZero; // trueboolean isAdult = age &gt;= 18; // falseboolean isTeenager = age &gt;6 &amp;&amp; age &lt;18; // true 关系运算符的优先级从高到低依次是： 12345!\\&gt;，&gt;=，&lt;，&lt;===，!=&amp;&amp;|| 短路运算布尔运算的一个重要特点是短路运算。如果一个布尔运算的表达式能提前确定结果，则后续的计算不再执行，直接返回结果。因为false &amp;&amp; x的结果总是false，无论x是true还是false，因此，与运算在确定第一个值为false后，不再继续计算，而是直接返回false。 1234567public class Main &#123; public static void main(String[] args) &#123; boolean b = 5 &lt; 3; boolean result = b &amp;&amp; (5 / 0 &gt; 0); System.out.println(result); &#125;&#125; 如果没有短路运算，&amp;&amp;后面的表达式会由于除数为0而报错，但实际上该语句并未报错，原因在于与运算是短路运算符，提前计算出了结果false。如果变量b的值为true，则表达式变为true &amp;&amp; (5 / 0 &gt; 0)。因为无法进行短路运算，该表达式必定会由于除数为0而报错，可以自行测试。类似的，对于||运算，只要能确定第一个值为true，后续计算也不再进行，而是直接返回true 三元运算符Java还提供一个三元运算符b ? x : y，它根据第一个布尔表达式的结果，分别返回后续两个表达式之一的计算结果。注意到三元运算b ? x : y会首先计算b，如果b为true，则只计算x，否则，只计算y。此外，x和y的类型必须相同，因为返回值不是boolean，而是x和y之一。 小结与运算和或运算是短路运算；三元运算b ? x : y后面的类型必须相同，三元运算也是“短路运算”，只计算x或y。 5.字符与字符串字符类型字符类型char是基本数据类型，它是character的缩写。一个char保存一个Unicode字符： 12char c1 = 'A';char c2 = '中'; 因为Java在内存中总是使用Unicode表示字符，所以，一个英文字符和一个中文字符都用一个char类型表示，它们都占用两个字节。要显示一个字符的Unicode编码，只需将char类型直接赋值给int类型即可： 12int n1 = 'A'; // 字母“A”的Unicodde编码是65int n2 = '中'; // 汉字“中”的Unicode编码是20013 还可以直接用转义字符\\u+Unicode编码来表示一个字符：// 注意是十六进制: 12char c3 = '\\u0041'; // 'A'，因为十六进制0041 = 十进制65char c4 = '\\u4e2d'; // '中'，因为十六进制4e2d = 十进制20013 字符串类型和char类型不同，字符串类型String是引用类型，我们用双引号”…”表示字符串。一个字符串可以存储0个到任意个字符： 1234String s = \"\"; // 空字符串，包含0个字符String s1 = \"A\"; // 包含一个字符String s2 = \"ABC\"; // 包含3个字符String s3 = \"中文 ABC\"; // 包含6个字符，其中有一个空格 因为字符串使用双引号”…”表示开始和结束，那如果字符串本身恰好包含一个”字符怎么表示？例如，”abc”xyz”，编译器就无法判断中间的引号究竟是字符串的一部分还是表示字符串结束。这个时候，我们需要借助转义字符\\： 1String s = \"abc\\\"xyz\"; // 包含7个字符: a, b, c, \", x, y, z 因为\\是转义字符，所以，两个\\表示一个\\字符： 1String s = \"abc\\\\xyz\"; // 包含7个字符: a, b, c, \\, x, y, z 常见的转义字符包括： 1234567\\\" 表示字符\"\\' 表示字符'\\\\ 表示字符\\\\n 表示换行符\\r 表示回车符\\t 表示Tab\\u#### 表示一个Unicode编码的字符 字符串连接Java的编译器对字符串做了特殊照顾，可以使用+连接任意字符串和其他数据类型，这样极大地方便了字符串的处理。例如： 12345678public class Main &#123; public static void main(String[] args) &#123; String s1 = \"Hello\"; String s2 = \"world\"; String s = s1 + \" \" + s2 + \"!\"; System.out.println(s); &#125;&#125; 注：如果用+连接字符串和其他数据类型，会将其他数据类型先自动转型为字符串 多行字符串如果我们要表示多行字符串，使用+号连接会非常不方便： 123String s = \"first line \\n\" + \"second line \\n\" + \"end\"; 从Java 13开始，字符串可以用”””…”””表示多行字符串（Text Blocks）了。举个例子： 1234567891011public class Main &#123; public static void main(String[] args) &#123; String s = \"\"\" SELECT * FROM users WHERE id &gt; 100 ORDER BY name DESC \"\"\"; System.out.println(s); &#125;&#125; 上述多行字符串实际上是5行，在最后一个DESC后面还有一个\\n。如果我们不想在字符串末尾加一个\\n，就需要这么写： 12345String s = \"\"\" SELECT * FROM users WHERE id &gt; 100 ORDER BY name DESC\"\"\"; 不可变特性Java的字符串除了是一个引用类型外，还有个重要特点，就是字符串不可变。考察以下代码： 12345678public class Main &#123; public static void main(String[] args) &#123; String s = \"hello\"; System.out.println(s); // 显示 hello s = \"world\"; System.out.println(s); // 显示 world &#125;&#125; 观察执行结果，难道字符串s变了吗？其实变的不是字符串，而是变量s的“指向”。执行String s = “hello”;时，JVM虚拟机先创建字符串”hello”，然后，把字符串变量s指向它： 1234567891011121314 s │ ▼┌───┬───────────┬───┐│ │ \"hello\" │ │└───┴───────────┴───┘紧接着，执行s = \"world\";时，JVM虚拟机先创建字符串\"world\"，然后，把字符串变量s指向它： s ──────────────┐ │ ▼┌───┬───────────┬───┬───────────┬───┐│ │ \"hello\" │ │ \"world\" │ │└───┴───────────┴───┴───────────┴───┘ 原来的字符串”hello”还在，只是我们无法通过变量s访问它而已。因此，字符串的不可变是指字符串内容不可变。理解了引用类型的“指向”后，试解释下面的代码输出 12345678public class Main &#123; public static void main(String[] args) &#123; String s = \"hello\"; String t = s; s = \"world\"; System.out.println(t); // t是\"hello\"还是\"world\"? &#125;&#125; 输出：hello 空值null引用类型的变量可以指向一个空值null，它表示不存在，即该变量不指向任何对象。例如： 1234String s1 = null; // s1是nullString s2; // 没有赋初值值，s2也是nullString s3 = s1; // s3也是nullString s4 = \"\"; // s4指向空字符串，不是null 注意要区分空值null和空字符串””，空字符串是一个有效的字符串对象，它不等于null。 小结Java的字符类型char是基本类型，字符串类型String是引用类型；基本类型的变量是“持有”某个数值，引用类型的变量是“指向”某个对象；引用类型的变量可以是空值null；要区分空值null和空字符串””。 6.数组类型如果有一组类型相同的变量，例如，5位同学的成绩，可以这么写： 12345678910public class Main &#123; public static void main(String[] args) &#123; // 5位同学的成绩: int n1 = 68; int n2 = 79; int n3 = 91; int n4 = 85; int n5 = 62; &#125;&#125; 但其实没有必要定义5个int变量。可以使用数组来表示“一组”int类型定义一个数组类型的变量，使用数组类型“类型[]”，例如，int[]。和单个基本类型变量不同，数组变量初始化必须使用new int[5]表示创建一个可容纳5个int元素的数组。int[] arr = new int[5];Java的数组有几个特点：数组所有元素初始化为默认值，整型都是0，浮点型是0.0，布尔型是false；数组一旦创建后，大小就不可改变。要访问数组中的某一个元素，需要使用索引。数组索引从0开始，例如，5个元素的数组，索引范围是0~4。可以修改数组中的某一个元素，使用赋值语句，例如，ns[1] = 79;。可以用数组变量.length获取数组大小（长度）（数组是引用类型，在使用索引访问数组元素时，如果索引超出范围，运行时将报错） 也可以在定义数组时直接指定初始化的元素，这样就不必写出数组大小，而是由编译器自动推算数组大小例如： 1234567public class Main &#123; public static void main(String[] args) &#123; // 5位同学的成绩: int[] ns = new int[] &#123; 68, 79, 91, 85, 62 &#125;; System.out.println(ns.length); // 编译器自动推算数组大小为5 &#125;&#125; 还可以简写成：int[] ns = { 68, 79, 91, 85, 62 }; 注意数组是引用类型，并且数组大小不可变。例如：定义了一个数组 1ns = new int[] &#123; 68, 79, 91, 85, 62 &#125;; 然后再修改他的长度 1ns = new int[] &#123; 1, 2, 3 &#125;; 数组大小看上去变了，其实没有改变对于数组ns来说，执行ns = new int[] { 68, 79, 91, 85, 62 };时，它指向一个5个元素的数组： 12345678910111213 ns │ ▼┌───┬───┬───┬───┬───┬───┬───┐│ │68 │79 │91 │85 │62 │ │└───┴───┴───┴───┴───┴───┴───┘执行ns = new int[] &#123; 1, 2, 3 &#125;;时，它指向一个新的3个元素的数组： ns ──────────────────────┐ │ ▼┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐│ │68 │79 │91 │85 │62 │ │ 1 │ 2 │ 3 │ │└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘ 但是，原有的5个元素的数组并没有改变，只是无法通过变量ns引用到它们而已。 字符串数组如果数组元素不是基本类型，而是一个引用类型，那么，修改数组元素会有哪些不同？字符串是引用类型，因此我们先定义一个字符串数组： 123String[] names = &#123; \"ABC\", \"XYZ\", \"zoo\"&#125;; 对于String[]类型的数组变量names，它实际上包含3个元素，但每个元素都指向某个字符串对象： 123456789 ┌─────────────────────────┐ names │ ┌─────────────────────┼───────────┐ │ │ │ │ │ ▼ │ │ ▼ ▼┌───┬───┬─┴─┬─┴─┬───┬───────┬───┬───────┬───┬───────┬───┐│ │░░░│░░░│░░░│ │ \"ABC\" │ │ \"XYZ\" │ │ \"zoo\" │ │└───┴─┬─┴───┴───┴───┴───────┴───┴───────┴───┴───────┴───┘ │ ▲ └─────────────────┘ 对names[1]进行赋值，例如names[1] = “cat”;，效果如下： 123456789 ┌─────────────────────────────────────────────────┐ names │ ┌─────────────────────────────────┐ │ │ │ │ │ │ ▼ │ │ ▼ ▼┌───┬───┬─┴─┬─┴─┬───┬───────┬───┬───────┬───┬───────┬───┬───────┬───┐│ │░░░│░░░│░░░│ │ \"ABC\" │ │ \"XYZ\" │ │ \"zoo\" │ │ \"cat\" │ │└───┴─┬─┴───┴───┴───┴───────┴───┴───────┴───┴───────┴───┴───────┴───┘ │ ▲ └─────────────────┘ 这里注意到原来names[1]指向的字符串”XYZ”并没有改变，仅仅是将names[1]的引用从指向”XYZ”改成了指向”cat”，其结果是字符串”XYZ”再也无法通过names[1]访问到了。 小结数组是同一数据类型的集合，数组一旦创建后，大小就不可变；可以通过索引访问数组元素，但索引超出范围将报错；数组元素可以是值类型（如int）或引用类型（如String），但数组本身是引用类型；","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]}]